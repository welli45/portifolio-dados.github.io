[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portifólio de Dados",
    "section": "",
    "text": "Sou uma pessoa curiosa e apaixonada por tecnologia, música e ciência. Acredito que a Sociologia, com seus métodos científicos, aliada à programação e análise de dados, pode ser uma ferramenta poderosa para resolver problemas dentro das organizações e melhorar a vida das pessoas.\nPara mais informações sobre mim clique aqui.\nSinta-se à vontade para entrar em contato comigo através de um dos botões abaixo!\n \n  \n   \n  \n    \n     Twitter\n  \n  \n    \n     Linkedin\n  \n  \n    \n     Kaggle\n  \n  \n    \n     GitHub\n  \n  \n    \n     Lattes\n  \n  \n    \n     Email\nO intuito deste Portifólio é compartilhar conhecimento e experiências, e também para que eu possa ter um registro de tudo que venho aprendendo. Espero que você encontre algo útil por aqui. Seja bem-vindo (a)!"
  },
  {
    "objectID": "index.html#projetos",
    "href": "index.html#projetos",
    "title": "Bem-vindo (a) ao meu portifólio",
    "section": "Projetos",
    "text": "Projetos\nClique aqui para acesar meus projetos.\n\n\n\n\n  \n\n\n\n\nAcessando dados disponíveis no SIDRA IBGE com o pacote sidrar\n\n\nInterface R para a API do SIDRA\n\n\nO pacote R sidrar busca fornecer acesso direto aos dados do SIDRA - Sistema IBGE de Recuperação Automática - dentro do ambiente R de forma fácil e flexível.\n\n\n\n\n\n\nFeb 11, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\n  \n\n\n\n\nAnálise de Redes Usando R\n\n\nIntrodução à Análise de Redes Usando R\n\n\nEste tutorial é uma introdução à análise de redes usando R.\n\n\n\n\n\n\nFeb 11, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#artigos",
    "href": "index.html#artigos",
    "title": "Bem-vindo (a) ao meu portifólio",
    "section": "Artigos",
    "text": "Artigos\nClique aqui para acessar meus meu projetos em Power BI\n\n\n\n\n\n\n\n\nDashboard - Projeto Majestic\n\n\nO relatorio de vendas é um conjunto de dados que permite a visualização de indicadores de vendas de uma empresa.\n\n\n\nWellington Santos Souza\n\n\nFeb 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Qualidade\n\n\nO relatorio de qualidade é um conjunto de dados que permite a visualização de indicadores de qualidade de uma empresa.\n\n\n\nWellington Santos Souza\n\n\nFeb 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Sistema de Informações Sobre Mortalidade\n\n\nO SIM é um sistema de informação que coleta dados sobre mortalidade em todo o território nacional. Este Dashboard foi desenvolvido para fornecer uma visão abrangente dos…\n\n\n\nWellington Santos Souza\n\n\nFeb 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nÍndice de Percepção de Corrupção (IPC)\n\n\nO Índice de Percepção de Corrupção (IPC) é o ranking global de corrupção mais utilizado no mundo. Mede até que ponto o sector público de cada país é considerado corrupto, de…\n\n\n\nWellington Santos Souza\n\n\nFeb 12, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projetos-R/index.html",
    "href": "projetos-R/index.html",
    "title": "Projetos desenvolvidos na liguagem de programação e estatística R",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nIntrodução Álgebra Matricial\n\n\nAplicação em R\n\n\nEsse documento foi desenvolvido para organizar meus estudos em álgebra matricial aplicada em R. Aqui você encontrará conceitos, definições, propriedades e aplicações de matrizes e vetores em R.\n\n\n\n\n\n03 August 2024\n\n\nWellington Santos Souza\n\n\n12 min\n\n\n\n\n\n\n\n\n\n\n\n\nTeste de significância com dados multivariados\n\n\nAplicação em R… EM CONSTRUÇÃO…\n\n\nEsse documento foi desenvolvido para organizar meus estudos em testes de significância com dados multivariados. Aqui, você encontrará informações sobre a aplicação de testes de significância em R, com exemplos práticos e códigos para auxiliar no aprendizado.\n\n\n\n\n\n03 August 2024\n\n\nWellington Santos Souza\n\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\n\nTeste T para amostras independentes e amostras pareadas\n\n\nAplicação em R\n\n\nO tutorial inclui exemplos de como realizar o teste T para amostras independentes e pareadas e verificar pressupostos com comandos específicos no R, além de apresentar gráficos e tabelas para auxiliar na interpretação dos dados.\n\n\n\n\n\n25 May 2024\n\n\nWellington Santos Souza\n\n\n13 min\n\n\n\n\n\n\n\n\n\n\n\n\nAnálise de dados do Programa Universidade para Todos (ProUni)\n\n\nAnálise dos dados com o R - EM CONSTRUÇÃO…\n\n\nO relatório traz algumas análises dos dados disponíveis no portal Dados Abertos\n\n\n\n\n\n09 May 2024\n\n\nWellington Santos Souza\n\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\n\nAnálise de dados da pesquisa DataSenado\n\n\nAnálise dos dados com o R - EM CONSTRUÇÃO…\n\n\nEstimativas pontuais considerando o delineamento amostral\n\n\n\n\n\n03 May 2024\n\n\nWellington Santos Souza\n\n\n16 min\n\n\n\n\n\n\n\n\n\n\n\n\nAcessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE\n\n\nTutorial PNADcIBGE\n\n\nA PNAD Contínua nvestiga as características econômicas e sociais da população, principalmente aquelas relacionadas ao mercado de trabalho\n\n\n\n\n\n14 April 2024\n\n\nWellington Santos Souza\n\n\n7 min\n\n\n\n\n\n\n\n\n\n\n\n\nAcessando dados disponíveis no SIDRA IBGE com o pacote sidrar\n\n\nInterface R para a API do SIDRA\n\n\nO pacote R sidrar busca fornecer acesso direto aos dados do SIDRA - Sistema IBGE de Recuperação Automática - dentro do ambiente R de forma fácil e flexível.\n\n\n\n\n\n11 February 2024\n\n\nWellington Santos Souza\n\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\n\nAnálise de Redes Usando R\n\n\nIntrodução à Análise de Redes Usando R\n\n\nEste tutorial é uma introdução à análise de redes usando R.\n\n\n\n\n\n11 February 2024\n\n\nWellington Santos Souza\n\n\n5 min\n\n\n\n\n\n\nNo matching items\n\n\n  \n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "projetos-R/posts/projeto-sidrar.html",
    "href": "projetos-R/posts/projeto-sidrar.html",
    "title": "Acessando dados disponíveis no SIDRA IBGE com o pacote sidrar",
    "section": "",
    "text": "Este artigo foi reescrito em Domingo, 11 de Fevereiro de 2024."
  },
  {
    "objectID": "projetos-R/posts/projeto-sidrar.html#introdução",
    "href": "projetos-R/posts/projeto-sidrar.html#introdução",
    "title": "Acessando dados disponíveis no SIDRA IBGE com o pacote sidrar",
    "section": "Introdução",
    "text": "Introdução\nEsse tutorial tem como objetivo mostar como podemos acessar de forma fácil os dados disponíveis no SIDRA com o auxílio da linguagem estatística R. Bem como, mostrar alguns exemplos apresentando tabelas e gráficos."
  },
  {
    "objectID": "projetos-R/posts/projeto-sidrar.html#sidra",
    "href": "projetos-R/posts/projeto-sidrar.html#sidra",
    "title": "Acessando dados disponíveis no SIDRA IBGE com o pacote sidrar",
    "section": "SIDRA",
    "text": "SIDRA\nO SIDRA permite consultar informações de todos os indicadores econômicos conjunturais (como os de trabalho e rendimento, inflação, indústria, comércio, serviços, agropecuária e o PIB) e suas séries históricas. Também dá acesso aos resultados de quase todas as pesquisas estruturais do IBGE, inclusive o Censo Demográfico, a Pesquisa Nacional por Amostra de Domicílios (PNAD), a Pesquisa de Orçamentos Familiares (POF), a Pesquisa Nacional de Saúde (PNS) e as pesquisas econômicas anuais.\nO acesso ao website do SIDRA é feito pelo endereço http://sidra.ibge.gov.br. A aplicação também dispõe de uma API (Interface de Programação de Aplicação), que permite a extração dos dados utilizando programas e aplicativos web, pelo endereço http://api.sidra.ibge.gov.br.\nFonte: Agência IBGE\nOs dados disponíveis no SIDRA podem ser acessado com o axílio da linguagem estatística R, com o auxílio do pacote sidrar."
  },
  {
    "objectID": "projetos-R/posts/projeto-sidrar.html#sidrar",
    "href": "projetos-R/posts/projeto-sidrar.html#sidrar",
    "title": "Acessando dados disponíveis no SIDRA IBGE com o pacote sidrar",
    "section": "sidrar",
    "text": "sidrar\nO pacote R “sidrar” busca fornecer acesso direto aos dados do SIDRA - Sistema IBGE de Recuperação Automática - dentro do ambiente R de forma fácil e flexível.\n\nInstalando e carregando o pacote sidrar\nPara instalar e carregar a versão disponível no CRAN:\n\n\nCode\nif(!require(sidrar)){install.packages(\"sidrar\")};library(sidrar)\n# pacote utilizado para manipular os dados\nif(!require(tidyverse)){install.packages(\"tidyverse\")};library(tidyverse)\noptions(scipen = 999)\n\n\n\n\nFunções\nObter tabelas do SIDRA\n\n\nCode\n# ?get_sidra\n\n\nListando todos os parâmetros de uma tabela do SIDRA\n\n\nCode\n# ?info_sidra \n\n\nPesquise nas tabelas do SIDRA com termo(s) específicos\n\n\nCode\n# ?search_sidra  \n\n\n\n\nExemplos\n\nget_sidra\nVamos supor que queremos o Produto Interno Bruto a preços correntes (Mil Reais) para o estado da Bahia nos últimos 10 anos.\nPara isso basta executar:\n\n\nCode\npib &lt;- get_sidra(x = 5938,\n          period = c(\"last\" = 10),\n          variable = 37,\n          geo = \"State\",\n          geo.filter = 29,\n          header = T,\n          format = 3)\n\n\nGráfico com o valor do PIB a Preços correntes para o estado da Bahia\n\n\nCode\npib %&gt;% \n  ggplot(mapping = aes(x=Ano,y=Valor, group = 1))+\n  geom_line(color = \"red\")+\n  geom_point(color = \"blue\")+\n  labs(title = \"PIB a Preços correntes para o estado da Bahia\",\n       subtitle = \"2010-2019\",\n       x=\"Ano\",\n       y=NULL,\n       caption = \"Fonte: IBGE\")+\n  geom_text(aes(x = Ano, y = Valor, label = paste0(Valor)),\n                        vjust = -0.15, size = 2.5)+\n  theme(plot.title = element_text(size=12),axis.text.x= element_text(size=12),\n                            axis.text.y= element_text(size=8), axis.title=element_text(size=6))+\n  theme_grey()\n\n\n\n\n\n\n\n\n\nUtililzando a API da tabela para obter as mesmas informações\n\n\nCode\n# get_sidra(api = \"\")\n\n\n\n\ninfo_sidra\nListando todos os parâmetros da Tabela 5938: Produto interno bruto a preços correntes, impostos, líquidos de subsídios, sobre produtos a preços correntes e valor adicionado bruto a preços correntes total e por atividade econômica, e respectivas participações - Referência 2010.\n\n\nCode\ninfo_sidra(5938)\n\n\n$table\n[1] \"Tabela 5938: Produto interno bruto a preços correntes, impostos, líquidos de subsídios, sobre produtos a preços correntes e valor adicionado bruto a preços correntes total e por atividade econômica, e respectivas participações - Referência 2010\"\n\n$period\n[1] \"2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021\"\n\n$variable\n    cod\n1    37\n2   553\n3   552\n4   497\n5   530\n6   496\n7   543\n8   571\n9   570\n10  545\n11  551\n12  544\n13  498\n14  555\n15  554\n16  500\n17  546\n18  499\n19  513\n20  516\n21  557\n22  556\n23  515\n24  547\n25  514\n26  517\n27  520\n28  559\n29  558\n30  519\n31  548\n32  518\n33 6575\n34 6574\n35 6571\n36 6570\n37 6572\n38 6569\n39 6573\n40  525\n41  528\n42  563\n43  562\n44  527\n45  550\n46  526\n                                                                                                                                                                                                                                                                                                                                desc\n1                                                                                                                                                                                                                                                                               Produto Interno Bruto a preços correntes (Mil Reais)\n2                                                                                                                                                                                                Participação do produto interno bruto a preços correntes no produto interno bruto a preços correntes da microrregião geográfica (%)\n3                                                                                                                                                                                                 Participação do produto interno bruto a preços correntes no produto interno bruto a preços correntes da mesorregião geográfica (%)\n4                                                                                                                                                                                                   Participação do produto interno bruto a preços correntes no produto interno bruto a preços correntes da unidade da federação (%)\n5                                                                                                                                                                                                          Participação do produto interno bruto a preços correntes no produto interno bruto a preços correntes da grande região (%)\n6                                                                                                                                                                                                                 Participação do produto interno bruto a preços correntes no produto interno bruto a preços correntes do Brasil (%)\n7                                                                                                                                                                                                                                                     Impostos, líquidos de subsídios, sobre produtos a preços correntes (Mil Reais)\n8                                                                                                                                          Participação dos impostos, líquidos de subsídios, sobre produtos a preços correntes nos impostos, líquidos de subsídios, sobre produtos a preços correntes da microrregião geográfica (%)\n9                                                                                                                                           Participação dos impostos, líquidos de subsídios, sobre produtos a preços correntes nos impostos, líquidos de subsídios, sobre produtos a preços correntes da mesorregião geográfica (%)\n10                                                                                                                                            Participação dos impostos, líquidos de subsídios, sobre produtos a preços correntes nos impostos, líquidos de subsídios, sobre produtos a preços correntes da unidade da federação (%)\n11                                                                                                                                                   Participação dos impostos, líquidos de subsídios, sobre produtos a preços correntes nos impostos, líquidos de subsídios, sobre produtos a preços correntes da grande região (%)\n12                                                                                                                                                          Participação dos impostos, líquidos de subsídios, sobre produtos a preços correntes nos impostos, líquidos de subsídios, sobre produtos a preços correntes do Brasil (%)\n13                                                                                                                                                                                                                                                                       Valor adicionado bruto a preços correntes total (Mil Reais)\n14                                                                                                                                                                                 Participação do valor adicionado bruto a preços correntes total no valor adicionado bruto a preços correntes total da microrregião geográfica (%)\n15                                                                                                                                                                                  Participação do valor adicionado bruto a preços correntes total no valor adicionado bruto a preços correntes total da mesorregião geográfica (%)\n16                                                                                                                                                                                    Participação do valor adicionado bruto a preços correntes total no valor adicionado bruto a preços correntes total da unidade da federação (%)\n17                                                                                                                                                                                           Participação do valor adicionado bruto a preços correntes total no valor adicionado bruto a preços correntes total da grande região (%)\n18                                                                                                                                                                                                  Participação do valor adicionado bruto a preços correntes total no valor adicionado bruto a preços correntes total do Brasil (%)\n19                                                                                                                                                                                                                                                             Valor adicionado bruto a preços correntes da agropecuária (Mil Reais)\n20                                                                                                                                                                                                  Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes total (%)\n21                                                                                                                                                             Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes da agropecuária da microrregião geográfica (%)\n22                                                                                                                                                              Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes da agropecuária da mesorregião geográfica (%)\n23                                                                                                                                                                Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes da agropecuária da unidade da federação (%)\n24                                                                                                                                                                       Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes da agropecuária da grande região (%)\n25                                                                                                                                                                              Participação do valor adicionado bruto a preços correntes da agropecuária no valor adicionado bruto a preços correntes da agropecuária do Brasil (%)\n26                                                                                                                                                                                                                                                                Valor adicionado bruto a preços correntes da indústria (Mil Reais)\n27                                                                                                                                                                                                     Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes total (%)\n28                                                                                                                                                                   Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes da indústria da microrregião geográfica (%)\n29                                                                                                                                                                    Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes da indústria da mesorregião geográfica (%)\n30                                                                                                                                                                      Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes da indústria da unidade da federação (%)\n31                                                                                                                                                                             Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes da indústria da grande região (%)\n32                                                                                                                                                                                    Participação do valor adicionado bruto a preços correntes da indústria no valor adicionado bruto a preços correntes da indústria do Brasil (%)\n33                                                                                                                                                                                Valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social (Mil Reais)\n34                                                                                                                    Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes total (%)\n35 Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, da microrregião geográfica (%)\n36  Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, da mesorregião geográfica (%)\n37    Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, da unidade da federação (%)\n38           Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, da grande região (%)\n39                  Participação do valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, no valor adicionado bruto a preços correntes dos serviços, exclusive administração, defesa, educação e saúde públicas e seguridade social, do Brasil (%)\n40                                                                                                                                                                                                     Valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social (Mil Reais)\n41                                                                                                                                          Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes total (%)\n42                                              Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social da microrregião geográfic (%)\n43                                              Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social da mesorregião geográfica (%)\n44                                                Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social da unidade da federação (%)\n45                                                       Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social da grande região (%)\n46                                                              Participação do valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social no valor adicionado bruto a preços correntes da administração, defesa, educação e saúde públicas e seguridade social do Brasil (%)\n\n$classific_category\nNULL\n\n$geo\n          cod                          desc\n1      Brazil                    Brasil (1)\n2      Region             Grande Região (5)\n3       State     Unidade da Federação (27)\n4        City             Município (5.570)\n5  MesoRegion  Mesorregião Geográfica (137)\n6 MicroRegion Microrregião Geográfica (558)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mim",
    "section": "",
    "text": "Atualmente, estou cursando o mestrado em Sociologia na Universidade Federal de Minas Gerais, na linha de Sociologia Econômica e das Organizações. Sou também Licenciado em Ciências Sociais, com uma Formação Complementar Aberta em Estatística pela mesma universidade. Ao longo da graduação, participei ativamente do projeto Pescarte, onde desenvolvi minha Iniciação Científica, colaborando com uma equipe multidisciplinar composta por sociólogos, antropólogos, estatísticos e educadores ambientais.\nAlém disso, faço parte do GIARS - Grupo Interdisciplinar de Pesquisa em Análise de Redes Sociais, vinculado à FAFICH da UFMG. Meu interesse profissional e acadêmico se concentra na análise de dados, pesquisa científica, meio ambiente, políticas públicas para redução das desigualdades sociais, geração de emprego e renda, tecnologia e aplicação de ferramentas como linguagem de programação R, Microsoft Power BI, estatística e suas diversas aplicações.s.\nMinha experiência abrange a condução de análises de dados de saúde, elaboração de relatórios detalhados e a criação de dashboards interativos no Power BI. As certificações recentes, incluindo SQL, Git e Google Data Analytics, demonstram meu comprometimento com a aprendizagem contínua. Possuo habilidades avançadas em R e Power BI.\n\nExperiênciaSkillsFerramentasIdiomas\n\n\nAnalista de Dados | Governo do Estado de Minas Gerais\nMarço de 2023 – Atualmente\n\nDesenvolvimento e construção de relatórios utilizando o Power BI para aprimorar o monitoramento de qualidade.\nUtilização de R para manipulação e geração de amostras de dados, contribuindo para análises estatísticas mais eficientes.\nColaboração no Núcleo de Estatística da Assessoria Estratégica, fornecendo insights valiosos por meio de análises de dados.\nAplicação de competências em Rstudio, Limpeza de Dados e outras 8 competências para otimizar processos analíticos.\n\nEstágio em Análise de Dados - Assessoria de Gestão do Fundo Estadual de Assistência Social – AGFEAS | Governo do Estado de Minas Gerais\nNovembro de 2022 – Fevereiro de 2023\n\nOfereci suporte proativo nas atividades de análise de dados, destacando-me no manejo do Piso Mineiro de Assistência Social e proporcionando insights cruciais para tomadas de decisão informadas.\nDesempenhei um papel crucial na implementação eficaz de linguagens de programação, notadamente R, na Assessoria de Gestão, promovendo a eficiência e modernização dos processos analíticos.\nCooperei de forma integral nas atividades administrativas do Fundo Estadual de Assistência Social, priorizando a organização e integridade dos dados.\n\nEstágio em Pesquisa - Análise de Redes Sociais e Análise de Dados | Instituto Cordial\nMaio de 2022 – Novembro de 2022\n\nCondução da coleta e manipulação de dados públicos de saúde, incluindo fontes como PNS, Vigitel, Sisvan e POF, utilizando a linguagem de programação R. Essa atuação permitiu uma abordagem mais precisa e eficiente na análise de informações relevantes.\nElaboração de relatórios de pesquisa detalhados, consolidando os resultados obtidos a partir da análise de dados de saúde. Destaque para a capacidade de apresentar de forma clara e concisa insights valiosos extraídos dos conjuntos de dados.\nConstrução de dashboards interativos no Power BI, proporcionando uma visualização intuitiva e acessível das tendências e padrões identificados nos dados de saúde. Essa ferramenta contribuiu para uma compreensão mais abrangente e rápida das informações, facilitando a tomada de decisões.\nColaboração ativa com a equipe de pesquisa, compartilhando conhecimentos sobre análise de redes sociais e análise de dados, contribuindo assim para um ambiente colaborativo e de aprendizado mútuo.\n\n\n\nProgramação\nPython, Jupyter, R, Quarto, SQL, Git, GitHub, Markdown\nAnálise de Dados\nAnálise dos dados, Coleta de Dados, Ética em Dados, Limpeza de dados, Metadados, Planilha, Questionamento, Solução de problemas, SQL, Tomada de decisões, Visualização de dados (DataViz)\nAnálise de Redes Sociais\nAnálise de Redes Sociais, Análise de Redes Sociais com R, Análise de Redes Sociais com Python, Análise de Redes Sociais com Gephi, Análise de Redes Sociais com UCINET, Análise de Redes Sociais com Pajek\nEstatística\nEstatística Descritiva, Estatística para Análise de Dados, Estatística para Pesquisa, Estatística para Redes Sociais, Amostragem, Análise de Regressão, Teste de Hipóteses\n\n\nMicrosoft Power BI, Tableau, Google Data Studio, Microsoft Excel, Google Sheets, Microsoft Word, Google Docs, Microsoft PowerPoint, Google Slides\n\n\nInglês | (intermediário) – leitura e conversação.\nEspanhol | (intermediário) – leitura e conversação.\nPortuguês | Fluente\n\n\n\n\nFormaçãoProjetosCertificações/Cursos\n\n\nLicenciatura em Ciências Sociais\nUniversidade Federal de Minas Gerais, fevereiro de 2019 – dezembro de 2023\nFormação Complementar em Estatística\nUniversidade Federal de Minas Gerais, março de 2021 – julho de 2023\nEnsino Técnico em Qualidade\nUniversidade Estadual de Campinas, 2016 – 2017\n\n\nIniciação Científica - Fundação IPEAD-UFMG\nPeríodo: Janeiro de 2021 - Janeiro de 2024\nProjeto PESCARTE - Pesquisa-Ação para Melhoria das Condições de Vida de Comunidades de Pescadores Tradicionais na Bacia de Campos\n\nContribuí ativamente para o Projeto PESCARTE, uma pesquisa-ação destinada a aprimorar as condições de vida das comunidades de pescadores tradicionais na Bacia de Campos, em conformidade com as exigências institucionais para mitigar os impactos socioambientais da indústria petrolífera.\nParticipação integral na Linha de Pesquisa 7: Redes Sociais em Comunidades de Pesca Artesanal, com ênfase especial em dados georreferenciados.\nDesenvolvimento de revisões bibliográficas abrangentes, consolidando conhecimentos fundamentais para o embasamento teórico da pesquisa.\nElaboração de metodologias inovadoras para a coleta de dados cognitivos através de informantes-chave, visando uma compreensão mais profunda das comunidades estudadas.\nConstrução de questionários de pesquisa eficazes, contribuindo para a coleta de dados relevantes e abrangentes.\nDesenvolvimento de metodologias de coleta de dados georreferenciados, enfatizando a importância da localização geográfica na análise das comunidades.\nTreinamento da equipe de pesquisa em metodologias avançadas de análise de redes em ciências sociais, promovendo uma abordagem integrada e abrangente.\nParticipação ativa em grupos focais, atuando como redator e facilitador para validar informações e garantir a qualidade dos dados coletados.\nElaboração de relatórios de pesquisa detalhados, consolidando os resultados e insights obtidos ao longo do projeto.\n\n\n\n\n09/2024: Calculus for Machine Learning and Data Science - DeepLearning.AI\n08/2024: Linear Algebra for Machine Learning and Data Science - DeepLearning.AI\n01/2024: SQL para Análise de Dados – Udemy\n07/2024: Regressão Linear – MQ – UFMG\n08/2023: Master DAX – Power BI Orientado ao Projeto – Udemy\n08/2023: Data Storytelling – Udemy\n06/2023: Certificado Profissional de Análise de Dados do Google – Coursera.\n02/2023: Power BI Data Modeling with DAX – LinkedIn.\n02/2023: SQL for Data Science – Coursera.\n02/2023: Cleaning Bad Data in R – LinkedIn.\n01/2023: Introdução às Competências Essenciais para a Análise de Dados – LinkedIn.\n01/2023: Master Power BI - De A à Z – Udemy.\n03/2022: Microsoft Power BI Para Data Science, Versão 2.0 – Data Science Academy.\n03/2022: Dashboards com Google Data Studio – IBPAD.\n01/2022: Análise de Redes com R – IBPAD.\n01/2022: Análise de Dados em Linguagem R – Enap.\n11/2021: R Intermediário – Meios – Empresa Júnior de Ciências Sociais.\n06/2021: Descubra a Linguagem de Programação R – Linkedin Learning.\n10/2020: Metodologia de Survey – Meios – Empresa Júnior de Ciências Sociais – UFMG.\n04/2020: Ciência de Dados com R – Udemy.\n\n\n\n\n \n\n\n Back to top"
  },
  {
    "objectID": "projetos-PBI/index.html",
    "href": "projetos-PBI/index.html",
    "title": "Projetos - Power BI",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nDashboard - Projeto Majestic\n\n\nDashboard Interativo\n\n\nO relatorio de vendas é um conjunto de dados que permite a visualização de indicadores de vendas de uma empresa.\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Qualidade\n\n\nDashboard Interativo\n\n\nO relatorio de qualidade é um conjunto de dados que permite a visualização de indicadores de qualidade de uma empresa.\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Sistema de Informações Sobre Mortalidade\n\n\nDashboard Interativo\n\n\nO SIM é um sistema de informação que coleta dados sobre mortalidade em todo o território nacional. Este Dashboard foi desenvolvido para fornecer uma visão abrangente dos dados coletados, permitindo a análise de tendências e a identificação de padrões relevantes.\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nProjeto final de Data Analytics do Google\n\n\nDashboard Interativo\n\n\nO Projeto Final de Data Analytics do Google consistiu em uma análise sobre o perfil religioso do Brasil, utilizando um conjunto de dados público do Censo de 2000 e 2010 do IBGE. O processo começou com a formulação da pergunta de pesquisa, que foi definida como investigar o perfil religioso da população brasileira.\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\n\nÍndice de Percepção de Corrupção (IPC)\n\n\nDashboard Interativo\n\n\nO Índice de Percepção de Corrupção (IPC) é o ranking global de corrupção mais utilizado no mundo. Mede até que ponto o sector público de cada país é considerado corrupto, de acordo com especialistas e empresários.\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "projetos-Python/index.html",
    "href": "projetos-Python/index.html",
    "title": "Projetos em Python",
    "section": "",
    "text": "Aqui você pode encontrar meus Projetos e Aprendizados.\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nAnálise exploratória de dados\n\n\nIntrodução ao Pandas\n\n\nPandas\n\n\n\n\n\n12 September 2024\n\n\nWellington Santos Souza\n\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\n\nDerivadas usando Sympy e Numpy\n\n\nDerivadas com Python\n\n\n\n\n\n\n\n\n23 August 2024\n\n\nWellington Santos Souza\n\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\n\nOtimização usando Gradient Descent em duas variáveis usando Python\n\n\n\n\n\nAnotações do módulo 2 do curso de Cálculo para aprendizado de máquina e ciência de dados\n\n\n\n\n\n04 August 2024\n\n\nWellington Santos Souza\n\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\n\nOtimização usando Gradient Descent em uma variável Usando Python\n\n\n\n\n\nAnotações do módulo 2 do curso de Cálculo para aprendizado de máquina e ciência de dados\n\n\n\n\n\n04 August 2024\n\n\nWellington Santos Souza\n\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\n\nCOLETANDO DADOS DO SIDRA COM O PYTHON\n\n\nsidrapy\n\n\n\n\n\n\n\n\n12 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "projetos-Python/posts/projeto-sidrapy.html",
    "href": "projetos-Python/posts/projeto-sidrapy.html",
    "title": "COLETANDO DADOS DO SIDRA COM O PYTHON",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda, 25 de Março de 2024.\n\nCOLETANDO DADOS DO SIDRA COM O PYTHON\nO primeiro passo será instalar a biblioteca sidrapy, se estiver usando o VSCode pode digitar o código pip install sidrapy no termianl que você irá instalar a biblioteca usada para fazer o download dos dados.\nO segundo passo será importar essa biblioteca para isso faça;\n\n\nCode\nimport sidrapy\n\n\nAgora que temos nossa biblioteca instalada vamos baixar nossos dados.\n\n\nCode\n# Importa os dados do SIDRA\npib_sa_raw = sidrapy.get_table(table_code= \"1621\",\n                            territorial_level = \"1\",\n                            ibge_territorial_code = \"all\",\n                            period = \"all\",\n                            classification = \"11255/90707\")\n\n# Checamos a importação\npib_sa_raw.head()\n\n\n\n\n\n\n\n\n\nNC\nNN\nMC\nMN\nV\nD1C\nD1N\nD2C\nD2N\nD3C\nD3N\nD4C\nD4N\n\n\n\n\n0\nNível Territorial (Código)\nNível Territorial\nUnidade de Medida (Código)\nUnidade de Medida\nValor\nBrasil (Código)\nBrasil\nTrimestre (Código)\nTrimestre\nSetores e subsetores (Código)\nSetores e subsetores\nVariável (Código)\nVariável\n\n\n1\n1\nBrasil\n30\nNúmero-índice\n99.42\n1\nBrasil\n199601\n1º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n2\n1\nBrasil\n30\nNúmero-índice\n100.65\n1\nBrasil\n199602\n2º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n3\n1\nBrasil\n30\nNúmero-índice\n104.16\n1\nBrasil\n199603\n3º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n4\n1\nBrasil\n30\nNúmero-índice\n103.38\n1\nBrasil\n199604\n4º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n\n\n\n\n\n\n\nCode\n# Substitui as colunas pela primeira observação\npib_sa_raw.columns = pib_sa_raw.iloc[0]\n\n# Retira a primeira observação\npib_sa_raw = pib_sa_raw.iloc[1:, :]\n\n# Altera para float a coluna do valor\npib_sa_raw['Valor'] = pib_sa_raw['Valor'].astype(float)\npib_sa_raw.head()\n\n\n\n\n\n\n\n\n\nNível Territorial (Código)\nNível Territorial\nUnidade de Medida (Código)\nUnidade de Medida\nValor\nBrasil (Código)\nBrasil\nTrimestre (Código)\nTrimestre\nSetores e subsetores (Código)\nSetores e subsetores\nVariável (Código)\nVariável\n\n\n\n\n1\n1\nBrasil\n30\nNúmero-índice\n99.42\n1\nBrasil\n199601\n1º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n2\n1\nBrasil\n30\nNúmero-índice\n100.65\n1\nBrasil\n199602\n2º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n3\n1\nBrasil\n30\nNúmero-índice\n104.16\n1\nBrasil\n199603\n3º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n4\n1\nBrasil\n30\nNúmero-índice\n103.38\n1\nBrasil\n199604\n4º trimestre 1996\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n5\n1\nBrasil\n30\nNúmero-índice\n104.41\n1\nBrasil\n199701\n1º trimestre 1997\n90707\nPIB a preços de mercado\n584\nSérie encadeada do índice de volume trimestral...\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html#projetos-em-r",
    "href": "index.html#projetos-em-r",
    "title": "Portifólio de Dados",
    "section": "Projetos em R",
    "text": "Projetos em R\nClique aqui para acesar meus projetos em R.\n\n\n\n\n\n\n\n\n\n\nIntrodução Álgebra Matricial\n\n\nAplicação em R\n\n\nEsse documento foi desenvolvido para organizar meus estudos em álgebra matricial aplicada em R. Aqui você encontrará conceitos, definições, propriedades e aplicações de matrizes e vetores em R.\n\n\n\n\n\nAug 3, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\n\n\n\n\n\n\nTeste de significância com dados multivariados\n\n\nAplicação em R… EM CONSTRUÇÃO…\n\n\nEsse documento foi desenvolvido para organizar meus estudos em testes de significância com dados multivariados. Aqui, você encontrará informações sobre a aplicação de testes de significância em R, com exemplos práticos e códigos para auxiliar no aprendizado.\n\n\n\n\n\nAug 3, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\n\n\n\n\n\n\nTeste T para amostras independentes e amostras pareadas\n\n\nAplicação em R\n\n\nO tutorial inclui exemplos de como realizar o teste T para amostras independentes e pareadas e verificar pressupostos com comandos específicos no R, além de apresentar gráficos e tabelas para auxiliar na interpretação dos dados.\n\n\n\n\n\nMay 25, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html",
    "href": "projetos-R/posts/projeto-ARS.html",
    "title": "Análise de Redes Usando R",
    "section": "",
    "text": "Este artigo foi reescrito em Domingo, 11 de Fevereiro de 2024."
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#introdução",
    "href": "projetos-R/posts/projeto-ARS.html#introdução",
    "title": "Análise de Redes Usando R",
    "section": "Introdução",
    "text": "Introdução\nA análise de redes sociais (ARS) é uma abordagem teórico-metodológica que tem como objetivo estudar as relações sociais entre atores. A ARS tem sido amplamente utilizada em diversas áreas do conhecimento, tais como sociologia, antropologia, psicologia, administração, economia, ciência política, entre outras. A ARS tem como base teórica a teoria dos grafos, que é um ramo da matemática que estuda as relações entre os objetos de um conjunto. A teoria dos grafos é uma ferramenta poderosa para a análise de redes sociais, pois permite a representação e a análise de redes sociais de forma rigorosa e sistemática.A análise de redes sociais permite a identificação de padrões de relações sociais, tais como centralidade, coesão, densidade, entre outros."
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#objetivos",
    "href": "projetos-R/posts/projeto-ARS.html#objetivos",
    "title": "Análise de Redes Usando R",
    "section": "Objetivos",
    "text": "Objetivos\nO tutorial tem como objetivo apresentar os conceitos básicos da análise de redes sociais, bem como as principais ferramentas e técnicas para a análise de redes sociais usando R."
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#começando",
    "href": "projetos-R/posts/projeto-ARS.html#começando",
    "title": "Análise de Redes Usando R",
    "section": "Começando",
    "text": "Começando\nPara começar nossa analise precisamos instalar alguns pacotes, para isso vamos usar o comando install.packages para instalar os pacotes igraph e sand.\n\n\nCode\nif(!require(igraph)) install.packages(\"igraph\")\nif(!require(sand)) install.packages(\"sand\")\nif(!require(ggraph)) install.packages(\"ggraph\")\nif(!require(tidyverse)) install.packages(\"tidyverse\")\nif(!require(tidygraph)) install.packages(\"tidygraph\")\nif(!require(viridis)) install.packages(\"viridis\")\nif(!require(patchwork)) install.packages(\"patchwork\")\nif(!require(hrbrthemes)) install.packages(\"hrbrthemes\")\nif(!require(networkD3)) install.packages(\"networkD3\")\nif(!require(kableExtra))install.packages(\"kableExtra\")\nif(!require(summarytools))install.packages(\"summarytools\")\n\n\nNa sequência vamos carregar os pacotes que acabamos de instalar.\n\n\nCode\nlibrary(igraph)\nlibrary(sand)\nlibrary(ggraph)\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(viridis)\nlibrary(patchwork)\nlibrary(hrbrthemes)\nlibrary(networkD3)\nlibrary(kableExtra)\nlibrary(summarytools)\n\n\nAgora que já instalamos e carregamos os pacotes, vamos começar a nossa análise. Para isso precisamos de um conjunto de dados, para isso vamos usar o conjunto de dados aidsblog que está disponível no pacote sand.\n\n\nCode\n# help(aidsblog)\n\n# Evitando menssagens de erro...\naidsblog &lt;- upgrade_graph(aidsblog)"
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#visualizando-o-grafo",
    "href": "projetos-R/posts/projeto-ARS.html#visualizando-o-grafo",
    "title": "Análise de Redes Usando R",
    "section": "Visualizando o Grafo",
    "text": "Visualizando o Grafo\nPlotandoo Grafo\n\n\nCode\nplot(aidsblog)\n\n\n\n\n\n\n\n\n\nEsse grafo ficou um pouco confuso, vamos tentar melhorar a visualização.\nPrimeiro vamos remover os labels dos vértices.\n\n\nCode\nplot(aidsblog, vertex.label=NA)\n\n\n\n\n\n\n\n\n\nAinda assim está confuso, vamos tentar melhorar a visualização.\nVamos reduzir o tamanho dos vértices e mudar o layout do grafo para Kamala Kawai\n\n\nCode\nplot(aidsblog, vertex.label=NA, vertex.size=5, layout=layout.kamada.kawai)\n\n\n\n\n\n\n\n\n\nMelhrou, mas mesmo assim ainda está confuso. Vamos tentar melhorar a visualização. Agora vamos diminuir o tamanho das setas.\n\n\nCode\nplot(aidsblog, vertex.label=NA, vertex.size=5, layout=layout.kamada.kawai, edge.arrow.size=0.3)\n\n\n\n\n\n\n\n\n\nAgora sim, a visualização está bem melhor.\n\nMelhorando a visualização com o pacote ggraph\nPodemos melhorar um pouco mais com o pacote ggraph.\n\n\nCode\ngrafo &lt;- as_tbl_graph(aidsblog)\n\nggraph(grafo, layout = \"kk\") +\n  geom_edge_link(colour =\"#666666\") +\n  geom_node_point(colour =\"#69b3a2\", size = 5) +\n  theme_void()\n\n\n\n\n\n\n\n\n\nFicou legal, mas vamos melhorar essa visualização.\n\n\nCode\ngrafo_data &lt;- as_long_data_frame(aidsblog)\nsimpleNetwork(grafo_data,     \n        Source = 1,                 \n        Target = 2,                \n        height = 880,               \n        width = 1980,\n        linkDistance = 100,         \n        charge = -4,              \n        fontSize = 5,              \n        fontFamily = \"serif\",       \n        linkColour = \"#666\",        \n        nodeColour = \"#69b3a2\",     \n        opacity = 0.9,              \n        zoom = T                    \n        )\n\n\nWarning: It looks like Source/Target is not zero-indexed. This is required in\nJavaScript and so your plot may not render."
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#métricas-de-rede",
    "href": "projetos-R/posts/projeto-ARS.html#métricas-de-rede",
    "title": "Análise de Redes Usando R",
    "section": "Métricas de Rede",
    "text": "Métricas de Rede\n\n\nCode\ndata.frame(Métrica = c(\"Número de nós\",\n                       \"Número de relacões\",\n                       \"Número de componentes\",\n                       \"Densidade\",\n                       \"Distancia geodésica média\",\n                       \"Diâmetro\",\n                       \"Transitividade global\",\n                       \"Transitividade local\"\n),Valor = c(round(gorder(aidsblog),1),\n          round(gsize(aidsblog),1),\n          round(components(aidsblog)$no,2),\n          round(edge_density(aidsblog),2),\n          round(mean_distance(aidsblog),2),\n          round(diameter(aidsblog),2),\n          round(transitivity(aidsblog, type = \"global\"),2),\n          round(transitivity(aidsblog, type = \"localaverage\"),2)\n)\n)%&gt;%\n  kbl(caption = \"Métricas da Rede\") %&gt;%\n  kable_classic(full_width = T, html_font = \"Cambria\") \n\n\n\n\nMétricas da Rede\n\n\nMétrica\nValor\n\n\n\n\nNúmero de nós\n146.00\n\n\nNúmero de relacões\n187.00\n\n\nNúmero de componentes\n1.00\n\n\nDensidade\n0.01\n\n\nDistancia geodésica média\n2.89\n\n\nDiâmetro\n6.00\n\n\nTransitividade global\n0.02\n\n\nTransitividade local\n0.25\n\n\n\n\n\n\n\n\n\n\nCode\nnos &lt;- as.data.frame(V(aidsblog))\n\n# Centralidade de grau\nnos$grau &lt;- degree(aidsblog)\n\n# grau de intermediação\nnos$intermediacao &lt;- betweenness(aidsblog)\n\n# grau de proximidade\nnos$proximidade &lt;- closeness(aidsblog, normalized = TRUE)\n\n# Excentricidade\nnos$excentricidade &lt;- eccentricity(aidsblog)\n\n# Centralidade de autovetor\nnos$autovetor &lt;- eigen_centrality(aidsblog)$vector\n\n# Criando tabela com métricas\n(metricas_ind &lt;- nos %&gt;%\n    select(grau, intermediacao, proximidade, excentricidade, autovetor) %&gt;%\n    descr(stats = c(\"min\", \"q1\", \"med\", \"mean\", \"sd\", \"q3\", \"max\"), transpose = TRUE))\n\n\nDescriptive Statistics  \nnos  \nN: 146  \n\n                        Min     Q1   Median    Mean   Std.Dev     Q3      Max\n-------------------- ------ ------ -------- ------- --------- ------ --------\n           autovetor   0.00   0.03     0.07    0.09      0.12   0.11     1.00\n      excentricidade   3.00   5.00     5.00    5.09      0.62   5.00     6.00\n                grau   1.00   1.00     1.00    2.56      5.85   1.00    43.00\n       intermediacao   0.00   0.00     0.00   10.07     51.32   0.00   423.75\n         proximidade   0.23   0.29     0.44    0.53      0.31   0.78     1.00"
  },
  {
    "objectID": "projetos-R/posts/projeto-ARS.html#referências",
    "href": "projetos-R/posts/projeto-ARS.html#referências",
    "title": "Análise de Redes Usando R",
    "section": "Referências",
    "text": "Referências\nS. Gopal, The evolving social geography of blogs. In Societies and Cities in the Age of Instant Access, ed. by H. Miller (Springer, Berlin, 2007), 139 pp. 275-294."
  },
  {
    "objectID": "projetos-PBI/posts/projeto-dax.html",
    "href": "projetos-PBI/posts/projeto-dax.html",
    "title": "Dashboard - Projeto Majestic",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n\nCom o objetivo de aprimorar meus conhecimentos em Linguagem DAX, decidi realizar o curso oferecido pelo instrutor Felipe Mafra na plataforma Udemy. Durante o curso, tive a oportunidade de significativamente aprimorar minha compreensão em DAX, por meio da execução de um projeto abrangente com foco na aplicação prática. Nesse projeto, assumi o papel de analista de Power BI na empresa Majestic, uma exportadora de materiais escolares. Ao longo desse cenário fictício, desenvolvemos relatórios que abrangem áreas como vendas, classificação de gerentes, margem de lucro por continente e país. Além disso, também exploramos a criação de elementos visuais dinâmicos, os quais se adaptam de acordo com as métricas selecionadas. Essa experiência proporcionou um ambiente de aprendizado altamente envolvente, no qual pude não apenas aprimorar minha habilidade com a Linguagem DAX, mas também entender como aplicá-la de maneira eficaz em situações do mundo real.\nAo compartilhar este projeto, desejo ressaltar a importância da Linguagem DAX como uma ferramenta poderosa para a análise de dados. A capacidade de criar cálculos personalizados e métricas específicas é fundamental para a compreensão aprofundada dos dados e a geração de insights valiosos. Além disso, a utilização do Power BI como ferramenta de visualização ressalta a importância da proficiência em tecnologias contemporâneas para impulsionar a eficácia das análises de vendas.\n\nDashboard Interativo\nVocê pode explorar o Dashboard interativo abaixo\n\n\nDownload Dashboard - Projeto Majestic\n\n\n\n\n Back to top"
  },
  {
    "objectID": "projetos-PBI/posts/projeto-ipc.html",
    "href": "projetos-PBI/posts/projeto-ipc.html",
    "title": "Índice de Percepção de Corrupção (IPC)",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n}\nO Índice de Percepção de Corrupção (IPC) é o ranking global de corrupção mais utilizado no mundo. Mede até que ponto o sector público de cada país é considerado corrupto, de acordo com especialistas e empresários.\nA pontuação de cada país é uma combinação de pelo menos 3 fontes de dados extraídas de 13 pesquisas e avaliações diferentes sobre corrupção. Estas fontes de dados são recolhidas por diversas instituições conceituadas, incluindo o Banco Mundial e o Fórum Económico Mundial.\nA pontuação de um país é o nível percebido de corrupção no sector público numa escala de 0 a 100, onde 0 significa altamente corrupto e 100 significa muito limpo.\nA classificação de um país é a sua posição em relação aos outros países no índice. As classificações podem mudar apenas se o número de países incluídos no índice mudar.\nA classificação não é, portanto, tão importante como a pontuação em termos de indicar o nível de corrupção nesse país.\nA pontuação de um país pode mudar de um ano para o outro, mas as mudanças são geralmente pequenas. As mudanças significativas são raras, mas podem acontecer.\nFonte: https://www.transparency.org/en/news/how-cpi-scores-are-calculated\n\nDashboard Interativo\nVocê pode explorar o Dashboard interativo abaixo\n\n\nDashboard Corruption Perceptions Index (CPI)\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html#projetos-em-power-bi",
    "href": "index.html#projetos-em-power-bi",
    "title": "Portifólio de Dados",
    "section": "Projetos em Power BI",
    "text": "Projetos em Power BI\nClique aqui para acessar meus meu projetos em Power BI\n\n\n\n\n\n\n\n\n\n\nDashboard - Projeto Majestic\n\n\nDashboard Interativo\n\n\nO relatorio de vendas é um conjunto de dados que permite a visualização de indicadores de vendas de uma empresa.\n\n\n\n\n\nFeb 12, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Qualidade\n\n\nDashboard Interativo\n\n\nO relatorio de qualidade é um conjunto de dados que permite a visualização de indicadores de qualidade de uma empresa.\n\n\n\n\n\nFeb 12, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard de Sistema de Informações Sobre Mortalidade\n\n\nDashboard Interativo\n\n\nO SIM é um sistema de informação que coleta dados sobre mortalidade em todo o território nacional. Este Dashboard foi desenvolvido para fornecer uma visão abrangente dos dados coletados, permitindo a análise de tendências e a identificação de padrões relevantes.\n\n\n\n\n\nFeb 12, 2024\n\n\nWellington Santos Souza\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projetos-PBI/posts/projeto-sim.html",
    "href": "projetos-PBI/posts/projeto-sim.html",
    "title": "Dashboard de Sistema de Informações Sobre Mortalidade",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n\nO Dashboard de hoje foi elaborado utilizando informações provenientes do Sistema de Informações sobre Mortalidade (SIM), obtidas a partir da https://basedosdados.org/ (Base dos Dados). O SIM foi desenvolvido pelo DATASUS com o propósito de adquirir regularmente dados acerca da mortalidade em todo o país. A instauração do SIM possibilitou a coleta abrangente de dados referentes a óbitos, fornecendo um embasamento substancial para as diversas instâncias envolvidas na administração da saúde pública. Com base nisso, foi concebido este Dashboard, estruturando as informações acerca do volume de óbitos por região, Unidade da Federação e município. Adicionalmente, essas informações são segmentadas por gênero e identificação étnico-racial, permitindo uma análise mais detalhada dos dados.\nO Dashboard é composto por quatro páginas distintas, cada uma fornecendo uma perspectiva única dos dados coletados. A primeira página apresenta uma visão geral dos óbitos registrados, permitindo a visualização de tendências ao longo do tempo. Além disso, é possível identificar padrões relevantes relacionados à distribuição dos óbitos por região e Unidade da Federação. A segunda página do Dashboard se concentra na análise dos óbitos por UF e Capitais do Brasil. A terceira se concentra nos dados por UF e Municípios´. Já a quarta página você pode explorar os dados com base em critérios específicos, como gênero, identificação étnico-racial, faixa etária e região. Isso permite uma compreensão mais detalhada da distribuição dos óbitos em relação a esses critérios, fornecendo insights valiosos para a formulação de políticas públicas e ações de saúde.\n\nDashboard Interativo\nVocê pode explorar o Dashboard interativo abaixo\n\n\nDashboard Sistema de Informações sobre Mortalidade\n\n\n\n\n Back to top"
  },
  {
    "objectID": "projetos-PBI/posts/projeto-qualidade.html",
    "href": "projetos-PBI/posts/projeto-qualidade.html",
    "title": "Dashboard de Qualidade",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024."
  },
  {
    "objectID": "projetos-PBI/posts/projeto-qualidade.html#resumo-do-projeto",
    "href": "projetos-PBI/posts/projeto-qualidade.html#resumo-do-projeto",
    "title": "Dashboard de Qualidade",
    "section": "Resumo do Projeto",
    "text": "Resumo do Projeto\nVisando aplicar os conhecimentos adquiridos no curso técnico em qualidade, concluído em 2017 no COTIL-UNICAMP, e aprimorar minhas habilidades no Power BI, decidi criar um Dashboard fictício como exercício prático. Este Dashboard possui duas páginas distintas, cada uma fornecendo informações relevantes relacionadas à análise de qualidade, permitindo uma compreensão abrangente dos dados.\nA primeira página do Dashboard apresenta uma visão geral das amostras analisadas, abrangendo diferentes métricas essenciais. São exibidos dados como o número de defeitos identificados, o score de qualidade obtido e a quantidade de erros fatais registrados. Além disso, essas informações são desagregadas com base em diversos critérios, como local de trabalho, supervisor, auditor e funcionário responsável. Tudo isso é apresentado num intervalo de datas específico, possibilitando a identificação de tendências ao longo do tempo.\nA segunda página do Dashboard se concentra na avaliação de desempenho individual de cada funcionário e supervisor, mantendo o mesmo intervalo de datas para uma análise comparativa consistente. Nessa seção, é possível examinar de perto a desempenho de cada membro da equipe em relação às métricas de qualidade definidas. Isso permite uma compreensão mais detalhada de como diferentes indivíduos estão contribuindo para os resultados gerais de qualidade.\nÉ importante destacar que esse Dashboard foi desenvolvido com o propósito de servir como um exercício prático para consolidar minhas habilidades no uso do Power BI, assim como aplicar os princípios de qualidade aprendidos durante o curso no COTIL-UNICAMP. Embora os dados e cenários sejam fictícios, a abordagem e as técnicas empregadas são reflexos da minha busca por um contínuo aprendizado e aprimoramento.\nAo compartilhar este projeto, desejo ressaltar a relevância da integração entre a gestão da qualidade e a visualização de dados. A capacidade de extrair insights valiosos a partir de informações aparentemente complexas é fundamental para a tomada de decisões informadas e o aprimoramento contínuo dos processos. Além disso, a utilização do Power BI como ferramenta de análise e visualização ressalta a importância da proficiência em tecnologias contemporâneas para impulsionar a eficácia das análises de qualidade."
  },
  {
    "objectID": "Vida-Academica/posts/projeto-sim.html",
    "href": "Vida-Academica/posts/projeto-sim.html",
    "title": "Dashboard de Sistema de Informações Sobre Mortalidade",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n\nO Dashboard de hoje foi elaborado utilizando informações provenientes do Sistema de Informações sobre Mortalidade (SIM), obtidas a partir da https://basedosdados.org/ (Base dos Dados). O SIM foi desenvolvido pelo DATASUS com o propósito de adquirir regularmente dados acerca da mortalidade em todo o país. A instauração do SIM possibilitou a coleta abrangente de dados referentes a óbitos, fornecendo um embasamento substancial para as diversas instâncias envolvidas na administração da saúde pública. Com base nisso, foi concebido este Dashboard, estruturando as informações acerca do volume de óbitos por região, Unidade da Federação e município. Adicionalmente, essas informações são segmentadas por gênero e identificação étnico-racial, permitindo uma análise mais detalhada dos dados.\nO Dashboard é composto por quatro páginas distintas, cada uma fornecendo uma perspectiva única dos dados coletados. A primeira página apresenta uma visão geral dos óbitos registrados, permitindo a visualização de tendências ao longo do tempo. Além disso, é possível identificar padrões relevantes relacionados à distribuição dos óbitos por região e Unidade da Federação. A segunda página do Dashboard se concentra na análise dos óbitos por UF e Capitais do Brasil. A terceira se concentra nos dados por UF e Municípios´. Já a quarta página você pode explorar os dados com base em critérios específicos, como gênero, identificação étnico-racial, faixa etária e região. Isso permite uma compreensão mais detalhada da distribuição dos óbitos em relação a esses critérios, fornecendo insights valiosos para a formulação de políticas públicas e ações de saúde.\nVocê pode explorar o Dashboard interativo abaixo:\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/projeto-ipc.html",
    "href": "Vida-Academica/posts/projeto-ipc.html",
    "title": "Índice de Percepção de Corrupção (IPC)",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n}\nO Índice de Percepção de Corrupção (IPC) é o ranking global de corrupção mais utilizado no mundo. Mede até que ponto o sector público de cada país é considerado corrupto, de acordo com especialistas e empresários.\nA pontuação de cada país é uma combinação de pelo menos 3 fontes de dados extraídas de 13 pesquisas e avaliações diferentes sobre corrupção. Estas fontes de dados são recolhidas por diversas instituições conceituadas, incluindo o Banco Mundial e o Fórum Económico Mundial.\nA pontuação de um país é o nível percebido de corrupção no sector público numa escala de 0 a 100, onde 0 significa altamente corrupto e 100 significa muito limpo.\nA classificação de um país é a sua posição em relação aos outros países no índice. As classificações podem mudar apenas se o número de países incluídos no índice mudar.\nA classificação não é, portanto, tão importante como a pontuação em termos de indicar o nível de corrupção nesse país.\nA pontuação de um país pode mudar de um ano para o outro, mas as mudanças são geralmente pequenas. As mudanças significativas são raras, mas podem acontecer.\nAqui está um dashboard interativo que mostra o IPC de 2012 a 2021:\n\n\nFonte: https://www.transparency.org/en/news/how-cpi-scores-are-calculated\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/index.html",
    "href": "Vida-Academica/index.html",
    "title": "Estuos e Projetos Acadêmicos",
    "section": "",
    "text": "Publicações\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nAnotações do cursos feitos na plataforma Coursera\n\n\n\n\n\nAnotações dos cursos feitos na plataforma Coursera\n\n\n\n\n\n04 August 2024\n\n\nWellington Santos Souza\n\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\n\nEntre redes completas y personales: estrategia de recolección de datos cognitivos con informantes clave\n\n\n\n\n\nArtigo Publicado!\n\n\n\n\n\n07 February 2024\n\n\nWellington Santos Souza\n\n\n2 min\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/projeto-dax.html",
    "href": "Vida-Academica/posts/projeto-dax.html",
    "title": "Dashboard - Projeto Majestic",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024.\n\nCom o objetivo de aprimorar meus conhecimentos em Linguagem DAX, decidi realizar o curso oferecido pelo instrutor Felipe Mafra na plataforma Udemy. Durante o curso, tive a oportunidade de significativamente aprimorar minha compreensão em DAX, por meio da execução de um projeto abrangente com foco na aplicação prática. Nesse projeto, assumi o papel de analista de Power BI na empresa Majestic, uma exportadora de materiais escolares. Ao longo desse cenário fictício, desenvolvemos relatórios que abrangem áreas como vendas, classificação de gerentes, margem de lucro por continente e país. Além disso, também exploramos a criação de elementos visuais dinâmicos, os quais se adaptam de acordo com as métricas selecionadas. Essa experiência proporcionou um ambiente de aprendizado altamente envolvente, no qual pude não apenas aprimorar minha habilidade com a Linguagem DAX, mas também entender como aplicá-la de maneira eficaz em situações do mundo real.\nAo compartilhar este projeto, desejo ressaltar a importância da Linguagem DAX como uma ferramenta poderosa para a análise de dados. A capacidade de criar cálculos personalizados e métricas específicas é fundamental para a compreensão aprofundada dos dados e a geração de insights valiosos. Além disso, a utilização do Power BI como ferramenta de visualização ressalta a importância da proficiência em tecnologias contemporâneas para impulsionar a eficácia das análises de vendas.\nVocê pode explorar o Dashboard interativo abaixo.\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/projeto-qualidade.html",
    "href": "Vida-Academica/posts/projeto-qualidade.html",
    "title": "Dashboard de Qualidade",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024."
  },
  {
    "objectID": "Vida-Academica/posts/projeto-qualidade.html#resumo-do-projeto",
    "href": "Vida-Academica/posts/projeto-qualidade.html#resumo-do-projeto",
    "title": "Dashboard de Qualidade",
    "section": "Resumo do Projeto",
    "text": "Resumo do Projeto\nVisando aplicar os conhecimentos adquiridos no curso técnico em qualidade, concluído em 2017 no COTIL-UNICAMP, e aprimorar minhas habilidades no Power BI, decidi criar um Dashboard fictício como exercício prático. Este Dashboard possui duas páginas distintas, cada uma fornecendo informações relevantes relacionadas à análise de qualidade, permitindo uma compreensão abrangente dos dados.\nA primeira página do Dashboard apresenta uma visão geral das amostras analisadas, abrangendo diferentes métricas essenciais. São exibidos dados como o número de defeitos identificados, o score de qualidade obtido e a quantidade de erros fatais registrados. Além disso, essas informações são desagregadas com base em diversos critérios, como local de trabalho, supervisor, auditor e funcionário responsável. Tudo isso é apresentado num intervalo de datas específico, possibilitando a identificação de tendências ao longo do tempo.\nA segunda página do Dashboard se concentra na avaliação de desempenho individual de cada funcionário e supervisor, mantendo o mesmo intervalo de datas para uma análise comparativa consistente. Nessa seção, é possível examinar de perto a desempenho de cada membro da equipe em relação às métricas de qualidade definidas. Isso permite uma compreensão mais detalhada de como diferentes indivíduos estão contribuindo para os resultados gerais de qualidade.\nÉ importante destacar que esse Dashboard foi desenvolvido com o propósito de servir como um exercício prático para consolidar minhas habilidades no uso do Power BI, assim como aplicar os princípios de qualidade aprendidos durante o curso no COTIL-UNICAMP. Embora os dados e cenários sejam fictícios, a abordagem e as técnicas empregadas são reflexos da minha busca por um contínuo aprendizado e aprimoramento.\nAo compartilhar este projeto, desejo ressaltar a relevância da integração entre a gestão da qualidade e a visualização de dados. A capacidade de extrair insights valiosos a partir de informações aparentemente complexas é fundamental para a tomada de decisões informadas e o aprimoramento contínuo dos processos. Além disso, a utilização do Power BI como ferramenta de análise e visualização ressalta a importância da proficiência em tecnologias contemporâneas para impulsionar a eficácia das análises de qualidade.\nVocê pode explorar o Dashboard interativo abaixo."
  },
  {
    "objectID": "Vida-Academica/posts/redes_completas.html",
    "href": "Vida-Academica/posts/redes_completas.html",
    "title": "Entre redes completas y personales: estrategia de recolección de datos cognitivos con informantes clave",
    "section": "",
    "text": "Autores\nDimitri Fazito\nSilvio Salej Higgins\nAntonio Carlos Andrade Ribeiro\nGeraldo Timoteo\nWellington Santos Souza\nDOI: https://doi.org/10.5944/empiria.58.2023.37382\nPalabras clave: análisis de redes sociales, sociología relacional, redes cognitivas, líderes comunitarios, PESCARTE, social network analysis, relational sociology, cognitive networks, communitarian leaders"
  },
  {
    "objectID": "Vida-Academica/posts/redes_completas.html#entre-redes-completas-y-personales-estrategia-de-recolección-de-datos-cognitivos-con-informantes-clave",
    "href": "Vida-Academica/posts/redes_completas.html#entre-redes-completas-y-personales-estrategia-de-recolección-de-datos-cognitivos-con-informantes-clave",
    "title": "Entre redes completas y personales: estrategia de recolección de datos cognitivos con informantes clave",
    "section": "",
    "text": "Autores\nDimitri Fazito\nSilvio Salej Higgins\nAntonio Carlos Andrade Ribeiro\nGeraldo Timoteo\nWellington Santos Souza\nDOI: https://doi.org/10.5944/empiria.58.2023.37382\nPalabras clave: análisis de redes sociales, sociología relacional, redes cognitivas, líderes comunitarios, PESCARTE, social network analysis, relational sociology, cognitive networks, communitarian leaders"
  },
  {
    "objectID": "Vida-Academica/posts/redes_completas.html#resumen",
    "href": "Vida-Academica/posts/redes_completas.html#resumen",
    "title": "Entre redes completas y personales: estrategia de recolección de datos cognitivos con informantes clave",
    "section": "Resumen",
    "text": "Resumen\nEste trabajo propone una estrategia, denominada como Modelo de Redes Sociales Cognitivas (MRSC), para recolectar datos relacionales a partir de informantes-clave. Ofrecemos una solución para la doble problemática de, por un lado, definir los límites de una red de interaciones y, por el otro, recolectar datos de una red completa basada en la percepción de informantes que son observadores privilegiados del proceso social en estudio. El proyecto fue implementado para diagnosticar la dinámica de las relaciones comunitarias en comunidades de pesquerías tradicionales, por encomienda de un proyecto de investigación-acción (PESCARTE), en el campo de la educación ambiental, en el litoral del estado de Rio de Janeiro (Brasil). La propuesta combina técnicas de recolección de datos de redes personales y de redes completas. Los instrumentos elaborados para la recogida de datos y los procedimientos utilizados para validar la estrategia son detallados. Artículo financiado por el Proyecto de Educación Ambiental (PEA) PESCARTE, iniciativa de mitigación exigida por la Licencia Federal Ambiental conducida por el Instituto Brasilero del Medio Ambiente y de los Recursos Naturales Renovables (IBAMA).\nPara acessar o artigo completo clique AQUI."
  },
  {
    "objectID": "ccc/index.html",
    "href": "ccc/index.html",
    "title": "Vida Acadêmica",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNo matching items\n\n\n\nLoading…\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/palestras-GIARS.html",
    "href": "Vida-Academica/posts/palestras-GIARS.html",
    "title": "Amostragem de survey em Ciências Sociais:práticas, desafios e soluções",
    "section": "",
    "text": "Junte-se a nós para uma discussão sobre Amostragem de Survey em Ciências Sociais com os especialistas Matheus Dias e Marcos Ruben de Oliveira!\n\nData: 22 de abril de 2024\nLugar: FAFICH –UFMG\nOrganizador: Prof. Silvio Salej Higgins (DSO-FAFICH)"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html",
    "href": "projetos-R/posts/analise-DataSenado.html",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "",
    "text": "Este artigo foi reescrito em Sexta-Feira, 03 de maio de 2024."
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html#carregando-dados",
    "href": "projetos-R/posts/analise-DataSenado.html#carregando-dados",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Carregando dados",
    "text": "Carregando dados\nOs dados utilizados nesta análise estão disponíveis no site do Data Senado. Você pode acessar os dados, documentos técnicos e alguns dos blocos de códigos utilizados nesta análise clicando aqui.\nInstalando e carregando pacotes\n\n\nCode\nif(!require(\"pacman\")){install.packages(\"pacman\")}; library(pacman)\n\npacman::p_load(readxl, tidyverse, survey, purrr, srvyr, knitr, shinydashboard,shiny)\n\n\nCarregando o dicionário de dados.\n\n\nCode\nrm(list = ls())\nDICIONARIO_DE_DADOS &lt;- read_excel(\"C:/Users/welli/OneDrive/portifolio-dados.github.io/projetos-R/dados/DATASEN BR 2022 NOV BAROMETRO - DICIONARIO DE DADOS.xlsx\")\n\n\nCarregando Microdado\n\n\nCode\ndf = read.csv2(\"C:/Users/welli/OneDrive/portifolio-dados.github.io/projetos-R/dados/DATASEN BR 2022 NOV BAROMETRO - DADOS.csv\",  sep = \";\")\n\n\nMudanca de nomenclatura das variaveis para facilitar entendimento do codigo\n\n\nCode\ndf &lt;- df |&gt; \n  mutate(\n    P02 = case_when(\n      P02 == 12 ~ \"Acre\",\n      P02 == 27 ~ \"Alagoas\",\n      P02 == 13 ~ \"Amazonas\",\n      P02 == 16 ~ \"Amapá\",\n      P02 == 29 ~ \"Bahia\",\n      P02 == 23 ~ \"Ceará\",\n      P02 == 53 ~ \"Distrito Federal\",\n      P02 == 32 ~ \"Espírito Santo\",\n      P02 == 52 ~ \"Goiás\",\n      P02 == 21 ~ \"Maranhão\",\n      P02 == 51 ~ \"Mato Grosso\",\n      P02 == 50 ~ \"Mato Grosso do Sul\",\n      P02 == 31 ~ \"Minas Gerais\",\n      P02 == 15 ~ \"Pará\",\n      P02 == 25 ~ \"Paraíba\",\n      P02 == 41 ~ \"Paraná\",\n      P02 == 26 ~ \"Pernambuco\",\n      P02 == 22 ~ \"Piauí\",\n      P02 == 33 ~ \"Rio de Janeiro\",\n      P02 == 24 ~ \"Rio Grande do Norte\",\n      P02 == 43 ~ \"Rio Grande do Sul\",\n      P02 == 11 ~ \"Rondônia\",\n      P02 == 14 ~ \"Roraima\",\n      P02 == 42 ~ \"Santa Catarina\",\n      P02 == 35 ~ \"São Paulo\",\n      P02 == 28 ~ \"Sergipe\",\n      P02 == 17 ~ \"Tocantins\",\n      TRUE ~ NA)) |&gt;\n  mutate(\n  VD_REGIAO = case_when(\n    VD_REGIAO == 1  ~ \"Norte\",\n    VD_REGIAO == 2  ~ \"Nordeste\",\n    VD_REGIAO == 3  ~ \"Sudeste\",\n    VD_REGIAO == 4  ~ \"Sul\",\n    VD_REGIAO == 5  ~ \"Centro-Oeste\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V02 = case_when(\n      V02 == 1 ~ \"Masculino\",\n      V02 == 2 ~ \"Feminino\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V04 = case_when(\n      V04 == 1  ~ \"Branca\",\n      V04 == 2  ~ \"Preta\",\n      V04 == 3  ~ \"Parda\",\n      V04 == 4  ~ \"Indígena\",\n      V04 == 5  ~ \"Amarela\",\n      V04 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V09 = case_when(\n      V09 == 1  ~ 'Católica',\n      V09 == 2  ~ 'Evangélica',\n      V09 == 3  ~ 'Espírita',\n      V09 == 4  ~ 'Sem religião ou crença',\n      V09 == 5  ~ 'Outra',\n      V09 == 99 ~ 'Prefiro não responder',\n      TRUE ~ NA)) |&gt; \n  mutate(\n    P04 = case_when( \n      P04 == 1  ~ \"Saúde\",\n      P04 == 2  ~ \"Emprego\",\n      P04 == 3  ~ \"Custo de vida\",\n      P04 == 4  ~ \"Corrupção\",\n      P04 == 5  ~ \"Segurança pública\",\n      P04 == 6  ~ \"Educação\",\n      P04 == 7  ~ \"Outro\",\n      P04 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    P19 = case_when(\n      P19 == 1 ~ \"Muito satisfeito(a)\",\n      P19 == 2 ~ \"Pouco satisfeito(a)\",\n      P19 == 3 ~ \"Nada satisfeito(a)\",\n      P19 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    VD_IDADE = case_when(\n      VD_IDADE == 1 ~ \"16 a 29 anos\",\n      VD_IDADE == 2 ~ \"30 a 39 anos\",\n      VD_IDADE == 3  ~ \"40 a 49 anos\",\n      VD_IDADE == 4 ~ \"50 a 59 anos\",\n      VD_IDADE == 5 ~ \"60 anos ou mais\",\n      TRUE ~ NA_character_)) |&gt; \n    mutate(\n    VD_VOTO.TURNO1_ = case_when(\n      VD_VOTO.TURNO1 == 1 ~ \"Jair Bolsonaro (22)\",\n      VD_VOTO.TURNO1 == 2 ~ \"Lula (13)\",\n      VD_VOTO.TURNO1 == 3 ~ \"Outros/Branco/Nulo/Não votou\",\n      TRUE ~ NA_character_)) |&gt; \n      mutate(\n    VD_VOTO.TURNO2_ = case_when(\n      VD_VOTO.TURNO2 == 1 ~ \"Jair Bolsonaro (22)\",\n      VD_VOTO.TURNO2 == 2 ~ \"Lula (13)\",\n      VD_VOTO.TURNO2 == 3 ~ \"Outros / Branco/Nulo/Não votou\",\n      TRUE ~ NA_character_)) |&gt; \n  mutate(\n    P06 = case_when(\n      P06 == 1 ~ \"A favor\",\n      P06 == 2 ~ \"Contra\",\n      P06 == 97 ~ \"Não sei / Prefiro não responder\",\n      TRUE ~ NA_character_)) |&gt; \n    mutate(\n    P08 = case_when(\n      P08 == 1 ~ \"A favor\",\n      P08 == 2 ~ \"Contra\",\n      P08 == 97 ~ \"Não sei / Prefiro não responder\",\n      TRUE ~ NA_character_)) |&gt; \n  mutate(\n    P09 = case_when(\n      P09 == 1 ~ \"Qualquer valor abaixo de R$ 499 mil\",\n      P09  == 2 ~ \"De R$ 500 mil a R$ 999 mil\",\n      P09 == 3 ~ \"De R$ 1 milhão a R$ 9,9 milhões\",\n      P09 == 4 ~ \"De R$ 10 milhões a 49 milhões\",\n      P09 == 5 ~ \"De R$ 50 milhões a 99 milhões\",\n      P09 == 6 ~ \"Acima de R$ 100 milhões\",\n      P09 == 7 ~ \"Não sei\",\n      P09 == 8 ~ \"Prefiro não responder\",\n      TRUE ~ NA_character_\n    )\n  )"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html#ponderação",
    "href": "projetos-R/posts/analise-DataSenado.html#ponderação",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Ponderação",
    "text": "Ponderação\nDefinição das variáveis a serem usadas no raking (calibracao):\n\n\nCode\n# Mudanca de nomenclatura das variaveis para facilitar entendimento do codigo\n\ndf$regiao.wgts      = df$VD_REGIAO\ndf$sexo.wgts        = df$V02\ndf$edu.wgts         = df$VD_EDUCACAO\ndf$raca.wgts        = df$VD_RACA \ndf$idade.wgts       = df$VD_IDADE \ndf$porte.wgts       = df$VD_PORTE\ndf$voto.turno1.wgts = df$VD_VOTO.TURNO1\ndf$voto.turno2.wgts = df$VD_VOTO.TURNO2\n\n## Ponderacao ------------\n\n# Definição das variáveis a serem usadas no raking (calibracao):\nvar.wgts = c(\"raca.wgts\",\n             \"sexo.wgts\",\n             \"idade.wgts\",\n             \"porte.wgts\",\n             \"edu.wgts\",\n             \"voto.turno2.wgts\",\n             \"voto.turno1.wgts\")\n\n\n# Definição das variaveis populacionais que servirao de parametro para o raking\n# Essas variaveis foram extraidas da PNADC 2021-03\n\nvar.pop = c(\"POP_REGIAO_RACA\",\n            \"POP_REGIAO_SEXO\",\n            \"POP_REGIAO_IDADE\",\n            \"POP_REGIAO_PORTE\",\n            \"POP_REGIAO_EDU\",\n            \"POP_REGIAO_VOTO.TURNO2\",\n            \"POP_REGIAO_VOTO.TURNO1\")\n\n# Criacao da lista de referencia com os parametros populacionais a serem usados na funcao rake:\n\npopulation &lt;- list(0)\nfor (i in 1:length(var.wgts)) {\n  pop = unique(df[, c('regiao.wgts', var.wgts[i], var.pop[i])])\n  names(pop) &lt;- c('regiao.wgts', var.wgts[i], 'freq')\n  population[[i]] &lt;- pop\n  \n}\n\n# Definicao das variaveis na amostra que serao usadas no rake, no formato exigido pela funcao\n\nsample &lt;- map(paste0(\"~\", \"regiao.wgts +\", var.wgts), as.formula)\n\n# Delineamento amostral ------------\ndata.svy &lt;-\n  svydesign(\n    id = ~ ID,\n    weights = df$W1,\n    data = df,\n    strata = df$regiao.wgts\n  )\n\n# Ponderacao Rake ------------\ndata.rake &lt;-\n  rake(\n    data.svy,\n    sample.margins = sample,\n    population.margins = population,\n    control = list(maxit = 62)\n  )\n\n\nTeste para ver se a ponderacao acima bate com o peso calculado pelo DataSenado disponivel na base\n\n\nCode\nWrake &lt;- data.frame(ID = data.svy$cluster, W2_teste = weights(data.rake))\nsummary(Wrake$W2_teste)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1323   31923   55903   83460   97066 1547555 \n\n\nCode\nsummary(df$W2)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1323   31923   55903   83460   97066 1547555 \n\n\nComo os valores são iguais vamos partir para as análises\n\nUsando o pacote srvyr para facilitar a análise\n\n\nCode\ndata.rake.srvyr &lt;- as_survey(data.rake)"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html#análise-descritiva",
    "href": "projetos-R/posts/analise-DataSenado.html#análise-descritiva",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Análise descritiva",
    "text": "Análise descritiva\nQual a sua maior preocupação dos cidadãos do Brasil hoje?\n\nCode\npreocupacao &lt;- data.rake.srvyr %&gt;%\n  group_by(P04) %&gt;%\n  summarise(proporcao = survey_prop()) %&gt;%\n  mutate(Proporcao = paste0(round(proporcao * 100),\"%\")) |&gt;\n  mutate(Proporcao_se = paste0(round(proporcao_se * 100,2),\"%\")) |&gt;\n  rename(\"Preocupação\" = P04)\nkable(preocupacao)\n\n\n\n\n\n\n\n\n\n\n\nPreocupação\nproporcao\nproporcao_se\nProporcao\nProporcao_se\n\n\n\n\nCorrupção\n0.1668992\n0.0113481\n17%\n1.13%\n\n\nCusto de vida\n0.1396945\n0.0115270\n14%\n1.15%\n\n\nEducação\n0.1461462\n0.0117522\n15%\n1.18%\n\n\nEmprego\n0.1140201\n0.0103845\n11%\n1.04%\n\n\nNão sei/Prefiro não responder\n0.0345028\n0.0101606\n3%\n1.02%\n\n\nOutro\n0.0331413\n0.0053532\n3%\n0.54%\n\n\nSaúde\n0.2570159\n0.0137271\n26%\n1.37%\n\n\nSegurança pública\n0.1085799\n0.0101609\n11%\n1.02%"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html#qual-a-sua-maior-preocupação-dos-cidadãos-do-brasil-hoje",
    "href": "projetos-R/posts/analise-DataSenado.html#qual-a-sua-maior-preocupação-dos-cidadãos-do-brasil-hoje",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Qual a sua maior preocupação dos cidadãos do Brasil hoje?",
    "text": "Qual a sua maior preocupação dos cidadãos do Brasil hoje?\n\nCode\npreocupacao &lt;- data.rake.srvyr %&gt;%\n  group_by(P04) %&gt;%\n  summarise(proporcao = survey_prop()) %&gt;%\n  mutate(Proporcao = paste0(round(proporcao * 100),\"%\")) |&gt;\n  mutate(Proporcao_se = paste0(round(proporcao_se * 100,2),\"%\")) |&gt;\n  rename(\"Preocupação\" = P04)\nkable(preocupacao)\n\n\n\n\n\n\n\n\n\n\n\nPreocupação\nproporcao\nproporcao_se\nProporcao\nProporcao_se\n\n\n\n\nCorrupção\n0.1668992\n0.0113481\n17%\n1.13%\n\n\nCusto de vida\n0.1396945\n0.0115270\n14%\n1.15%\n\n\nEducação\n0.1461462\n0.0117522\n15%\n1.18%\n\n\nEmprego\n0.1140201\n0.0103845\n11%\n1.04%\n\n\nNão sei/Prefiro não responder\n0.0345028\n0.0101606\n3%\n1.02%\n\n\nOutro\n0.0331413\n0.0053532\n3%\n0.54%\n\n\nSaúde\n0.2570159\n0.0137271\n26%\n1.37%\n\n\nSegurança pública\n0.1085799\n0.0101609\n11%\n1.02%"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado_1.html",
    "href": "projetos-R/posts/analise-DataSenado_1.html",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "",
    "text": "Este artigo foi reescrito em Domingo, 03 de maio de 2024."
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado_1.html#carregando-dados",
    "href": "projetos-R/posts/analise-DataSenado_1.html#carregando-dados",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Carregando dados",
    "text": "Carregando dados\nOs dados que iremos usar aqui n análise de dados estão disponíveis no site do data Senado. Você pode acessar os dados, documentos técnicos e alguns dos blocos de códigos usados nessa análise clicando aqui.\nInstalando e carregando pacotes\n\n\nCode\nif(!require(\"pacman\")){install.packages(\"pacman\")}; library(pacman)\n\npacman::p_load(readxl, tidyverse, survey, purrr, srvyr, knitr, shinydashboard,shiny)\n\n\nCarregando o dicionário de dados.\n\n\nCode\nrm(list = ls())\nDICIONARIO_DE_DADOS &lt;- read_excel(\"~/portifolio/projetos-R/dados/DATASEN BR 2022 NOV BAROMETRO - DICIONARIO DE DADOS.xlsx\")\n\n\nCarregando Microdado\n\n\nCode\ndf = read.csv2(\"~/portifolio/projetos-R/dados/DATASEN BR 2022 NOV BAROMETRO - DADOS.csv\",  sep = \";\")\n\n\nMudanca de nomenclatura das variaveis para facilitar entendimento do codigo\n\n\nCode\ndf &lt;- df |&gt; \n  mutate(\n    P02 = case_when(\n      P02 == 12 ~ \"Acre\",\n      P02 == 27 ~ \"Alagoas\",\n      P02 == 13 ~ \"Amazonas\",\n      P02 == 16 ~ \"Amapá\",\n      P02 == 29 ~ \"Bahia\",\n      P02 == 23 ~ \"Ceará\",\n      P02 == 53 ~ \"Distrito Federal\",\n      P02 == 32 ~ \"Espírito Santo\",\n      P02 == 52 ~ \"Goiás\",\n      P02 == 21 ~ \"Maranhão\",\n      P02 == 51 ~ \"Mato Grosso\",\n      P02 == 50 ~ \"Mato Grosso do Sul\",\n      P02 == 31 ~ \"Minas Gerais\",\n      P02 == 15 ~ \"Pará\",\n      P02 == 25 ~ \"Paraíba\",\n      P02 == 41 ~ \"Paraná\",\n      P02 == 26 ~ \"Pernambuco\",\n      P02 == 22 ~ \"Piauí\",\n      P02 == 33 ~ \"Rio de Janeiro\",\n      P02 == 24 ~ \"Rio Grande do Norte\",\n      P02 == 43 ~ \"Rio Grande do Sul\",\n      P02 == 11 ~ \"Rondônia\",\n      P02 == 14 ~ \"Roraima\",\n      P02 == 42 ~ \"Santa Catarina\",\n      P02 == 35 ~ \"São Paulo\",\n      P02 == 28 ~ \"Sergipe\",\n      P02 == 17 ~ \"Tocantins\",\n      TRUE ~ NA)) |&gt;\n  mutate(\n  VD_REGIAO = case_when(\n    VD_REGIAO == 1  ~ \"Norte\",\n    VD_REGIAO == 2  ~ \"Nordeste\",\n    VD_REGIAO == 3  ~ \"Sudeste\",\n    VD_REGIAO == 4  ~ \"Sul\",\n    VD_REGIAO == 5  ~ \"Centro-Oeste\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V02 = case_when(\n      V02 == 1 ~ \"Masculino\",\n      V02 == 2 ~ \"Feminino\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V04 = case_when(\n      V04 == 1  ~ \"Branca\",\n      V04 == 2  ~ \"Preta\",\n      V04 == 3  ~ \"Parda\",\n      V04 == 4  ~ \"Indígena\",\n      V04 == 5  ~ \"Amarela\",\n      V04 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    V09 = case_when(\n      V09 == 1  ~ 'Católica',\n      V09 == 2  ~ 'Evangélica',\n      V09 == 3  ~ 'Espírita',\n      V09 == 4  ~ 'Sem religião ou crença',\n      V09 == 5  ~ 'Outra',\n      V09 == 99 ~ 'Prefiro não responder',\n      TRUE ~ NA)) |&gt; \n  mutate(\n    P04 = case_when( \n      P04 == 1  ~ \"Saúde\",\n      P04 == 2  ~ \"Emprego\",\n      P04 == 3  ~ \"Custo de vida\",\n      P04 == 4  ~ \"Corrupção\",\n      P04 == 5  ~ \"Segurança pública\",\n      P04 == 6  ~ \"Educação\",\n      P04 == 7  ~ \"Outro\",\n      P04 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    P19 = case_when(\n      P19 == 1 ~ \"Muito satisfeito(a)\",\n      P19 == 2 ~ \"Pouco satisfeito(a)\",\n      P19 == 3 ~ \"Nada satisfeito(a)\",\n      P19 == 97 ~ \"Não sei/Prefiro não responder\",\n      TRUE ~ NA)) |&gt; \n  mutate(\n    VD_IDADE = case_when(\n      VD_IDADE == 1 ~ \"16 a 29 anos\",\n      VD_IDADE == 2 ~ \"30 a 39 anos\",\n      VD_IDADE == 3  ~ \"40 a 49 anos\",\n      VD_IDADE == 4 ~ \"50 a 59 anos\",\n      VD_IDADE == 5 ~ \"60 anos ou mais\",\n      TRUE ~ NA_character_)) |&gt; \n    mutate(\n    VD_VOTO.TURNO1_ = case_when(\n      VD_VOTO.TURNO1 == 1 ~ \"Jair Bolsonaro (22)\",\n      VD_VOTO.TURNO1 == 2 ~ \"Lula (13)\",\n      VD_VOTO.TURNO1 == 3 ~ \"Outros/Branco/Nulo/Não votou\",\n      TRUE ~ NA_character_)) |&gt; \n      mutate(\n    VD_VOTO.TURNO2_ = case_when(\n      VD_VOTO.TURNO2 == 1 ~ \"Jair Bolsonaro (22)\",\n      VD_VOTO.TURNO2 == 2 ~ \"Lula (13)\",\n      VD_VOTO.TURNO2 == 3 ~ \"Outros / Branco/Nulo/Não votou\",\n      TRUE ~ NA_character_)) |&gt; \n  mutate(\n    P06 = case_when(\n      P06 == 1 ~ \"A favor\",\n      P06 == 2 ~ \"Contra\",\n      P06 == 97 ~ \"Não sei / Prefiro não responder\",\n      TRUE ~ NA_character_)) |&gt; \n    mutate(\n    P08 = case_when(\n      P08 == 1 ~ \"A favor\",\n      P08 == 2 ~ \"Contra\",\n      P08 == 97 ~ \"Não sei / Prefiro não responder\",\n      TRUE ~ NA_character_)) |&gt; \n  mutate(\n    P09 = case_when(\n      P09 == 1 ~ \"Qualquer valor abaixo de R$ 499 mil\",\n      P09  == 2 ~ \"De R$ 500 mil a R$ 999 mil\",\n      P09 == 3 ~ \"De R$ 1 milhão a R$ 9,9 milhões\",\n      P09 == 4 ~ \"De R$ 10 milhões a 49 milhões\",\n      P09 == 5 ~ \"De R$ 50 milhões a 99 milhões\",\n      P09 == 6 ~ \"Acima de R$ 100 milhões\",\n      P09 == 7 ~ \"Não sei\",\n      P09 == 8 ~ \"Prefiro não responder\",\n      TRUE ~ NA_character_\n    )\n  )"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado_1.html#ponderação",
    "href": "projetos-R/posts/analise-DataSenado_1.html#ponderação",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Ponderação",
    "text": "Ponderação\nDefinição das variáveis a serem usadas no raking (calibracao):\n\n\nCode\n# Mudanca de nomenclatura das variaveis para facilitar entendimento do codigo\n\ndf$regiao.wgts      = df$VD_REGIAO\ndf$sexo.wgts        = df$V02\ndf$edu.wgts         = df$VD_EDUCACAO\ndf$raca.wgts        = df$VD_RACA \ndf$idade.wgts       = df$VD_IDADE \ndf$porte.wgts       = df$VD_PORTE\ndf$voto.turno1.wgts = df$VD_VOTO.TURNO1\ndf$voto.turno2.wgts = df$VD_VOTO.TURNO2\n\n## Ponderacao ------------\n\n# Definição das variáveis a serem usadas no raking (calibracao):\nvar.wgts = c(\"raca.wgts\",\n             \"sexo.wgts\",\n             \"idade.wgts\",\n             \"porte.wgts\",\n             \"edu.wgts\",\n             \"voto.turno2.wgts\",\n             \"voto.turno1.wgts\")\n\n\n# Definição das variaveis populacionais que servirao de parametro para o raking\n# Essas variaveis foram extraidas da PNADC 2021-03\n\nvar.pop = c(\"POP_REGIAO_RACA\",\n            \"POP_REGIAO_SEXO\",\n            \"POP_REGIAO_IDADE\",\n            \"POP_REGIAO_PORTE\",\n            \"POP_REGIAO_EDU\",\n            \"POP_REGIAO_VOTO.TURNO2\",\n            \"POP_REGIAO_VOTO.TURNO1\")\n\n# Criacao da lista de referencia com os parametros populacionais a serem usados na funcao rake:\n\npopulation &lt;- list(0)\nfor (i in 1:length(var.wgts)) {\n  pop = unique(df[, c('regiao.wgts', var.wgts[i], var.pop[i])])\n  names(pop) &lt;- c('regiao.wgts', var.wgts[i], 'freq')\n  population[[i]] &lt;- pop\n  \n}\n\n# Definicao das variaveis na amostra que serao usadas no rake, no formato exigido pela funcao\n\nsample &lt;- map(paste0(\"~\", \"regiao.wgts +\", var.wgts), as.formula)\n\n# Delineamento amostral ------------\ndata.svy &lt;-\n  svydesign(\n    id = ~ ID,\n    weights = df$W1,\n    data = df,\n    strata = df$regiao.wgts\n  )\n\n# Ponderacao Rake ------------\ndata.rake &lt;-\n  rake(\n    data.svy,\n    sample.margins = sample,\n    population.margins = population,\n    control = list(maxit = 62)\n  )\n\n\nTeste para ver se a ponderacao acima bate com o peso calculado pelo DataSenado disponivel na base\n\n\nCode\nWrake &lt;- data.frame(ID = data.svy$cluster, W2_teste = weights(data.rake))\nsummary(Wrake$W2_teste)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1323   31923   55903   83460   97066 1547555 \n\n\nCode\nsummary(df$W2)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1323   31923   55903   83460   97066 1547555 \n\n\nComo os valores são iguais vamos partir para as análises\n\nUsando o pacote srvyr para facilitar a análise\n\n\nCode\ndata.rake.srvyr &lt;- as_survey(data.rake)"
  },
  {
    "objectID": "projetos-R/posts/analise-DataSenado.html#resumo",
    "href": "projetos-R/posts/analise-DataSenado.html#resumo",
    "title": "Análise de dados da pesquisa DataSenado",
    "section": "Resumo",
    "text": "Resumo\nO código começa carregando os dados necessários para a análise do site do Data Senado. Em seguida, são realizadas algumas transformações nos dados, como mudança de nomenclatura e agrupamento por região, sexo, idade, entre outros, para facilitar a compreensão e análise futura.\nEm seguida, o código realiza uma ponderação dos dados, utilizando o pacote survey, ajustando os pesos das observações para que reflitam a distribuição da população.\nApós a ponderação, são realizadas análises descritivas e multivariadas dos dados. São apresentadas visualizações sobre as principais preocupações da população brasileira, opiniões sobre temas como redução da maioridade penal e criação de impostos sobre grandes fortunas, bem como análises estratificadas por sexo, idade, voto nas últimas eleições e religião.\nEssas análises visam fornecer insights sobre as opiniões e preocupações da população brasileira em relação a diversos temas."
  },
  {
    "objectID": "projetos-R/posts/projeto-PNADc.html",
    "href": "projetos-R/posts/projeto-PNADc.html",
    "title": "Acessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE",
    "section": "",
    "text": "Este artigo foi reescrito em Domingo, 12 de Abril de 2024."
  },
  {
    "objectID": "projetos-R/posts/projeto-PNADc.html#baixando-os-dados-da-pnadc",
    "href": "projetos-R/posts/projeto-PNADc.html#baixando-os-dados-da-pnadc",
    "title": "Acessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE",
    "section": "Baixando os dados da PNADc",
    "text": "Baixando os dados da PNADc\n\nDefinindo as variáveis que serão utilizadas. Lembre-se de que este é apenas um exemplo; você pode explorar outras variáveis disponíveis.\n\nVD3005 = Anos de Estudo\nV2009 = Idade\nV2007 = Sexo\nVD4020 = Rendimento mensal efetivo de todos os trabalhos para pessoas de 14 anos ou mais de idade (apenas para pessoas que receberam em dinheiro, produtos ou mercadorias em qualquer trabalho)\nUF = Unidade da Federação\nV2010 = Cor/Raça\nV2001 = Número de pessoas no domicílio\nVD4035 = Horas efetivamente trabalhadas na semana de referência em todos os trabalhos para pessoas de 14 anos ou mais de idade\nV3007 = Já concluiu ou não a graduação\n\nvariaveis &lt;- c('VD3005','V2009','V2007',\"VD4020\",'UF', \"V2010\", \"VD4035\", \"V3007\", \"V2001\")\noptions(scipen= 999 )\n\n\nRealizando o download dos dados da PNAD Contínua do ano de 2022 para a 1ª entrevista. Para mais informações sobre como utilizar o pacote, acesse\n\nAlém dos argumentos year e quarter, que indicam, respectivamente, o ano e o trimestre dos microdados a serem baixados, a função get_pnadc possui outros quatro argumentos que podem ser ajustados durante o download:\n\ndesign: Um argumento lógico que indica se a função deve retornar um objeto de plano amostral para análise com o pacote survey. Mantenha esta opção como TRUE para garantir análises corretas;\nvars: Este argumento recebe um vetor de caracteres com o nome das variáveis a serem baixadas. Se nenhum nome de variável for especificado, todas as variáveis disponíveis na pesquisa serão baixadas. É útil quando você precisa trabalhar apenas com algumas variáveis específicas, reduzindo o espaço ocupado na memória do computador;\nlabels: Um argumento lógico que indica se os níveis das variáveis categóricas devem ser rotulados de acordo com o dicionário da pesquisa. Por padrão, os níveis são rotulados.\n\n\ndados_PNADc &lt;- get_pnadc(vars = variaveis, year=2022, interview = 1)\n\n\nDando uma olhada classe do objeto baixado\n\n\nclass(dados_PNADc)\n\n[1] \"svyrep.design\"\n\n\n\nTransformando a classe svyrep.design em tbl_svy\n\n\ndados_PNADc_srvyr &lt;- as_survey(dados_PNADc)\nclass(dados_PNADc_srvyr)\n\n[1] \"tbl_svy\"       \"svyrep.design\""
  },
  {
    "objectID": "projetos-R/posts/projeto-PNADc.html#tratando-o-dados",
    "href": "projetos-R/posts/projeto-PNADc.html#tratando-o-dados",
    "title": "Acessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE",
    "section": "Tratando o dados",
    "text": "Tratando o dados\n\nAgora que fizemos a transformação podemos alterar o nome das variáveis usando a gramática do dplyr: srvyr.\n\n\ndados_PNADc_srvyr &lt;- dados_PNADc_srvyr |&gt; \n  rename(\"Anos_de_Estudo\" = VD3005,\n         \"Renda_Media\" = VD4020,\n         \"Idade\" = V2009,\n         \"Sexo\" = V2007,\n         \"Cor_Raca\" = V2010,\n         \"Unidade_da_Federacao\" = UF,\n         \"Horas_Trabalhadas\" = VD4035, \n         \"Num_pesoas_dom\" = V2001,\n         \"Concluiu_ou_nao_graduacao\" = V3007)\n\n\nCriando variável Região\n\n\ndados_PNADc_srvyr &lt;- dados_PNADc_srvyr |&gt; \n  transform(\n  Regiao = case_when(\n    Unidade_da_Federacao %in% c(\"Rondônia\", \"Acre\", \"Amazonas\", \"Roraima\", \"Pará\", \"Amapá\", \"Tocantins\") ~ \"Norte\",\n    Unidade_da_Federacao %in% c(\"Maranhão\", \"Piauí\", \"Ceará\", \"Rio Grande do Norte\", \"Paraíba\", \"Pernambuco\", \"Alagoas\", \"Sergipe\", \"Bahia\") ~ \"Nordeste\",\n    Unidade_da_Federacao %in% c(\"Minas Gerais\", \"Espírito Santo\", \"Rio de Janeiro\", \"São Paulo\") ~ \"Sudeste\",\n    Unidade_da_Federacao %in% c(\"Paraná\", \"Santa Catarina\", \"Rio Grande do Sul\") ~ \"Sul\",\n    TRUE ~ \"Centro-Oeste\"))"
  },
  {
    "objectID": "projetos-R/posts/projeto-PNADc.html#análise-descritiva-de-dados",
    "href": "projetos-R/posts/projeto-PNADc.html#análise-descritiva-de-dados",
    "title": "Acessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE",
    "section": "Análise descritiva de dados",
    "text": "Análise descritiva de dados\nEstimando a quantidade de homens e mulheres\n\nSexo &lt;- dados_PNADc_srvyr |&gt; \n  group_by(Sexo) |&gt; \n  summarise(n = survey_total(na.rm=T))\nSexo |&gt; \n  knitr::kable(col.names = c(\"Sexo\", \"N\", \"Erro Amostral\"))\n\n\n\n\nSexo\nN\nErro Amostral\n\n\n\n\nHomem\n104660652\n0.0178035\n\n\nMulher\n109492989\n0.0130509\n\n\n\n\n\nPodemos melhorar a visualização das estimativas de Sexo, que indicavam 105.595.187 homens e 110.528.146 mulheres, usando um gráfico de pizza para destacar essas proporções.\n\n# Calcular proporções\nSexo$proporcao &lt;- Sexo$n / sum(Sexo$n) * 100\n\nggplot(Sexo, aes(x = \"\", y = n, fill = Sexo)) +\n  geom_bar(width = 1, stat = \"identity\") +\n  geom_text(aes(label = paste0(round(proporcao), \"%\")), \n            position = position_stack(vjust = 0.5)) +\n  coord_polar(theta = \"y\") +\n  labs(title = \"Distribuição por Sexo\") +\n  theme_minimal() +\n  theme(axis.text.x = element_blank(),\n        axis.title.x = element_blank())   \n\n\n\n\n\n\n\n\n\nConcluiu_ou_nao_graduacao &lt;- dados_PNADc_srvyr |&gt; \n  group_by(Concluiu_ou_nao_graduacao) |&gt; \n  summarise(n = survey_total(na.rm=T))\nConcluiu_ou_nao_graduacao &lt;- Concluiu_ou_nao_graduacao |&gt; \n  drop_na()\n\n\n# Calcular proporções\nConcluiu_ou_nao_graduacao$proporcao_grad &lt;- Concluiu_ou_nao_graduacao$n / sum(Concluiu_ou_nao_graduacao$n) * 100\n\nggplot(Concluiu_ou_nao_graduacao, aes(x = \"\", y = n, fill = Concluiu_ou_nao_graduacao)) +\n  geom_bar(width = 1, stat = \"identity\") +\n  geom_text(aes(label = paste0(round(proporcao_grad), \"%\")), \n            position = position_stack(vjust = 0.5)) +\n  coord_polar(theta = \"y\") +\n  labs(title = \"Distribuição por Concluinte ou não da graduação\") +\n  theme_minimal() +\n  theme(axis.text.x = element_blank(),\n        axis.title.x = element_blank())\n\n\n\n\n\n\n\n\nNúmero de Pessoas por Cor Raça\n\nCor_Raca &lt;- dados_PNADc_srvyr |&gt; \n  group_by(Cor_Raca) |&gt; \n  summarise(n = survey_total(na.rm=T))\nCor_Raca |&gt; \n  knitr::kable(col.names = c(\"Cor/Raça\", \"N\", \"Erro Amostral\"))\n\n\n\n\nCor/Raça\nN\nErro Amostral\n\n\n\n\nBranca\n91626405.60\n444335.94\n\n\nPreta\n22663392.29\n259799.55\n\n\nAmarela\n1740263.44\n87013.00\n\n\nParda\n97088333.39\n421042.96\n\n\nIndígena\n951366.20\n45396.02\n\n\nIgnorado\n83880.12\n17573.45\n\n\n\n\n\nGráfico de Barras\n\nggplot(Cor_Raca, aes(x = Cor_Raca, y = n, label = round(n))) +\n  geom_col(fill = \"blue\") +\n  geom_text(size = 3, position = position_stack(vjust = 0.5),  color = \"black\") +\n  xlab(\"\") +\n  ylab(\"\") +\n  labs(title = \"Distribuição por Cor/Raça\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nHistograma de idades\n\nsvyhist(formula=~as.numeric(V2009), \n        design=dados_PNADc,\n        freq=TRUE,\n        main=\"Histograma Idade\",\n        xlab=\"Distribuição da Idade\",\n        col = \"blue\")\n\n\n\n\n\n\n\n\nDistribuição rendimentos efetivos\n\nsvyhist(formula = ~as.numeric(V2009), \n        design = dados_PNADc, \n        freq = TRUE, \n        main = \"Histograma rendimentos efetivos\", \n        xlab = \"Renda média\",\n        col = \"blue\")\n\n\n\n\n\n\n\n\n\nsvyhist(formula = ~as.numeric(V2001), \n        design = dados_PNADc, \n        freq = TRUE, \n        main = \"Histograma número de pessoas no domicílio\", \n        xlab = \"Número de Pessoas\",\n        col = \"blue\")\n\n\n\n\n\n\n\n\n\nsvyboxplot(formula=VD4020~V2007, design=dados_PNADc, all.outliers=TRUE, main=\"Boxplot da Idade por sexo\")\n\n\n\n\n\n\n\n\n\nsvyboxplot(formula=VD4020~V2007, design=dados_PNADc, all.outliers=TRUE, main=\"Boxplot da rendimentos efetivos por sexo\")\n\n\n\n\n\n\n\n\nRendimentos efetivos por concluintes ou não da graduação\n\nsvyboxplot(formula=VD4020~V3007, design=dados_PNADc, all.outliers=TRUE, main=\"Boxplot da rendimentos efetivos por concluintes ou não da graduação\")\n\n\n\n\n\n\n\n\nDistribuição dos anos de estudo\n\nsvyhist(formula=~as.numeric(VD3005), design=dados_PNADc, freq=TRUE, main=\"Histograma Anos de Estudo\", xlab=\"Anos de Estudo\", col = \"blue\")"
  },
  {
    "objectID": "projetos-R/posts/projeto-PNADc.html#regressão-linear",
    "href": "projetos-R/posts/projeto-PNADc.html#regressão-linear",
    "title": "Acessando dados da PNADC disponíveis no site do IBGE com o pacote PNADcIBGE",
    "section": "Regressão Linear",
    "text": "Regressão Linear\n\nmod &lt;- svyglm(formula = VD4035 ~ V3007 + V2010, design = dados_PNADc)\nsummary(mod)\n\n\nCall:\nsvyglm(formula = VD4035 ~ V3007 + V2010, design = dados_PNADc)\n\nSurvey design:\nsvrepdesign.default(data = data_pnadc, weight = ~V1032, type = \"bootstrap\", \n    repweights = \"V1032[0-9]+\", mse = TRUE, replicates = length(sprintf(\"V1032%03d\", \n        seq(1:200))), df = length(sprintf(\"V1032%03d\", seq(1:200))))\n\nCoefficients:\n              Estimate Std. Error t value             Pr(&gt;|t|)    \n(Intercept)    38.1318     0.5898  64.648 &lt; 0.0000000000000002 ***\nV3007Não       -1.7193     0.5553  -3.096              0.00225 ** \nV2010Preta      0.4499     0.5901   0.762              0.44677    \nV2010Amarela    1.7782     2.2502   0.790              0.43036    \nV2010Parda      0.3756     0.3996   0.940              0.34841    \nV2010Indígena   5.8057     3.2301   1.797              0.07384 .  \nV2010Ignorado -23.0088     8.9240  -2.578              0.01067 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for gaussian family taken to be 204.6414)\n\nNumber of Fisher Scoring iterations: 2"
  },
  {
    "objectID": "projetos-R/posts/Script-Teste-T.html",
    "href": "projetos-R/posts/Script-Teste-T.html",
    "title": "Teste T para amostras independentes e amostras pareadas",
    "section": "",
    "text": "Este artigo foi escrito em Sábado, 25 de Maio de 2024."
  },
  {
    "objectID": "projetos-R/posts/Script-Teste-T.html#teste-t-para-amostras-independentes",
    "href": "projetos-R/posts/Script-Teste-T.html#teste-t-para-amostras-independentes",
    "title": "Teste T para amostras independentes e amostras pareadas",
    "section": "Teste T para amostras independentes",
    "text": "Teste T para amostras independentes\nQuando queremos comparar as médias de duas amostras independentes, utilizamos o teste T para amostras independentes. A hipótese nula é que as médias das duas amostras são iguais. A hipótese alternativa é que as médias das duas amostras são diferentes.\n\\(H_0: \\mu_X = \\mu_Y\\)\n\\(H_1: \\mu_X \\neq \\mu_Y\\)\nQuais são os pressupostos do teste T para amostras independentes?\nA variável dependente deve ser quantitativa (discreta ou contínua) e a variável independente deve ser qualitativa, com apenas duas categorias - por exemplo, sexo (masculino/feminino), escolaridade (fundamental/médio), tratamento (placebo/tratamento) (FIGUEIREDO FILHO, 2019).\n\nAs duas amostras são independentes.\nAs duas amostras são normalmente distribuídas.\nAs duas amostras têm variâncias iguais.\n\n\\(X \\sim Normal(\\mu, \\sigma^2_X)\\)\n\\(X \\sim Normal(\\mu, \\sigma^2_Y)\\)\nA fórmula do teste T para amostras independentes é:\n\\[t = \\frac{(\\bar{x}_1 - \\bar{x}_2)}{\\sqrt{\\frac{s_1^2}{n_1} + \\frac{s_2^2}{n_2}}}\\] Onde: - \\(\\bar{x}_1\\) e \\(\\bar{x}_2\\) são as médias das duas amostras.\n\n\\(s_1\\) e \\(s_2\\) são os desvios padrão das duas amostras.\n\\(n_1\\) e \\(n_2\\) são os tamanhos das duas amostras.\n\nAplicação no R:\n\n\nCode\n# Instalando e carregando o pacote\nif(!require(tidyverse)){install.packages(\"tidyverse\")};library(tidyverse)\nif(!require(readr)){install.packages(\"readr\")}; library(readr)\nif(!require(rstatix)){install.packages(\"rstatix\")}; library(rstatix)\nif(!require(kableExtra)){install.packages(\"kableExtra\")}; library(kableExtra)\nif(!require(broom)){install.packages(\"broom\")}; library(broom)\n\n\nLendo os dados do Github\nOs dados que vamos utilizar são os dados disponiblizados pela Fernanda Peres no seu repositório do Github (“Fernanda Peres | Estatística aplicada”, [s.d.]).\n\n\nCode\ndados &lt;- read_delim(\"https://raw.githubusercontent.com/fernandaperes/bancosdedados/main/Bancos%20em%20csv/Banco%20de%20Dados%203.csv\", delim = \";\")\n\n\nDando uma olhada nos dados\n\n\nCode\n# Verificando os dados\nkable(head(dados))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSujeito\nGenero\nEscola\nPosicao_Sala\nNota_Biol\nNota_Fis\nNota_Hist\n\n\n\n\n1\nM\nPrivada\nFundos\n81\n46\n29\n\n\n2\nF\nPrivada\nFundos\n53\n49\n64\n\n\n3\nM\nPublica\nFundos\n29\n37\n31\n\n\n4\nM\nPublica\nFundos\n37\n38\n49\n\n\n5\nF\nPublica\nFundos\n44\n42\n49\n\n\n6\nF\nPublica\nFundos\n47\n49\n55\n\n\n\n\n\n\n\nCode\n# Verificando estrutura dos dados\n(str(dados))\n\n\nspc_tbl_ [32 × 7] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Sujeito     : num [1:32] 1 2 3 4 5 6 7 8 9 10 ...\n $ Genero      : chr [1:32] \"M\" \"F\" \"M\" \"M\" ...\n $ Escola      : chr [1:32] \"Privada\" \"Privada\" \"Publica\" \"Publica\" ...\n $ Posicao_Sala: chr [1:32] \"Fundos\" \"Fundos\" \"Fundos\" \"Fundos\" ...\n $ Nota_Biol   : num [1:32] 81 53 29 37 44 47 54 58 31 6 ...\n $ Nota_Fis    : num [1:32] 46 49 37 38 42 49 64 68 41 69 ...\n $ Nota_Hist   : num [1:32] 29 64 31 49 49 55 74 81 33 83 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Sujeito = col_double(),\n  ..   Genero = col_character(),\n  ..   Escola = col_character(),\n  ..   Posicao_Sala = col_character(),\n  ..   Nota_Biol = col_number(),\n  ..   Nota_Fis = col_number(),\n  ..   Nota_Hist = col_number()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nNULL\n\n\nQuestões que vamos responder com o teste t\nQuestão 1: Existe diferença entre as notas em Biologia/História de alunos do sexo masculino e feminino?\nHipóteses:\n\\(H_0: \\text{A média das notas em (Biologia/história) para alunos do sexo Masculino = Feminino}\\)\n\\(H_1: \\text{A média das notas em (Biologia/história) para alunos do sexo Masculino $\\neq$ Feminino}\\)\nVerificando a distribuição das medidas em cada grupo\nNota de Biologia\n\n\nCode\nmedia_biol &lt;- dados |&gt; \n  group_by(Genero) |&gt; \n  summarise(media = mean(Nota_Biol, na.rm = TRUE))\n\n\ndados |&gt; \n  ggplot(aes(x = Nota_Biol, fill = Genero)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em Biologia por Gênero\")+\n  geom_vline(data = media_biol, aes(xintercept = media, color = Genero),\n             linetype = \"dashed\", size = 1) \n\n\n\n\n\n\n\n\n\n\n\nCode\n# boxplot\ndados |&gt; \n  ggplot(aes(x = Genero, y = Nota_Biol, fill = Genero)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em Biologia por Gênero\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em Biologia para alunos do sexo masculino e feminino é semelhante.\nNota de História\n\n\nCode\nmedia_hist &lt;- dados |&gt; \n  group_by(Genero) |&gt; \n  summarise(media = mean(Nota_Hist, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Hist, fill = Genero)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em História por Gênero\")+\n  geom_vline(data = media_hist, aes(xintercept = media, color = Genero),\n             linetype = \"dashed\", size = 1) \n\n\n\n\n\n\n\n\n\n\n\nCode\n# boxplot\ndados |&gt; \n  ggplot(aes(x = Genero, y = Nota_Hist, fill = Genero)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em História por Gênero\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em História para alunos do sexo masculino e feminino é semelhante.\nAgora vamos realizar o teste T para amostras independentes. Mas antes, vamos verificar se os pressupostos do teste T para amostras independentes são atendidos.\nVerificando pressupostos para o teste T para amostras independentes\n\nVerificando normalidade da variável dependente em cada grupo\n\n\n\nCode\nkable(dados |&gt; \n  group_by(Genero) |&gt; \n  shapiro_test(Nota_Biol, Nota_Hist))\n\n\n\n\n\nGenero\nvariable\nstatistic\np\n\n\n\n\nF\nNota_Biol\n0.9638246\n0.7313738\n\n\nF\nNota_Hist\n0.9695677\n0.8315585\n\n\nM\nNota_Biol\n0.9876640\n0.9970551\n\n\nM\nNota_Hist\n0.9518625\n0.5197572\n\n\n\n\n\nO teste de Shapiro-Wilk é um teste de normalidade que testa a hipótese nula de que os dados foram extraídos de uma população com distribuição normal.\n\\(H_0: \\text{Os dados são normalmente distribuídos}\\)\n\\(H_1: \\text{Os dados não são normalmente distribuídos}\\)\nComo o valor de p é maior que \\(0,05\\), em todos os grupos não rejeitamos a hipótese nula. Portanto, a variável dependente é normalmente distribuída em cada grupo.\n\nVerificando homogeneidade de variância\n\nNotas de Biologia\n\n\nCode\nkable(levene_test(Nota_Biol ~ Genero, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n0.1248719\n0.7262806\n\n\n\n\n\nNotas de História\n\n\nCode\nkable(levene_test(Nota_Hist ~ Genero, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n2.842218\n0.1021925\n\n\n\n\n\nO teste de Levene é um teste de homogeneidade de variância que testa a hipótese nula de que as variâncias são iguais em todos os grupos.\n\\(H_0: \\text{As variâncias são iguais}\\)\n\\(H_1: \\text{As variâncias não são iguais}\\)\nComo o valor de p é maior que \\(0,05\\), não rejeitamos a hipótese nula. Portanto, as variâncias são iguais em todos os grupos.\nComo os pressupostos do teste T para amostras independentes são atendidos, podemos prosseguir com o teste T.\nRealizando o teste T para amostras independentes\nNotas de Biologia\n\n\nCode\nkable(tidy(t.test(Nota_Biol ~ Genero, var.equal = TRUE, data = dados)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nestimate\nestimate1\nestimate2\nstatistic\np.value\nparameter\nconf.low\nconf.high\nmethod\nalternative\n\n\n\n\n-3.4375\n45.5\n48.9375\n-0.4176915\n0.6791471\n30\n-20.24491\n13.36991\nTwo Sample t-test\ntwo.sided\n\n\n\n\n\nComo o valor de p \\((0,6791)\\) é maior que \\(0,05\\), rejeitamos a hipótese nula. Portanto, a média das notas em Biologia para alunos do sexo masculino pode ser igual à média das notas em Biologia para alunos do sexo feminino.Outra evidência que temos é que o intervalo de confiança \\((-20.24491;  13.36991)\\) para a diferença das médias inclui o zero.\nNotas de História\n\n\nCode\nkable(tidy(t.test(Nota_Hist ~ Genero, var.equal = TRUE, data = dados)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nestimate\nestimate1\nestimate2\nstatistic\np.value\nparameter\nconf.low\nconf.high\nmethod\nalternative\n\n\n\n\n-3.0625\n41.5\n44.5625\n-0.3535687\n0.7261348\n30\n-20.75202\n14.62702\nTwo Sample t-test\ntwo.sided\n\n\n\n\n\nComo o valor de p \\((0,6791)\\) é maior que \\(0,05\\), rejeitamos a hipótese nula. Portanto, a média das notas em História para alunos do sexo masculino pode ser igual à média das notas em História para alunos do sexo feminino. Outra evidência que temos é que o intervalo de confiança \\((-20.75202; 14.62702)\\) para a diferença das médias inclui o zero.\nQuestão 2: Existe diferença entre as notas em Física/Biologia/História de alunos de escolas públicas e privadas?\nHipóteses:\n\\(H_0: \\text{A média das notas em (Física/Biologia/história) para alunos de escolas públicas = privadas}\\)\n\\(H_1: \\text{A média das notas em (Física/Biologia/história) para alunos de escolas públicas $\\neq$ privadas}\\)\nVerificando a distribuição das medidas em cada grupo\nNota de Física\n\n\nCode\nmedia_fisica &lt;- dados |&gt; \n  group_by(Escola) |&gt; \n  summarise(media = mean(Nota_Fis, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Fis, fill = Escola)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em Física por Escola\")+\n  geom_vline(data = media_fisica, aes(xintercept = media, color = Escola),\n             linetype = \"dashed\", size = 1) \n\n\n\n\n\n\n\n\n\n\n\nCode\n# Boxplot\ndados |&gt; \n  ggplot(aes(x = Escola, y = Nota_Fis, fill = Escola)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em Física por Escola\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em Física para alunos de escolas públicas e privadas parece ser diferentes.\nNota de Biologia\n\n\nCode\nmedia &lt;- dados |&gt; \n  group_by(Escola) |&gt; \n  summarise(media = mean(Nota_Biol, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Biol, fill = Escola)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em Biologia por Escola\") +\n  geom_vline(data = media, aes(xintercept = media, color = Escola),\n             linetype = \"dashed\", size = 1) \n\n\n\n\n\n\n\n\n\n\n\nCode\n# Boxplot\ndados |&gt; \n  ggplot(aes(x = Escola, y = Nota_Biol, fill = Escola)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em Biologia por Escola\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em Biologia para alunos de escolas públicas e privadas parece ser diferentes.\nNota de História\n\n\nCode\nmedia &lt;- dados |&gt; \n  group_by(Escola) |&gt; \n  summarise(media = mean(Nota_Hist, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Hist, fill = Escola)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em História por Escola\") +\n  geom_vline(data = media, aes(xintercept = media, color = Escola),\n             linetype = \"dashed\", size = 1) \n\n\n\n\n\n\n\n\n\n\n\nCode\n# Boxplot\ndados |&gt; \n  ggplot(aes(x = Escola, y = Nota_Hist, fill = Escola)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em História por Escola\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em História para alunos de escolas públicas e privadas parece ser diferentes.\nVerificando pressupostos para o teste T para amostras independentes\n\nVerificando normalidade da variável dependente em cada grupo\n\n\n\nCode\nkable(dados |&gt; \n  group_by(Escola) |&gt; \n  shapiro_test(Nota_Fis, Nota_Biol, Nota_Hist))\n\n\n\n\n\nEscola\nvariable\nstatistic\np\n\n\n\n\nPrivada\nNota_Biol\n0.9144470\n0.1372675\n\n\nPrivada\nNota_Fis\n0.9303937\n0.2473161\n\n\nPrivada\nNota_Hist\n0.8796205\n0.0382805\n\n\nPublica\nNota_Biol\n0.7936696\n0.0022470\n\n\nPublica\nNota_Fis\n0.7646116\n0.0009581\n\n\nPublica\nNota_Hist\n0.8900330\n0.0557702\n\n\n\n\n\nComo o valor de p é menor que \\(0,05\\), em quase todos os grupos rejeitamos a hipótese nula. Portanto, a variável dependente não é normalmente distribuída em todos os grupos. Com isso, já poderíamos parar por aqui, pois o teste T para amostras independentes requer que a variável dependente seja normalmente distribuída em cada grupo.\n\nVerificando homogeneidade de variância\n\n\n\nCode\nkable(levene_test(Nota_Biol ~ Escola, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n4.962929\n0.0335438\n\n\n\n\n\n\n\nCode\nkable(levene_test(Nota_Fis ~ Escola, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n2.262799\n0.1429705\n\n\n\n\n\n\n\nCode\nkable(levene_test(Nota_Hist ~ Genero, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n2.842218\n0.1021925\n\n\n\n\n\nAssim como o teste de normalidade, o teste de homogeneidade de variância também não é atendido. Portanto, não podemos prosseguir com o teste T para amostras independentes.\nQuestão 3: Existe diferença entre as notas em Biologia/História de alunos que se sentam na frente e fundo da sala?\nHipóteses:\n\\(H_0: \\text{A média das notas em (Biologia/história) para alunos que se sentam na frente = fundo}\\)\n\\(H_1: \\text{A média das notas em (Biologia/história) para alunos que se sentam na frente $\\neq$ fundo}\\)\nVerificando a distribuição das medidas em cada grupo\nNotas de Biologia\n\n\nCode\nmedia &lt;- dados |&gt; \n  group_by(Posicao_Sala) |&gt; \n  summarise(media = mean(Nota_Biol, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Biol, fill = Posicao_Sala)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em Biologia por Posição na Sala\") +\n  geom_vline(data = media, aes(xintercept = media, color = Posicao_Sala),\n             linetype = \"dashed\", size = 1)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Boxplot\ndados |&gt; \n  ggplot(aes(x = Posicao_Sala, y = Nota_Biol, fill = Posicao_Sala)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em Biologia por Posição na Sala\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em Biologia para alunos que se sentam na frente e fundo da sala parece ser diferentes.\nNotas de História\n\n\nCode\nmedia &lt;- dados |&gt; \n  group_by(Posicao_Sala) |&gt; \n  summarise(media = mean(Nota_Hist, na.rm = TRUE))\n\ndados |&gt; \n  ggplot(aes(x = Nota_Hist, fill = Posicao_Sala)) +\n  geom_density(alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas em História por Posição na Sala\") +\n  geom_vline(data = media, aes(xintercept = media, color = Posicao_Sala),\n             linetype = \"dashed\", size = 1)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Boxplot\ndados |&gt; \n  ggplot(aes(x = Posicao_Sala, y = Nota_Hist, fill = Posicao_Sala)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas em História por Posição na Sala\")\n\n\n\n\n\n\n\n\n\nO gráfico de boxplot mostra que a distribuição das notas em História para alunos que se sentam na frente e fundo da sala parece ser diferentes.\nVerificando pressupostos para o teste T para amostras independentes\n\nVerificando normalidade da variável dependente em cada grupo\n\n\n\nCode\nkable(dados |&gt; \n  group_by(Posicao_Sala) |&gt; \n  shapiro_test(Nota_Biol, Nota_Hist))\n\n\n\n\n\nPosicao_Sala\nvariable\nstatistic\np\n\n\n\n\nFrente\nNota_Biol\n0.9471473\n0.4806953\n\n\nFrente\nNota_Hist\n0.9295942\n0.2690903\n\n\nFundos\nNota_Biol\n0.9306021\n0.2227459\n\n\nFundos\nNota_Hist\n0.9425044\n0.3490982\n\n\n\n\n\nComo o valor de p é maior que \\(0,05\\), em todos os grupos não rejeitamos a hipótese nula. Portanto, a variável dependente é normalmente distribuída em cada grupo.\n\nVerificando homogeneidade de variância\n\n\n\nCode\nkable(levene_test(Nota_Hist ~ Posicao_Sala, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n11.9759\n0.0016393\n\n\n\n\n\nO teste de homogeneidade de variância não foi atendido. Portanto, não podemos prosseguir com o teste T para amostras independentes para a variável Nota_Hist.\n\n\nCode\nkable(levene_test(Nota_Biol ~ Posicao_Sala, data = dados, center = \"mean\"))\n\n\n\n\n\ndf1\ndf2\nstatistic\np\n\n\n\n\n1\n30\n2.786168\n0.1054859\n\n\n\n\n\nJá aqui, o teste de homogeneidade de variância foi atendido. Portanto, podemos prosseguir com o teste T para amostras independentes para a variável Nota_Biol.\nRealizando o teste T para amostras independentes\n\n\nCode\nkable(tidy(t.test(Nota_Biol ~ Posicao_Sala, var.equal = TRUE, data = dados)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nestimate\nestimate1\nestimate2\nstatistic\np.value\nparameter\nconf.low\nconf.high\nmethod\nalternative\n\n\n\n\n18.03529\n56.8\n38.76471\n2.377442\n0.0240075\n30\n2.542596\n33.52799\nTwo Sample t-test\ntwo.sided\n\n\n\n\n\nComo o valor de p \\((0.02401)\\) é menor que \\(0,05\\), rejeitamos a hipótese nula. Portanto, a média das notas em Biologia para alunos que se sentam na frente pode ser diferente da média das notas em Biologia para alunos que se sentam no fundo. Outra evidência que temos é que o intervalo de confiança \\((2.542596;  33.527992)\\) para a diferença das médias não inclui o zero."
  },
  {
    "objectID": "projetos-R/posts/Script-Teste-T.html#teste-t-para-amostras-pareadas",
    "href": "projetos-R/posts/Script-Teste-T.html#teste-t-para-amostras-pareadas",
    "title": "Teste T para amostras independentes e amostras pareadas",
    "section": "Teste T para amostras pareadas",
    "text": "Teste T para amostras pareadas\nQuando queremos comparar as médias de duas amostras pareadas, utilizamos o teste T para amostras pareadas. A hipótese nula é que as médias das duas amostras são iguais. A hipótese alternativa é que as médias das duas amostras são diferentes.\nPara realizar o teste T para amostras pareadas, precisamos de duas amostras pareadas. Por exemplo, a nota de um aluno na primeira prova de Biologia e a nota do mesmo aluno na segunda prova de Biologia.Ou duas condições experimentais aplicadas ao mesmo grupo de indivíduos.\n\\(H_0: \\mu_X = \\mu_Y\\)\n\\(H_1: \\mu_X \\neq \\mu_Y\\)\nQuais são os pressupostos do teste T para amostras pareadas?\n\nAs duas amostras são pareadas.\nAs diferenças entre as duas amostras são normalmente distribuídas.\n\n\\(X \\sim Normal(\\mu, \\sigma^2_X)\\)\n\\(Y \\sim Normal(\\mu, \\sigma^2_Y)\\)\nA fórmula do teste T para amostras pareadas é:\n\\[t = \\frac{\\bar{d}}{\\frac{s_d}{\\sqrt{n}}}\\]\nOnde:\n\n\\(\\bar{d}\\) é a média das diferenças entre as duas amostras.\n\\(s_d\\) é o desvio padrão das diferenças entre as duas amostras.\n\\(n\\) é o tamanho das amostras.\n\nAplicação no R:\nPara fins didáticos, vamos criar um exemplo fictício de um teste T para amostras pareadas.Para tal, vamos supor que a nota de física será a nota da segunda prova de Biologia.\n\n\nCode\ndados_01 &lt;- dados |&gt; \n  rename(Nota_Biol_2 = Nota_Fis)\n\n\nVerificando distribuição dos dados\n\n\nCode\nmean_Nota_Biol &lt;- mean(dados_01$Nota_Biol, na.rm = TRUE)\nmean_Nota_Biol_2 &lt;- mean(dados_01$Nota_Biol_2, na.rm = TRUE)\n\ndados_01 |&gt; \n  ggplot(aes(x = Nota_Biol)) +\n  geom_density(aes(fill = \"Nota_Biol\"), alpha = 0.5) +\n  geom_density(aes(x = Nota_Biol_2, fill = \"Nota_Biol_2\"), alpha = 0.5) +\n  theme_minimal() +\n  labs(title = \"Distribuição das notas de Biologia e Biologia 2\", fill = \"Variável\") +\n  geom_vline(aes(xintercept = mean_Nota_Biol, color = \"Nota_Biol\"), linetype = \"dashed\", size = 1) +\n  geom_vline(aes(xintercept = mean_Nota_Biol_2, color = \"Nota_Biol_2\"), linetype = \"dashed\", size = 1)\n\n\n\n\n\n\n\n\n\n\n\nCode\ndados_01 |&gt; \n  pivot_longer(cols = c(Nota_Biol, Nota_Biol_2), names_to = \"Prova\", values_to = \"Nota\") |&gt; \n  ggplot(aes(x = Prova, y = Nota, fill = Prova)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(title = \"Boxplot das notas de Biologia e Biologia 2\")\n\n\n\n\n\n\n\n\n\nAqui, podemos notar que a distribuição das notas de Biologia e Biologia 2 é semelhante.Agora vamos realizar o teste T para amostras pareadas para verificar se isso se confirma.\nRealizando o teste T para amostras pareadas\n\n\nCode\nkable(tidy(t.test(dados_01$Nota_Biol_2, dados_01$Nota_Biol, paired = TRUE)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nestimate\nstatistic\np.value\nparameter\nconf.low\nconf.high\nmethod\nalternative\n\n\n\n\n4.65625\n0.9823453\n0.3335348\n31\n-5.010905\n14.3234\nPaired t-test\ntwo.sided\n\n\n\n\n\nComo o valor de p \\((0.3335)\\) é maior que \\(0,05\\), não rejeitamos a hipótese nula. Portanto, a média das notas de Biologia pode ser igual à média das notas de Biologia 2. Outra evidência que temos é que o intervalo de confiança \\((-2.292,  6.292)\\) para a diferença das médias inclui o zero.\nReferências\nBARBETTA, P. A. Estatística aplicada às Ciências Sociais. [s.l.] Editora UFSC, 2014.\nFernanda Peres | Estatística aplicada. Disponível em: https://fernandafperes.com.br/. Acesso em: 25 maio. 2024.\nFIGUEIREDO FILHO, D. B. Métodos quantitativos em ciência política. [s.l.] Editora Intersaberes, 2019.\nGASPAR, J. DE S. Como descrever meus dados e quais testes estatísticos devo usar? Zenodo, , 22 abr. 2023. Disponível em: https://zenodo.org/records/7855276. Acesso em: 23 jan. 2024"
  },
  {
    "objectID": "projetos-R/posts/analise-PROUNI.html",
    "href": "projetos-R/posts/analise-PROUNI.html",
    "title": "Análise de dados do Programa Universidade para Todos (ProUni)",
    "section": "",
    "text": "Artigo em construção"
  },
  {
    "objectID": "projetos-R/posts/analise-PROUNI.html#capítulo-1-o-início-de-uma-jornada",
    "href": "projetos-R/posts/analise-PROUNI.html#capítulo-1-o-início-de-uma-jornada",
    "title": "Análise de dados do Programa Universidade para Todos (ProUni)",
    "section": "Capítulo 1: O Início de uma Jornada",
    "text": "Capítulo 1: O Início de uma Jornada\nEm 2004, o governo federal brasileiro lançou o Programa Universidade para Todos (Prouni), uma iniciativa revolucionária destinada a ampliar o acesso à educação superior no país. Os dados iniciais do Prouni revelam um aumento significativo no número de bolsas concedidas a cada ano, indicando uma crescente demanda por oportunidades educacionais entre os brasileiros.\n\n\nCode\ndados_prep  |&gt; \n  group_by(ano=as_factor(ANO_CONCESSAO_BOLSA)) |&gt; \n  summarise(qtd_bolsas_ano = n()) |&gt; \n  ggplot(mapping = aes(x =  ano, y = qtd_bolsas_ano, group = 1)) +\n  geom_line()+\n  geom_point()+\n    labs(title = \"Número Bolsas concedidas por ano\", y = NULL, x = NULL, subtitle = \"PROUNI - (2005 - 2020)\") + \n  theme_minimal()+\n  geom_text(aes(x = ano, y = qtd_bolsas_ano, label = paste0(qtd_bolsas_ano)),\n                        vjust = -1.5, size = 2, color = \"blue\")+\n  theme(plot.title = element_text(size=12),axis.text.x= element_text(size=),\n                            axis.text.y= element_text(size=8), axis.title=element_text(size=6))+\n  scale_fill_brewer(palette = \"Set3\")+ \n  theme(axis.text.y = element_blank())\n\n\n\n\n\n\n\n\n\nComo podemos notar o ano de 2015 foi o que mais teve bolsas concedidas. Tivemos um aumento até 2015 e depois uma queda."
  },
  {
    "objectID": "projetos-R/posts/analise-PROUNI.html#capítulo-2-distribuição-de-bolsas-por-região",
    "href": "projetos-R/posts/analise-PROUNI.html#capítulo-2-distribuição-de-bolsas-por-região",
    "title": "Análise de dados do Programa Universidade para Todos (ProUni)",
    "section": "Capítulo 2: Distribuição de Bolsas por Região",
    "text": "Capítulo 2: Distribuição de Bolsas por Região\nGráfico de Número de Bolsas Concedidas por Ano e Região\n\n\nCode\ndados_prep |&gt; \n  group_by(ano = as.factor(ANO_CONCESSAO_BOLSA), regiao = REGIAO_BENEFICIARIO_BOLSA) |&gt; \n  summarise(qtd_bolsas_ano = n(), .groups = 'drop') %&gt;%\n  ggplot(mapping = aes(x = ano, y = qtd_bolsas_ano, fill = regiao, label = qtd_bolsas_ano)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  geom_text(position = position_stack(vjust = 0.5), size = 3, color = \"white\") +\n  labs(\n    title = \"Número de Bolsas Concedidas por Ano e Região\", \n    subtitle = \"PROUNI - (2005 - 2020)\", \n    y = \"Quantidade de Bolsas\", \n    x = \"\",\n    fill = \"Região\"\n  ) + \n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),\n    axis.text.y = element_text(size = 8),\n    axis.title = element_text(size = 10)\n  ) +\n  scale_fill_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\nGráfico de Proporção de Bolsas Concedidas por Ano e Região\n\n\nCode\ntotal_por_ano &lt;- dados_prep |&gt; \n  group_by(as.factor(ANO_CONCESSAO_BOLSA)) |&gt; \n  summarise(total_bolsas_ano = n(), .groups = 'drop') |&gt; \n  rename(ano = \"as.factor(ANO_CONCESSAO_BOLSA)\")\n\ndados_por_ano_regiao &lt;- dados_prep  |&gt; \n  group_by(ano = as.factor(ANO_CONCESSAO_BOLSA), regiao = REGIAO_BENEFICIARIO_BOLSA)  |&gt; \n  summarise(qtd_bolsas_ano = n(), .groups = 'drop')\n\ndados_proporcao &lt;- left_join(dados_por_ano_regiao, total_por_ano, by = \"ano\")  |&gt; \n  mutate(proporcao = (qtd_bolsas_ano / total_bolsas_ano))\n\nggplot(dados_proporcao, aes(x = ano, y = proporcao, fill = regiao)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  geom_text(aes(label = scales::percent(round(proporcao, 3)), y = proporcao), \n            position = position_stack(vjust = 0.5), \n            size = 3, \n            color = \"black\") +  \n  labs(\n    title = \"Proporção de Bolsas Concedidas por Ano e Região\", \n    subtitle = \"PROUNI - (2005 - 2020)\", \n    y = \"\",\n    x = \"\",\n    fill = \"Região\"\n  ) + \n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),\n    axis.text.y = element_text(size = 8),\n    axis.title = element_text(size = 10)\n  ) +\n  scale_fill_brewer(palette = \"Set1\")"
  },
  {
    "objectID": "projetos-PBI/posts/Projeto-G-Data-Analytics.html",
    "href": "projetos-PBI/posts/Projeto-G-Data-Analytics.html",
    "title": "Projeto final de Data Analytics do Google",
    "section": "",
    "text": "Este artigo foi reescrito em Segunda-Feira, 12 de Fevereiro de 2024."
  },
  {
    "objectID": "projetos-PBI/posts/Projeto-G-Data-Analytics.html#estudo-de-caso",
    "href": "projetos-PBI/posts/Projeto-G-Data-Analytics.html#estudo-de-caso",
    "title": "Projeto final de Data Analytics do Google",
    "section": "Estudo de caso",
    "text": "Estudo de caso\n\nResumo do Projeto Final de Data Analytics\nO Projeto Final de Data Analytics do Google consistiu em uma análise sobre o perfil religioso do Brasil, utilizando um conjunto de dados público do Censo de 2000 e 2010 do IBGE. O processo começou com a formulação da pergunta de pesquisa, que foi definida como investigar o perfil religioso da população brasileira.\nApós a definição da pergunta, foram pesquisadas fontes de dados adequadas para obter informações relevantes. O conjunto de dados do Censo de 2000 e 2010 do IBGE foi identificado como a fonte ideal para o estudo, pois continha informações sobre a religião da população brasileira.\nEm seguida, os dados foram limpos e processados utilizando a linguagem de programação R, resultando na criação de uma tabela de dados. Com a tabela pronta, foram criadas visualizações utilizando o Microsoft Power BI, facilitando a compreensão dos dados analisados.\n\n\nObtenção dos dados\nPara a obtenção dos dados, foi utilizado o pacote SIDRA, uma API que permite a raspagem (ou coleta) de dados de forma rápida e prática. O SIDRA (Sistema IBGE de Recuperação Automática) é uma ferramenta fornecida pelo Instituto Brasileiro de Geografia e Estatística (IBGE) que possibilita o acesso a diversas informações estatísticas, incluindo os dados do Censo de 2000 e 2010 referentes à religião da população brasileira.\nTenho dois tutoriais em como raspar esses dados usando o R e Python.\nCom o auxílio do pacote SIDRA, os dados necessários para a análise do projeto foram obtidos de maneira automatizada, facilitando o processo de coleta e preparação dos dados para a análise de Data Analytics. Esse tipo de abordagem permite que os dados sejam acessados de forma eficiente e confiável, garantindo a qualidade e a atualização das informações utilizadas no projeto.\n\n\nObtendo os dados de acordo com os parâmetros estabelecidos\nOs parâmetros utilizados para a geração das tabelas no projeto foram os seguintes:\n\nReligião: Esse parâmetro permitiu filtrar os dados com base nas diferentes religiões presentes na população brasileira. As religiões consideradas no Censo 2010 podem incluir, por exemplo, católicos, evangélicos, espíritas, entre outras.\nPeríodo: O período selecionado refere-se ao ano ou intervalo de tempo em que os dados foram coletados. No caso do projeto, o período correspondeu ao Censo 2010, que é a fonte de dados utilizada.\nCor ou Raça: Esse parâmetro possibilitou a segmentação dos dados com base na autodeclaração dos indivíduos quanto à sua cor ou raça. As categorias podem abranger brancos, negros, pardos, amarelos e indígenas, seguindo a classificação utilizada pelo IBGE.\nSexo: Esse parâmetro permitiu analisar os dados separadamente para homens e mulheres, proporcionando insights sobre possíveis diferenças ou tendências específicas relacionadas à religião.\nUnidade Geográfica: Esse parâmetro possibilitou a segmentação dos dados por diferentes unidades geográficas, como estados, municípios, regiões, entre outras. Com isso, foi possível identificar padrões e variações regionais no perfil religioso da população brasileira.\n\nA utilização desses parâmetros foi fundamental para uma análise detalhada e completa sobre o perfil religioso do Brasil, permitindo investigar diferentes aspectos socioculturais relacionados à religião em diferentes contextos geográficos e demográficos."
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html",
    "href": "projetos-R/posts/algebra-matricial.html",
    "title": "Introdução Álgebra Matricial",
    "section": "",
    "text": "Este artigo foi escrito em Segunda, 03 de Agosto de 2024."
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#matriz",
    "href": "projetos-R/posts/algebra-matricial.html#matriz",
    "title": "Introdução Álgebra Matricial",
    "section": "Matriz",
    "text": "Matriz\nUma matriz m x n é um arranjo de número de com m linhas e n colunas, considerado como uma única entidade.\n\\[\nA=\n\\begin{bmatrix}\n    a_{11} & a_{12} & \\cdots & a_{1n} \\\\\n    a_{21} & a_{22} & \\cdots & a_{2n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    a_{m1} & a_{m2} & \\cdots & a_{mn}\n\\end{bmatrix}\n\\]\nVeja o exemplo de uma matriz criada no R abaixo.\nPara criarmos uma matriz A com 5 linhas x 5 colunas no R usamos os seguintes comandos.\n\n\nCode\n# Criando uma matriz 5 x 5\nA &lt;- matrix(1:25, nrow = 5, ncol = 5)\nA\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\nA matriz acima é uma matriz quadrada, pois o número de linhas é igual ao número de colunas."
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#vetor",
    "href": "projetos-R/posts/algebra-matricial.html#vetor",
    "title": "Introdução Álgebra Matricial",
    "section": "Vetor",
    "text": "Vetor\nCaso tivéssemos uma matriz com uma única coluna, teríamos um vetor coluna. Veja o exemplo abaixo.\n\\[\n\\mathbf{c} = \\begin{bmatrix}\n    c_1 \\\\\n    c_2 \\\\\n    \\vdots \\\\\n    c_m\n\\end{bmatrix}\n\\]\n\n\nCode\n# Criando um vetor coluna da matriz A\nc &lt;- A[,1]\nc\n\n\n[1] 1 2 3 4 5\n\n\nCaso tivéssemos somente uma linha, teríamos um vetor linha. Veja o exemplo abaixo.\n\\[\n\\mathbf{r} = \\begin{bmatrix}\n    r_1 & r_2 & \\cdots & r_n\n\\end{bmatrix}\n\\]\n\n\nCode\n# Criando um vetor linha da matriz A\nr &lt;- A[1,]\nr\n\n\n[1]  1  6 11 16 21"
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#escalar",
    "href": "projetos-R/posts/algebra-matricial.html#escalar",
    "title": "Introdução Álgebra Matricial",
    "section": "Escalar",
    "text": "Escalar\nEm álgebra matricial um escalar pode ser definido como um único número \\(k = a_{11}\\)\n\n\nCode\n# escalar\nk &lt;- A[3,3]\nk\n\n\n[1] 13"
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#tipos-de-matrizes",
    "href": "projetos-R/posts/algebra-matricial.html#tipos-de-matrizes",
    "title": "Introdução Álgebra Matricial",
    "section": "Tipos de Matrizes",
    "text": "Tipos de Matrizes\nHá diversos tipos de matrizes, dentre elas podemos citar:\nMatriz zero: matriz onde todos os elementos são iguais a zero.\n\n\nCode\n# Matriz zero\nZ &lt;- matrix(0, nrow = 5, ncol = 5)\nZ\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n[3,]    0    0    0    0    0\n[4,]    0    0    0    0    0\n[5,]    0    0    0    0    0\n\n\nMatriz diagonal: matriz onde todos os elementos fora da diagonal principal são iguais a zero.\n\n\nCode\n# Matriz diagonal\nD &lt;- diag(1:5)\nD\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    2    0    0    0\n[3,]    0    0    3    0    0\n[4,]    0    0    0    4    0\n[5,]    0    0    0    0    5\n\n\nMatriz simétrica: matriz onde a transposta é igual a matriz original.\n\n\nCode\n# Matriz simétrica\nn = 4\nl = matrix(1:(n:4), nrow = n, ncol = n)\n\nS &lt;- l + t(l)\nS\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    3    4    5\n[2,]    3    4    5    6\n[3,]    4    5    6    7\n[4,]    5    6    7    8\n\n\n\n\nCode\n# Verificando se a matriz é simétrica\nt(S)\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    3    4    5\n[2,]    3    4    5    6\n[3,]    4    5    6    7\n[4,]    5    6    7    8\n\n\nMatriz identidade: matriz diagonal onde todos os elementos da diagonal principal são iguais a 1.\n\n\nCode\n# Matriz identidade\nI &lt;- diag(1, nrow = 5, ncol = 5)\nI\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n\n\nDuas matrizes são iguais se tiverem o mesmo número de linhas e colunas e se os elementos correspondentes forem iguais.\n\n\nCode\nX = matrix(1:25, nrow = 5, ncol = 5)\nY = matrix(1:25, nrow = 5, ncol = 5)\n# Verificando se duas matrizes são iguais\nX == Y\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] TRUE TRUE TRUE TRUE TRUE\n[2,] TRUE TRUE TRUE TRUE TRUE\n[3,] TRUE TRUE TRUE TRUE TRUE\n[4,] TRUE TRUE TRUE TRUE TRUE\n[5,] TRUE TRUE TRUE TRUE TRUE\n\n\nO traço de uma matriz quadrada é a soma dos elementos da diagonal principal. Veja o exemplo abaixo aplicado a matrir \\(X\\) criada anteriormente.\n\n\nCode\n# Traço de uma matriz\nsum(diag(X))\n\n\n[1] 65"
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#operações-com-matrizes",
    "href": "projetos-R/posts/algebra-matricial.html#operações-com-matrizes",
    "title": "Introdução Álgebra Matricial",
    "section": "Operações com Matrizes",
    "text": "Operações com Matrizes\n\nSoma e subtração de matrizes\nSoma: a soma em duas matrizes de mesmo tamanho é feita somando os elementos correspondentes. Por exemplo, sejam as matrizes \\(A\\) e \\(B\\) abaixo.\n\n\nCode\nA = matrix(1:25, nrow = 5, ncol = 5)\n\nB = matrix(26:50, nrow = 5, ncol = 5)\n\n# Soma de matrizes\nA + B\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   27   37   47   57   67\n[2,]   29   39   49   59   69\n[3,]   31   41   51   61   71\n[4,]   33   43   53   63   73\n[5,]   35   45   55   65   75\n\n\nSubtração: a subtração em duas matrizes de mesmo tamanho é feita subtraindo os elementos correspondentes. Por exemplo, sejam as matrizes A e B criadas anteriormente, temos:\n\n\nCode\n# Subtração de matrizes\nA - B\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  -25  -25  -25  -25  -25\n[2,]  -25  -25  -25  -25  -25\n[3,]  -25  -25  -25  -25  -25\n[4,]  -25  -25  -25  -25  -25\n[5,]  -25  -25  -25  -25  -25\n\n\n\n\nMultiplicação\nMultiplicação de uma matriz com um escalar\nA multiplicação de um escalar com uma matriz é defina por: a multiplicação de cada elemento de A por k. Observe o exemplo a seguir aplicado ao R.\nEscalar K\n\n\nCode\nk\n\n\n[1] 13\n\n\nMatriz A\n\n\nCode\nA\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\nEscalar k multiplicado pela matriz A:\n\n\nCode\n# escalar k multiplicado pela matriz A.\nk * A\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   13   78  143  208  273\n[2,]   26   91  156  221  286\n[3,]   39  104  169  234  299\n[4,]   52  117  182  247  312\n[5,]   65  130  195  260  325\n\n\nJá a multilicação de duas matrizes definidas como AxB não é tão simples. AxB é definida somente se, o número de colunas de A é igual ao número de linhas de B. Veja o exemplo a seguir, aqui assumimos que A é de tamanho mxn e B nxc, então a multiplicação é definida para reproduzir o resultado AxB.\nVeja o exemplo aplicado ao R:\nMatriz A\n\n\nCode\nA = matrix(1:15, nrow = 3, ncol = 5)\nA\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n\nMatriz B\n\n\nCode\nB = matrix(1:30, nrow = 5, ncol = 6)\nB\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    6   11   16   21   26\n[2,]    2    7   12   17   22   27\n[3,]    3    8   13   18   23   28\n[4,]    4    9   14   19   24   29\n[5,]    5   10   15   20   25   30\n\n\nA matriz A multiplicado pela matriz B usando o R, observe que o código A%*%B produz uma multiplicação de matrizes compatíveis, de acordo com a definição enterior, não é uma multiplicação padrão.\n\n\nCode\nA%*%B\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]  135  310  485  660  835 1010\n[2,]  150  350  550  750  950 1150\n[3,]  165  390  615  840 1065 1290\n\n\nAssim, o elemento da i-ésima linha e k-ésima coluna de AxB é: \\[\n\\sum{a_{ij}*b_{jk} = a_{i1}*b_{1k} + a_{i2}*b_{2k} + ...+a_{in}*b_{nk}}\n\\] Nesse caso o elemento \\(a_{11} = 135\\) na multiplicação anteior foi definido por:\n\n\nCode\nsum((A[1,]*B[,1]))\n\n\n[1] 135\n\n\nO elemento \\(a_{12} = 310\\)\n\n\nCode\nsum((A[1,]*B[,2]))\n\n\n[1] 310\n\n\nQuando as matrizes A e B são matrizes quadradas AxB está definida. Entretanto AxB é diferente de BxA. Veja o exemplo abaixo:\nMatriz quadrada A\n\n\nCode\nA = matrix(c(2,1,-1,1), nrow = 2, ncol = 2)\nA\n\n\n     [,1] [,2]\n[1,]    2   -1\n[2,]    1    1\n\n\nMatriz quadrada B\n\n\nCode\nB = matrix(c(1,0,1,1), nrow = 2, ncol = 2)\nB\n\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    0    1\n\n\nEntão AxB:\n\n\nCode\nA%*%B\n\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    1    2\n\n\ne BxA:\n\n\nCode\nB%*%A\n\n\n     [,1] [,2]\n[1,]    3    0\n[2,]    1    1"
  },
  {
    "objectID": "projetos-R/posts/algebra-matricial.html#inversão-matricial",
    "href": "projetos-R/posts/algebra-matricial.html#inversão-matricial",
    "title": "Introdução Álgebra Matricial",
    "section": "Inversão matricial",
    "text": "Inversão matricial\nA inversão matricial é análogo ao processo comum aritmético de divisão. Onde, para um escalar k, é certamente verdadeiro que \\(k*k^{-1}=1\\). Veja o exemplo abaixo apicado no R, onde temos o escalar \\(k = 978\\).\n\n\nCode\nk = matrix(978)\nk\n\n\n     [,1]\n[1,]  978\n\n\nA matriz inversa \\(k^{-1}\\) é:\n\n\nCode\nsolve(k)\n\n\n            [,1]\n[1,] 0.001022495\n\n\nEntão \\(k*k^{-1}\\) é dado por:\n\n\nCode\nk*solve(k)\n\n\n     [,1]\n[1,]    1\n\n\nDe maneira similar se A é uma matriz quadrada e \\(A*A^{-1} = I\\), em que \\(I\\) é a matriz identidade, então a matriz \\(A^{-1}\\) é a inversa de A. Veja o exemplo abaixo:\n\n\nCode\nA = matrix(c(2,1,1,2),2,2)\nA\n\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    1    2\n\n\nInversa da matriz A\n\n\nCode\nsolve(A)\n\n\n           [,1]       [,2]\n[1,]  0.6666667 -0.3333333\n[2,] -0.3333333  0.6666667\n\n\nentão, \\(A*A^{-1}\\) é:\n\n\nCode\nround(A*solve(A))\n\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\nLembre-se que, as inversas só exestem para matrizes quadradas, mas nem toda matriz quadrada possui inversa. A matriz inversa de uma matriz 2 x 2, se existe, pode ser facilmente calculada. A equação é:\n\\[\n\\begin{bmatrix}\na & b \\\\\nc & d\n\\end{bmatrix}^{-1} =\n\\begin{bmatrix}\na/\\Delta & b/\\Delta \\\\\nc/\\Delta & d/\\Delta\n\\end{bmatrix}\n\\] onde \\(\\Delta = (a*d)-(b*c)\\). Aqui o escalar \\(\\Delta\\) é chamado de determinante da matriz que está sendo invertida. Portanto, se \\(\\Delta = 0\\) a matriz inversa não é definida.\nPor isso, se o determinante é 0, então a inversa não existe, e vice-versa. Uma matriz com determinate 0 é chamada de singular.\nUma matriz com a inversa igual à transposta é dita ortogonais. Portanto, A é ortogonal se \\(A^{-1} = **A**'\\)."
  },
  {
    "objectID": "projetos-R/posts/teste-sig-multivariados.html",
    "href": "projetos-R/posts/teste-sig-multivariados.html",
    "title": "Teste de significância com dados multivariados",
    "section": "",
    "text": "Projeto em construção…\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/01mod-sistema-equa-lineares.html",
    "href": "Vida-Academica/posts/01mod-sistema-equa-lineares.html",
    "title": "Módulo 1: Sistema de equações lineares",
    "section": "",
    "text": "Módulo 1: Sistema de equações lineares\n\nSistema de sentenças\n\nUm sistema de sentenças pode ser Completo; Redundante e Contraditório\nOs sistemas completos são não singulares\n\nExemplo: {the dog is black; the bird is red; the cat is white}\n\nOs sistemas Redundantes e Contraditórios são singulares\n\nExemplo → redundante: {the dog is black; the dog is black;the dog is black} ou {the dog is black; the dog is black; the bird is red}\nExemplo → contraditório: {the dog is black; the dog is white; the bird is red}\n\n\nSistema de equações\n\nOs sistemas de equações se comportam de forma similar aos sistemas de frase.\nPodem ser singulares e não singulares.\nExemplo de um sistema de equações:\n\napple + banana + cherry = $10\napple + 2banana + cherry = $15\napple + banana + 2cherry = $12\nCom essas informações podemos determinar os preços das frutas\nO sistema de equações resultante é:\n\na + b + c = 10\na + 2b + c = 15\na + b + 2c = 12\n\n\nSistema Completo - não singular → existe uma única solução.\nSistema Contraditório - singular → não existe solução.\nSistema Redundante - singular → infinitas soluções\nLinear ⇒ a + b = 10 / 2a + 3b = 15\nNão linear ⇒ \\(a^2 + b^3 + c = 23\\)\nNum sistema linear, uma única solução, se encontra quando colocado em um gráfico, seguindo o sistema de coordenadas a solução se encontra nos pontos em comum nas duas retas.\n\nNoção geométrica de sigularidade\n\nAs constantes não importam quando estamos definindo sistemas sigulares e não sigulares. Isto é, quando pegamos um sitema de equações e usamos o 0 como constante, o sistema de nenhuma soolução passa a ter infinita soluções.\n\nMatrizes singulares e não singulares\n\nSistema 1 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ a + 2b = 0\\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 1 & 2 \\end{matrix}\\)\n\nSitema 2 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ 2a+2b=0 \\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 2 & 2 \\end{matrix}\\)\n\nAs matrizes, assim como os sitemas de equações lineares podem ser singulares e não singulares.\nMatrizes não singulares possuem uma única solução\nMatrizes singulares possuem infinitas soluções.\nPodemos descobrir se um sistema de equações é singular ou não singular, basta simplificarmos as equações ingualando as soluções a 0.\n\nDependência e independência lineares\n\nSe uma equação (linhas das matrizes) forem dependentes (podemos determinar uma linha aplicando uma operação com outras linhas) da outra ou vice-versa, temos que as equações (matrizes) são dependentes e lineares. Já o inverso indica não linearidade e independencia.\nSe a matriz for singular, as linhas são dependentes. Do contrário são independentes.\n\nDeterminantes\n\nO determinante é a forma mais fácil de determinar a singularidade das matrizes.\nSe o determinante for igual a 0 a matriz é singular (dependente), caso contrário ela é não singular (independente).\n\nA matriz \\(A ={\\begin{matrix} a & b \\\\ c & d \\end{matrix}}\\) é singular se, \\(a~b*k = c~d\\)\n\\(a*k = c\\) & \\(b*k = d\\)\n\\(\\frac{c}{d} = \\frac{d}{b} = k\\)\n\\(a*d = b*c\\)\nassim, o determinante é definido como: \\(a*d - b*c = 0\\) e a matriz é singular.\nAgora consedere a matriz B = \\(\\begin{matrix} 1 & 1 & 1 \\\\ 0 &  2 & 2 \\\\ 0 & 0 & 3 \\end{matrix}\\) o determinante é definido como:\n\n\n\nUntitled\n\n\nSe todos os elementos abaixo da diagonal principal for 0 o determinante é definido como a multiplicação dos elementos da diagonal principal.\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html",
    "href": "Vida-Academica/posts/Algebra.html",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "",
    "text": "Este artigo foi escrito em Sábado, 25 de Maio de 2024."
  },
  {
    "objectID": "Vida-Academica/posts/Cursera.html",
    "href": "Vida-Academica/posts/Cursera.html",
    "title": "Anotações do cursos feitos na plataforma Coursera",
    "section": "",
    "text": "Anotações dos cursos feitos na plataforma Coursera\nNeste arquivo estão as anotações dos cursos feitos na plataforma Coursera.\n[## Álgebra linear para aprendizado de máquina e ciência de dados(../Cursera/Algebra.qmd)\nClique aqui para acessar as anotações do curso de Álgebra linear para aprendizado de máquina e ciência de dados.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "href": "Vida-Academica/posts/Algebra.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "text": "Álgebra linear para aprendizado de máquina e ciência de dados\nLink do curso: Álgebra linear para aprendizado de máquina e ciência de dados\nO que Aprendi:\n\nRepresentar dados como vetores e matrizes e identificar suas propriedades usando conceitos de singularidade, classificação e independência linear\nAplicar operações comuns de álgebra de vetores e matrizes, como produto escalar, inverso e determinantes\nExpressar certos tipos de operações de matriz como transformação linear e aplicar conceitos de valores próprios e vetores próprios a problemas de aprendizado de máquina"
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html#módulo-1-sistema-de-equações-lineares",
    "href": "Vida-Academica/posts/Algebra.html#módulo-1-sistema-de-equações-lineares",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 1: Sistema de equações lineares",
    "text": "Módulo 1: Sistema de equações lineares\nAs matrizes são comumente usadas no aprendizado de máquina e na ciência de dados para representar dados e suas transformações. Nesta semana, aprendi como as matrizes surgem dos sistemas de equações e como certas propriedades da matriz podem ser pensadas em termos de operações no sistema de equações.\nClique aqui para acessar o material de leitura desta semana."
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html#módulo-2-vetores-e-matrizes",
    "href": "Vida-Academica/posts/Algebra.html#módulo-2-vetores-e-matrizes",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 2: Vetores e matrizes",
    "text": "Módulo 2: Vetores e matrizes\nClique aqui para acessar o material de leitura desta semana."
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html#módulo-3-transformações-lineares",
    "href": "Vida-Academica/posts/Algebra.html#módulo-3-transformações-lineares",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 3: Transformações lineares",
    "text": "Módulo 3: Transformações lineares\nClique aqui para acessar o material de leitura desta semana."
  },
  {
    "objectID": "Vida-Academica/posts/Algebra.html#módulo-4-espaços-vetoriais",
    "href": "Vida-Academica/posts/Algebra.html#módulo-4-espaços-vetoriais",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 4: Espaços vetoriais",
    "text": "Módulo 4: Espaços vetoriais\nClique aqui para acessar o material de leitura desta semana."
  },
  {
    "objectID": "Vida-Academica/posts/01-mod-algebra.html",
    "href": "Vida-Academica/posts/01-mod-algebra.html",
    "title": "Módulo 1: Sistema de equações lineares",
    "section": "",
    "text": "Módulo 1: Sistema de equações lineares\n\nSistema de sentenças\n\nUm sistema de sentenças pode ser Completo; Redundante e Contraditório\nOs sistemas completos são não singulares\n\nExemplo: {the dog is black; the bird is red; the cat is white}\n\nOs sistemas Redundantes e Contraditórios são singulares\n\nExemplo → redundante: {the dog is black; the dog is black;the dog is black} ou {the dog is black; the dog is black; the bird is red}\nExemplo → contraditório: {the dog is black; the dog is white; the bird is red}\n\n\nSistema de equações\n\nOs sistemas de equações se comportam de forma similar aos sistemas de frase.\nPodem ser singulares e não singulares.\nExemplo de um sistema de equações:\n\napple + banana + cherry = $10\napple + 2banana + cherry = $15\napple + banana + 2cherry = $12\nCom essas informações podemos determinar os preços das frutas\nO sistema de equações resultante é:\n\na + b + c = 10\na + 2b + c = 15\na + b + 2c = 12\n\n\nSistema Completo - não singular → existe uma única solução.\nSistema Contraditório - singular → não existe solução.\nSistema Redundante - singular → infinitas soluções\nLinear ⇒ a + b = 10 / 2a + 3b = 15\nNão linear ⇒ \\(a^2 + b^3 + c = 23\\)\nNum sistema linear, uma única solução, se encontra quando colocado em um gráfico, seguindo o sistema de coordenadas a solução se encontra nos pontos em comum nas duas retas.\n\nNoção geométrica de sigularidade\n\nAs constantes não importam quando estamos definindo sistemas sigulares e não sigulares. Isto é, quando pegamos um sitema de equações e usamos o 0 como constante, o sistema de nenhuma soolução passa a ter infinita soluções.\n\nMatrizes singulares e não singulares\n\nSistema 1 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ a + 2b = 0\\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 1 & 2 \\end{matrix}\\)\n\nSitema 2 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ 2a+2b=0 \\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 2 & 2 \\end{matrix}\\)\n\nAs matrizes, assim como os sitemas de equações lineares podem ser singulares e não singulares.\nMatrizes não singulares possuem uma única solução\nMatrizes singulares possuem infinitas soluções.\nPodemos descobrir se um sistema de equações é singular ou não singular, basta simplificarmos as equações ingualando as soluções a 0.\n\nDependência e independência lineares\n\nSe uma equação (linhas das matrizes) forem dependentes (podemos determinar uma linha aplicando uma operação com outras linhas) da outra ou vice-versa, temos que as equações (matrizes) são dependentes e lineares. Já o inverso indica não linearidade e independencia.\nSe a matriz for singular, as linhas são dependentes. Do contrário são independentes.\n\nDeterminantes\n\nO determinante é a forma mais fácil de determinar a singularidade das matrizes.\nSe o determinante for igual a 0 a matriz é singular (dependente), caso contrário ela é não singular (independente).\n\nA matriz \\(A ={\\begin{matrix} a & b \\\\ c & d \\end{matrix}}\\) é singular se, \\(a~b*k = c~d\\)\n\\(a*k = c\\) & \\(b*k = d\\)\n\\(\\frac{c}{d} = \\frac{d}{b} = k\\)\n\\(a*d = b*c\\)\nassim, o determinante é definido como: \\(a*d - b*c = 0\\) e a matriz é singular.\nAgora consedere a matriz B = \\(\\begin{matrix} 1 & 1 & 1 \\\\ 0 &  2 & 2 \\\\ 0 & 0 & 3 \\end{matrix}\\) o determinante é definido como:\n\n\nSe todos os elementos abaixo da diagonal principal for 0 o determinante é definido como a multiplicação dos elementos da diagonal principal.\nMódulo 2: Vetores e matrizes\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/Cursera.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "href": "Vida-Academica/posts/Cursera.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "title": "Anotações do cursos feitos na plataforma Coursera",
    "section": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "text": "Álgebra linear para aprendizado de máquina e ciência de dados"
  },
  {
    "objectID": "Vida-Academica/posts/04-mod-espacos-vetoriais.html",
    "href": "Vida-Academica/posts/04-mod-espacos-vetoriais.html",
    "title": "Portifólio de Dados",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/02-mod-vetores-matrizes.html",
    "href": "Vida-Academica/posts/02-mod-vetores-matrizes.html",
    "title": "Portifólio de Dados",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "Vida-Academica/posts/03-mod-transformacoes-lineares.html",
    "href": "Vida-Academica/posts/03-mod-transformacoes-lineares.html",
    "title": "Portifólio de Dados",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html",
    "href": "Vida-Academica/Cursera/Algebra.html",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "",
    "text": "Este artigo foi reescrito em Quarta, 21 de agosto de 2024.\nLink do curso: Álgebra linear para aprendizado de máquina e ciência de dados\nO que Aprendi:"
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "href": "Vida-Academica/Cursera/Algebra.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "text": "Álgebra linear para aprendizado de máquina e ciência de dados\nLink do curso: Álgebra linear para aprendizado de máquina e ciência de dados\nO que Aprendi:\n\nRepresentar dados como vetores e matrizes e identificar suas propriedades usando conceitos de singularidade, classificação e independência linear\nAplicar operações comuns de álgebra de vetores e matrizes, como produto escalar, inverso e determinantes\nExpressar certos tipos de operações de matriz como transformação linear e aplicar conceitos de valores próprios e vetores próprios a problemas de aprendizado de máquina"
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html#módulo-1-sistema-de-equações-lineares",
    "href": "Vida-Academica/Cursera/Algebra.html#módulo-1-sistema-de-equações-lineares",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 1: Sistema de equações lineares",
    "text": "Módulo 1: Sistema de equações lineares\n\nFormar e interpretar graficamente sistemas de equações lineares.\nDeterminar o número de soluções para um sistema de equações lineares 2x2 e 3x3\nDistinguir entre sistemas de equações singulares e não-singulares\nDeterminar a singularidade de um sistema de equações 2x2 e 3x3 calculando o determinante"
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html#módulo-2-vetores-e-matrizes",
    "href": "Vida-Academica/Cursera/Algebra.html#módulo-2-vetores-e-matrizes",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 2: Vetores e matrizes",
    "text": "Módulo 2: Vetores e matrizes\n\nResolver um sistema de equações lineares usando o método de eliminação.\nUsar uma matriz para representar um sistema de equações lineares e resolvê-lo usando a redução da linha da matriz.\nResolver um sistema de equações lineares calculando a matriz na forma de linha escalonada.\nCalcular a classificação de um sistema de equações lineares e usar a classificação para determinar o número de soluções do sistema."
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html#módulo-3-transformações-lineares",
    "href": "Vida-Academica/Cursera/Algebra.html#módulo-3-transformações-lineares",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 3: Transformações lineares",
    "text": "Módulo 3: Transformações lineares\n\nRealizar operações comuns em vetores, como soma, diferença e produto escalar.\nMultiplicar matrizes e vetores.\nRepresentar um sistema de equações lineares como uma transformação linear em um vetor.\nCalcular a inversa de uma matriz, se ela existir."
  },
  {
    "objectID": "Vida-Academica/Cursera/Algebra.html#módulo-4-espaços-vetoriais",
    "href": "Vida-Academica/Cursera/Algebra.html#módulo-4-espaços-vetoriais",
    "title": "Álgebra linear para aprendizado de máquina e ciência de dados",
    "section": "Módulo 4: Espaços vetoriais",
    "text": "Módulo 4: Espaços vetoriais\n\nInterpretar o determinante de uma matriz como uma área e calcular o determinante de uma inversa de uma matriz e um produto de matrizes.\nDeterminar as bases e a amplitude dos vetores.\nEncontrar bases próprias para um tipo especial de transformações lineares comumente usadas no aprendizado de máquina.\nCalcular os valores próprios e os vetores próprios de uma transformação linear (matriz)."
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html",
    "title": "Portifólio de Dados",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/01-mod-algebra.html",
    "href": "Vida-Academica/Cursera/01-mod-algebra.html",
    "title": "Módulo 1: Sistema de equações lineares",
    "section": "",
    "text": "Módulo 1: Sistema de equações lineares\n\nSistema de sentenças\n\nUm sistema de sentenças pode ser Completo; Redundante e Contraditório\nOs sistemas completos são não singulares\n\nExemplo: {the dog is black; the bird is red; the cat is white}\n\nOs sistemas Redundantes e Contraditórios são singulares\n\nExemplo → redundante: {the dog is black; the dog is black;the dog is black} ou {the dog is black; the dog is black; the bird is red}\nExemplo → contraditório: {the dog is black; the dog is white; the bird is red}\n\n\nSistema de equações\n\nOs sistemas de equações se comportam de forma similar aos sistemas de frase.\nPodem ser singulares e não singulares.\nExemplo de um sistema de equações:\n\napple + banana + cherry = $10\napple + 2banana + cherry = $15\napple + banana + 2cherry = $12\nCom essas informações podemos determinar os preços das frutas\nO sistema de equações resultante é:\n\na + b + c = 10\na + 2b + c = 15\na + b + 2c = 12\n\n\nSistema Completo - não singular → existe uma única solução.\nSistema Contraditório - singular → não existe solução.\nSistema Redundante - singular → infinitas soluções\nLinear ⇒ a + b = 10 / 2a + 3b = 15\nNão linear ⇒ \\(a^2 + b^3 + c = 23\\)\nNum sistema linear, uma única solução, se encontra quando colocado em um gráfico, seguindo o sistema de coordenadas a solução se encontra nos pontos em comum nas duas retas.\n\nNoção geométrica de sigularidade\n\nAs constantes não importam quando estamos definindo sistemas sigulares e não sigulares. Isto é, quando pegamos um sitema de equações e usamos o 0 como constante, o sistema de nenhuma soolução passa a ter infinita soluções.\n\nMatrizes singulares e não singulares\n\nSistema 1 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ a + 2b = 0\\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 1 & 2 \\end{matrix}\\)\n\nSitema 2 → matriz\n\n\\(\\begin{matrix} a + b = 0 \\\\ 2a+2b=0 \\end{matrix}\\) → \\(\\begin{matrix} 1 & 1 \\\\ 2 & 2 \\end{matrix}\\)\n\nAs matrizes, assim como os sitemas de equações lineares podem ser singulares e não singulares.\nMatrizes não singulares possuem uma única solução\nMatrizes singulares possuem infinitas soluções.\nPodemos descobrir se um sistema de equações é singular ou não singular, basta simplificarmos as equações ingualando as soluções a 0.\n\nDependência e independência lineares\n\nSe uma equação (linhas das matrizes) forem dependentes (podemos determinar uma linha aplicando uma operação com outras linhas) da outra ou vice-versa, temos que as equações (matrizes) são dependentes e lineares. Já o inverso indica não linearidade e independencia.\nSe a matriz for singular, as linhas são dependentes. Do contrário são independentes.\n\nDeterminantes\n\nO determinante é a forma mais fácil de determinar a singularidade das matrizes.\nSe o determinante for igual a 0 a matriz é singular (dependente), caso contrário ela é não singular (independente).\n\nA matriz \\(A ={\\begin{matrix} a & b \\\\ c & d \\end{matrix}}\\) é singular se, \\(a~b*k = c~d\\)\n\\(a*k = c\\) & \\(b*k = d\\)\n\\(\\frac{c}{d} = \\frac{d}{b} = k\\)\n\\(a*d = b*c\\)\nassim, o determinante é definido como: \\(a*d - b*c = 0\\) e a matriz é singular.\nAgora consedere a matriz B = \\(\\begin{matrix} 1 & 1 & 1 \\\\ 0 &  2 & 2 \\\\ 0 & 0 & 3 \\end{matrix}\\) o determinante é definido como:\n\n\n\n\nDeterminante\n\n\nSe todos os elementos abaixo da diagonal principal for 0 o determinante é definido como a multiplicação dos elementos da diagonal principal.\nMódulo 2: Vetores e matrizes\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/02-mod-vetores-matrizes.html",
    "href": "Vida-Academica/Cursera/02-mod-vetores-matrizes.html",
    "title": "Módulo 2: Resolução de sistemas de equações lineares",
    "section": "",
    "text": "Resolução de sistemas de equações lineares\n\nA álgebra linear é fundamental para o aprendizado de máquina, servindo como base para vários algoritmos. A eliminação gaussiana, embora não seja o método mais avançado usado hoje, é uma técnica clássica e essencial para resolver sistemas de equações lineares. Ela fornece insights valiosos sobre os princípios básicos da álgebra linear e estabelece as bases para métodos numéricos mais avançados.\n\nResolução de Sistemas Não Singulares de Equações Lineares\n\nUma das maneiras de manipular uma equação é multiplicá-la por uma constante.\n\nTambém podemos somar ou subtrair equações.\nExemplo:\n\nSuponha que temos o seguinte sistema de equações:\n\n\\[\n  \\begin{cases}\n  5a + b = 17 \\\\\n  4a - 3b = 7\n  \\end{cases}\n  \\]\n\nEliminando os coeficientes de \\(a\\), dividindo todos os coeficientes da primeira equação por 5 e da segunda por 4:\n\n\\[\n  \\begin{cases}\n  a + 0.2b = 3.4 \\\\\n  a - 0.75b = 1.75\n  \\end{cases}\n  \\]\n\nAgora, subtraindo a primeira equação da segunda:\n\n\\[\n  \\begin{matrix}\n  -0.95b = -1.65\n  \\end{matrix}\n  \\]\n\nAssim, \\(b = \\frac{-1.65}{-0.95} \\approx 1.74\\) e, substituindo em \\(a + 0.2(1.74) = 3.4\\), encontramos \\(a \\approx 3.05\\).\n\n\n\n\n\nResolução de Sistemas Singulares de Equações Lineares\n\nSistema Redundante: Suponha que temos o seguinte sistema redundante:\n\\[\n  \\begin{cases}\n  a + b = 10 \\\\\n  2a + 2b = 20\n  \\end{cases} \\Rightarrow\n  \\begin{cases}\n  a + b = 10 \\\\\n  a + b = 10\n  \\end{cases}\n  \\]\n\nSubtraindo a primeira da segunda equação:\n\n\\[\n  \\begin{cases}\n  0 = 0\n  \\end{cases}\n  \\]\n\nConcluímos que o sistema tem infinitas soluções, como \\(a = x  \\text{ e }b = 10 - x\\).\n\nSistema Contraditório: Suponha que temos o seguinte sistema contraditório:\n\\[\n  \\begin{cases}\n  a + b = 10 \\\\\n  2a + 2b = 24\n  \\end{cases} \\Rightarrow\n  \\begin{cases}\n  a + b = 10 \\\\\n  a + b = 12\n  \\end{cases}\n  \\]\n\nSubtraindo a primeira da segunda equação:\n\n\\[\n  \\begin{matrix}\n  0 = 2\n  \\end{matrix}\n  \\]\n\nIsso gera uma contradição, mostrando que o sistema não tem solução.\n\n\n\n\nResolução de Sistemas de Equações com Mais Variáveis\n\nSuponha que temos o seguinte sistema de equações:\n\\[\n  \\begin{cases}\n  a + b + 2c = 12 \\\\\n  3a - 3b - c = 3 \\\\\n  2a - b + 6c = 24\n  \\end{cases}\n  \\]\n\nDividimos cada equação pelo coeficiente de \\(a\\).\n\n\\[\n  \\begin{cases}\n  a + b + 2c = 12 \\\\\n  a - b - \\frac{1}{3}c = 1 \\\\\n  a - \\frac{1}{2}b + 3c = 12\n  \\end{cases}\n  \\]\n\nSubtraímos as equações para obter novas equações:\n\n\\[\n  \\begin{cases}\n  -2b - \\frac{7}{3}c = -11 \\\\\n  -\\frac{3}{2}b + c = 0\n  \\end{cases}\n  \\]\n\nResolvendo as equações restantes:\n\n\\[\n  \\begin{cases}\n  b = 2 \\\\\n  c = 3\n  \\end{cases}\n  \\]\n\nSubstituímos b e c na primeira equação para encontrar a = 4.\n\n\n\n\nRedução de Matrizes por Eliminação Gaussiana\n\nForma Escalonada:\n\nDado o sistema original \\(\\begin{cases} 5a+b=17 \\\\ 4a-3b=7 \\end{cases}\\), podemos simplificá-lo para a forma escalonada intermediária \\(\\begin{cases} a+0.2b=3.4 \\\\ b=2 \\end{cases}\\).\nA forma escalonada reduzida seria \\(\\begin{cases} a=3 \\\\ b=2 \\end{cases}\\).\n\nForma Matricial:\n\nA matriz original \\(\\begin{matrix} 5 & 1 \\\\ 4 & -3 \\end{matrix}\\) é reduzida para a forma escalonada \\(\\begin{matrix} 1 & 0.2 \\\\ 0 & 1 \\end{matrix}\\).\nA forma diagonal seria \\(\\begin{matrix} 1 & 0 \\\\ 0 & 1 \\end{matrix}\\).\n\n\n\n\nOperações de Linha que Preservam a Singularidade\n\nTrocar Linhas:\n\nTrocar linhas inferiores com superiores altera o sinal do determinante em matrizes não singulares.\n\nMultiplicar uma Linha por um Escalar:\n\nMultiplicar uma linha por um escalar não zero multiplica o determinante pelo mesmo escalar.\n\nAdicionar uma Linha a Outra Linha:\n\nAdicionar uma linha a outra não altera o determinante.\n\n\n\n\nSolução de Sistemas de Equações Usando Numpy.linalg\n\nInstale o Numpy:\npip install numpy\nCarregue o Numpy:\nimport numpy as np\nExemplo: Dado o sistema de equações\n\\[\n\\begin{cases}\n4x_1 - 3x_2 + x_3 = -10, \\\\\n2x_1 + x_2 + 3x_3 = 0, \\\\\n-x_1 + 2x_2 - 5x_3 = 17\n\\end{cases}\n\\]\nPodemos resolver o sistema:\nA = np.array([[4, -3, 1], [2, 1, 3], [-1, 2, -5]], dtype=np.float64)\nb = np.array([-10, 0, 17], dtype=np.float64)\nx = np.linalg.solve(A, b)\nprint(f\"Solução: {x}\")\nDeterminante:\nd = np.linalg.det(A)\nprint(f\"Determinante de A: {d:.2f}\")\nSistema sem Solução Única: Se tentarmos resolver um sistema singular:\nA_2 = np.array([[1, 1, 1], [0, 1, -3], [2, 1, 5]], dtype=np.float64)\nb_2 = np.array([2, 1, 0], dtype=np.float64)\nx_2 = np.linalg.solve(A_2, b_2)\nIsso gerará um erro devido à singularidade da matriz.\n\n\n\nClassificação (rank) de uma Matriz\n\nConsidere os sistemas de frases a seguir:\n\nDuas informações:\n\n\\[\n\\begin{cases}\n\\text{The dog is orange} \\\\\n\\text{The cat is black}\n\\end{cases}\n\\]\n\nUma informação:\n\n\\[\n\\begin{cases}\n\\text{The dog is orange} \\\\\n\\text{The dog is orange}\n\\end{cases}\n\\]\n\nNenhuma informação:\n\n\\[\n\\begin{cases}\n\\text{The dog} \\\\\n\\text{The dog}\n\\end{cases}\n\\]\nA quantidade de informações é a “classificação” (rank) do sistema. O mesmo conceito se aplica a sistemas de equações e matrizes.\n\n\n\nForma escalonada de linha\n\nMatriz original \\(\\begin{cases}\\begin{matrix} 5 & 1\\\\4&-3\\end{matrix}\\end{cases}\\) ao dividir cada uma das linhas por seu coeficiente obtemos \\(\\begin{cases}\\begin{matrix}1&0.2\\\\1&-0.75\\end{matrix}\\end{cases}\\).\nAgora só subtrairmos a primeira linha da segunda \\(\\begin{cases}\\begin{matrix} 1 & -0.75\\\\1&0.2\\\\0&-0.95\\end{matrix}\\end{cases}\\) Com isso, chegamos a matriz \\(\\begin{cases}\\begin{matrix} 1 & 0.2\\\\0&-0.95\\end{matrix}\\end{cases}\\)\nAgora que temos o 0 no canto inferior, só dividir a segunda linha pelo coeficiente diferente de 0 e chegamos a matriz escalonada: \\(\\begin{cases}\\begin{matrix} 1&0.2\\\\0&1\\end{matrix}\\end{cases}\\).\n\n\nNas matrizes singulares podemos finalizar o escalonamento de linha na segunda etapa, pois todos os coeficientes na segunda etapa vira 0.\nNas matrizes em que todos os elementos são 0, sua forma original é o seu escalonamento de linha.\nAgora, podemos conectar essa forma de escalonamento com a classificação (Rank).\n\nNa matriz singular que escalonamos anteriormente temos todos os elementos da linha igual a 1 e ela tem forma 2 x 2, portanto tem dois valores 1 na diagonal principal, ou seja, ela tem classificação (rank) igual a 2. Ou seja, a classificação (rank) de uma matriz é o número de unidades na diagonal principal de uma matriz.\n\nAssim, temos que no primeiro caso a matriz é não singular, e as outras serão singulares.\n\n\n\n\n\nForma escalonada de linha forma geral\n\ntodos os elementos abaixo da diagonal são 0.\n\ntodos os elementos de linhas abaixo do pivot são 0.\nA classificação (rank) será o número de valores do pivot.\n\n\n\n\n\nClassificação (Rank)\n\n\n\n\nForma escalonada de linha reduzida\nA matriz intermediária é conhecida como matriz escalonada e a matriz resultante da solução do sistema é denominado forma escalonada reduzida.\nForma escalonada reduzida:\n\n\n\nForma escalonada Reduzida\n\n\nForma geral:\n\n\n\nForma Geral\n\n\n\n\nO algoritmo de eliminação gaussiana\nObserve o sistema de equações a seguir:\n\\[\n\\begin{cases}\n2a-b+c=1, \\\\\n2a+2b+4c=-2, \\\\\n4a+b=-1\n\\end{cases}\n\\]\nAntes, estávamos considerando os valores constantes do lado direito das equações como 0.\nAgora precisamos considerá-los para resolver o sistema de equações.\nAssim, a matriz será:\n\\[\n\\begin{matrix}\n2&-1&1&|&1 \\\\\n2&2&4&|&-2 \\\\\n4&1&0&|&-1\n\\end{matrix}\n\\]\n\nprecisamos transformar o primeiro valor (2) em 1.\n\nAssim, teremos: \\(R_1=R_1*1/2 =&gt; \\begin{matrix} 1 & -1/2 &1/2&|&1/2\\end{matrix}\\) onde \\(R_1\\) são os valores da linha 1.\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n2&2&4&|&-2 \\\\\n4&1&0&|&-1\n\\end{matrix}\n\\]\n\nComo queremos que os valores abaixo do pivot sejam 0, precisamos fazer uma operação do tipo \\(R_2=R_2 -2*R_1 =&gt; \\begin{matrix} 0&3&3&|&-3\\end{matrix}\\)\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n0&3&3&|&-3 \\\\\n4&1&0&|&-1\n\\end{matrix}\n\\]\n\nComo queremos que os valores abaixo do pivot sejam 0, precisamos fazer uma operação do tipo \\(R_3=R_3 -4*R_1 =&gt; \\begin{matrix} 0&3&-2&|&-3\\end{matrix}\\)\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n0&3&3&|&-3 \\\\\n0&3&-2&|&-3\\end{matrix}\n\\]\n\nÓtimo, agora precisamos passar para a segunda coluna para transformar o pivot \\(R_2=1/3*R_2 =&gt; \\begin{matrix} 0&1&1&|&-1\\end{matrix}\\)\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n0&1&1&|&-1 \\\\\n0&3&-2&|&-3\\end{matrix}\n\\]\n\nComo queremos que os valores abaixo do pivot sejam 0, precisamos fazer uma operação do tipo \\(R_3=R_3 -3*R_2 =&gt; \\begin{matrix} 0&0&-5&|&0\\end{matrix}\\)\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n0&1&1&|&-1 \\\\\n0&0&-5&|&-0\\end{matrix}\n\\]\n\nÓtimo, agora precisamos passar para a segunda coluna para transformar o pivot \\(R_3=1/5*R_3 =&gt; \\begin{matrix} 0&0&1&|&0\\end{matrix}\\)\n\n\\[\n\\begin{matrix}\n1 & -1/2 &1/2&|&1/2 \\\\\n0&1&1&|&-1 \\\\\n0&0&1&|&0\\end{matrix}\n\\]\n\nobserve agora que a matriz está na forma escalonada de linhas. Ou seja, os valores da diagonal principal são 1 e os valores abaixo 0.\n\nAgora usaremos uma operação chamada de substituição reversa para resolver o sistema de equações.\n\nComeçamos na linha inferior e seguimos em direção às linhas superiores.\nUsaremos o pivot de cada linha para cancelar os valores nas células acima:\\(R_2=R_3-R_3\\) ⇒ \\(\\begin{matrix}0&1&0&|&-1\\end{matrix}\\)\nAgora para a linha 1: \\(R_1=R_1-1/2*R_3\\) ⇒ \\(\\begin{matrix} 1&-1/2&0&|&1/2\\end{matrix}\\)\nNovamente para a linha 1: \\(R_1=R_1+1/2*R_2\\) ⇒ \\(\\begin{matrix} 1&0&0&|&0\\end{matrix}\\)\nE pronto, já temos o resultado:\n\\[\n\\begin{matrix}\n1 &0&0&|&0 \\\\\n0&1&0&|&-1 \\\\\n0&0&1&|&0\\end{matrix}\n\\]\nAssim, chegamos a matriz identidade o a resolução do sistema de equações é: a = 0, b = -1 e c = 0.\n\n\nE se o sistema de equações for singular?\n\nJá sabemos que se encontrarmos uma linha da matriz igual a 0 após a redução paramos, pois concluímos que a matriz é singular, por isso, nesse caso paramos por aqui e não tem solução.\nPodemos ainda determinar se o sistema tem infinitas ou nenhuma solução. Para isso basta examinarmos a coluna de constantes.\nMatriz com infinitas soluções\n\nCaso uma das linhas for na forma: \\(0a+0b+0c=0\\)\n\nNenhuma solução:\n\nCaso uma das linhas for na forma: \\(0a+0b+0c=4\\).\n\n\n\n\n\nEliminação Gaussiana em Python\nNeste exemplo, vamos explorar a eliminação Gaussiana para resolver um sistema de equações lineares. Considere o seguinte sistema:\n\\[\n\\begin{align*}\n2x_1 + 3x_2 + 5x_3&= 12 \\\\\n-3x_1 - 2x_2 + 4x_3 &= -2 \\\\\nx_1 + x_2 - 2x_3  &= 8 \\\\\n\\end{align*}\n\\]\n\nMatriz de Coeficientes e Vetor de Constantes\nA matriz ( A ) representa os coeficientes das variáveis, enquanto o vetor coluna ( B ) representa as constantes associadas:\n\\[\nA = \\begin{bmatrix} \\phantom{-}2 & \\phantom{-}3 & \\phantom{-}5 \\\\ -3 & -2 & \\phantom{-}4 \\\\ \\phantom{-}1 & \\phantom{-}1 & -2 \\end{bmatrix}\n\\]\n\\[\nB = \\begin{bmatrix} 12 \\\\ -2 \\\\ 8 \\end{bmatrix}\n\\]\nA matriz aumentada é representada da seguinte forma:\n\\[\n\\begin{bmatrix} \\phantom{-}2 & \\phantom{-}3 & \\phantom{-}5 & \\vert & \\phantom{-}12 \\\\ -3 & -2 & \\phantom{-}4 & \\vert & -2 \\\\ \\phantom{-}1 & \\phantom{-}1 & -2 & \\vert & \\phantom{-}8 \\end{bmatrix}\n\\]\nTransformação da Matriz para a Forma Escalonada por Linhas\nPara resolver o sistema, precisamos converter a matriz aumentada em sua forma escalonada por linhas. O processo é dividido em três etapas principais:\n\nTroca de Linhas: Reorganize as linhas para posicionar a entrada não nula mais à esquerda no topo.\nEscalonamento de Linhas: Multiplique uma linha por um escalar diferente de zero para ajustar os coeficientes.\nSubstituição de Linhas: Substitua uma linha pela soma dela mesma e um múltiplo de outra linha para criar zeros abaixo da diagonal principal.\n\nSubstituição Reversa\nApós obter a forma escalonada por linhas, aplicamos a substituição reversa, começando pela última linha e subindo, para encontrar os valores das variáveis.\nCompilação do Algoritmo de Eliminação Gaussiana\nPodemos combinar todas essas operações em uma única função para executar a eliminação Gaussiana de maneira automatizada.\n\n\n\nImplementação em Python\nPrimeiro, instale as bibliotecas necessárias:\npip install numpy\npip install w2_unittest\nAgora, vamos importar as bibliotecas:\nimport numpy as np\nimport w2_unittest\n\n\nFunções Auxiliares\nFunção para Trocar Linhas:\ndef swap_rows(M, row_index_1, row_index_2):\n    \"\"\"\n    Troca as linhas em uma matriz dada.\n\n    Parâmetros:\n    - M (numpy.array): A matriz de entrada onde as trocas serão realizadas.\n    - row_index_1 (int): Índice da primeira linha a ser trocada.\n    - row_index_2 (int): Índice da segunda linha a ser trocada.\n\n    Retorno:\n    - numpy.array: A matriz com as linhas trocadas.\n    \"\"\"\n    M = M.copy()\n    M[[row_index_1, row_index_2]] = M[[row_index_2, row_index_1]]\n    return M\nExemplo de Uso:\nCriando a matriz:\nM = np.array([\n    [1, 3, 6],\n    [0, -5, 2],\n    [-4, 5, 8]\n])\nprint(M)\nTrocando a linha 0 pela linha 2:\nM_swapped = swap_rows(M, 0, 2)\nprint(M_swapped)\nFunção para Encontrar o Primeiro Valor Diferente de Zero em uma Coluna:\ndef get_index_first_non_zero_value_from_column(M, column, starting_row):\n    \"\"\"\n    Retorna o índice do primeiro valor diferente de zero em uma coluna especificada.\n\n    Parâmetros:\n    - M (numpy.array): A matriz de entrada para a busca.\n    - column (int): O índice da coluna a ser buscada.\n    - starting_row (int): O índice da linha inicial para a busca.\n\n    Retorno:\n    - int: O índice do primeiro valor diferente de zero na coluna especificada, começando da linha dada.\n           Retorna -1 se nenhum valor diferente de zero for encontrado.\n    \"\"\"\n    column_array = M[starting_row:, column]\n    for i, val in enumerate(column_array):\n        if not np.isclose(val, 0, atol=1e-5):\n            return i + starting_row\n    return -1\nVamos aplicar as funções\nN = np.array([\n[0, 5, -3 ,6 ,8],\n[0, 6, 3, 8, 1],\n[0, 0, 0, 0, 0],\n[0, 0, 0 ,0 ,7],\n[0, 2, 1, 0, 4]\n]\n)\nprint(N)\nMódulo 3: Módulo 3: Vetores e transformações lineares\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Para uma matriz não singular, a sua transformação linear envia para um paralelogramo que cobre todo o plano.\nPara as singulares, cobre um segmento de reta ou um ponto.\n\n\n\n\nO determinante de uma matriz é a área após a transformação linear.\n\n\n\n\n\\(det(AB) = det(A)det(B)\\)\n\nO produto de uma matriz singular e uma não singular, independente da ordem, será singular.\n\n\n\n\n\nO determinante de uma matriz inversa é o inverso do determinante de uma matriz.\n\n\n\nE matrizes singulares não possui inversa.\nO determinante de uma matriz identidade será sempre 1.\n\n\n\nQ1. Seja T uma transformação linear no plano representada pela seguinte matriz:\n\\(\\begin{bmatrix} 1&0\\\\2&3 \\end{bmatrix}\\)\nA classificação de T é:\nPara classificar uma transformação linear, você geralmente calcula o determinante da matriz associada. O determinante nos ajuda a entender se a transformação é invertível, e a classificação pode ser feita com base no valor do determinante.\n\n\n\nDada a matriz:\n\\(T = \\begin{pmatrix} 1 & 0 \\\\ 2 & 3 \\end{pmatrix}\\)\nO determinante de uma matriz ( 2 ), dada por:\n\\(\\text{det}(T) = ad - bc\\)\nonde a matriz ( T ) tem a forma:\n\\(T = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\)\nPara a matriz \\(T = \\begin{pmatrix} 1 & 0 \\\\ 2 & 3 \\end{pmatrix}\\), temos:\n\n( a = 1 )\n( b = 0)\n( c = 2 )\n( d = 3 )\n\nO determinante é calculado como: \\(\\text{det}(T) = (1 \\times 3) - (0 \\times 2) = 3 - 0 = 3\\)\nComo o determinante é diferente de zero, a transformação \\(( T )\\) é invertível.\n\n\n\n\nInvertível (ou não singular): Se o determinante é diferente de zero.\nNão invertível (ou singular): Se o determinante é zero.\n\nNeste caso, a transformação ( T ) é invertível.\n\n\n\nAqui está como você pode calcular o determinante em Python usando a biblioteca NumPy:\nimport numpy as np\n\n# Definindo a matriz\nT = np.array([[1, 0], [2, 3]])\n\n# Calculando o determinante\ndeterminante = np.linalg.det(T)\n\n# Exibindo o resultado\nprint(determinante)\n\n\n\nAqui está como você pode calcular o determinante em R:\n# Definindo a matriz\nT &lt;- matrix(c(1, 2, 0, 3), nrow=2, byrow=TRUE)\n\n# Calculando o determinante\ndeterminante &lt;- det(T)\n\n# Exibindo o resultado\nprint(determinante)\nEm ambos os casos, o resultado do determinante será 3, indicando que a matriz é invertível.\nQ2. Considere a transformação linear T que mapeia os vetores (1,0) e (0,1) da seguinte maneira:\n\\(T(0,1)=(2,5)\\) \\(T(1,0)=(3,1)\\)\nA área do paralelogramo abrangido pela transformação dos vetores (0,1) e (1,0) é:\nA área do paralelogramo formado pelos vetores transformados por uma transformação linear pode ser encontrada calculando o determinante da matriz que representa essa transformação. A matriz de transformação é construída a partir das imagens dos vetores básicos ( (1,0) ) e ( (0,1) ).\n\n\n\nDada a transformação:\n\\([\nT(1,0) = (3,1)\n]\\) \\([\nT(0,1) = (2,5)\n]\\)\nA matriz que representa essa transformação é:\n\\([\nT = \\begin{pmatrix} 3 & 2 \\\\ 1 & 5 \\end{pmatrix}\n]\\)\nA área do paralelogramo é dada pelo valor absoluto do determinante desta matriz.\nO determinante de uma matriz \\(( 2 \\times 2 )\\) é calculado como:\n\\([\n\\text{det}(T) = ad - bc\n]\\)\nonde:\n\\([\nT = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\n]\\)\nSubstituindo os valores da matriz ( T ):\n\\([\n\\text{det}(T) = (3 \\times 5) - (2 \\times 1) = 15 - 2 = 13\n]\\)\nPortanto, a área do paralelogramo é 13.\n\n\n\nAqui está como você pode calcular o determinante em Python usando a biblioteca NumPy:\nimport numpy as np\n\n# Definindo a matriz\nT = np.array([[3, 2], [1, 5]])\n\n# Calculando o determinante\ndeterminante = np.linalg.det(T)\n\n# Exibindo o valor absoluto do determinante (área do paralelogramo)\narea = abs(determinante)\nprint(area)\n\n\n\nAqui está como você pode calcular o determinante em R:\n# Definindo a matriz\nT &lt;- matrix(c(3, 1, 2, 5), nrow=2, byrow=TRUE)\n\n# Calculando o determinante\ndeterminante &lt;- det(T)\n\n# Exibindo o valor absoluto do determinante (área do paralelogramo)\narea &lt;- abs(determinante)\nprint(area)\nEm ambos os casos, o valor do determinante será 13, que é a área do paralelogramo formado pelos vetores transformados.\n\n\n\n\nBase sãos os vetores que formam o ponto num plano. Não é uma base se os vetores seguirem a mesma direção.\n\n\n\nGeometricamente, quando dois elementos em \\(R^2~ \\text{ou}~R^3~\\)são Linearmente Dependentes, eles estão na mesma reta, quando colocados na mesma origem.\n\nGeometricamente, quando dois elementos em \\(R^2\\) ou \\(R^3\\) são L.I., eles não estão na mesma reta, quando colocados na mesma origem.\n\nGeometricamente, se três vetores em \\(R^3\\) são linearmente dependentes, ele estão no mesmo plano, quando colocados na mesma origem, caso contrário são linearmente independentes.\n\nExemplo 1: O conjunto \\({(1, 0), (0, 1)}\\) em \\(R^2\\) é Linearmente Independente. De fato, a equação:\n\\(\\alpha1(1, 0) + \\alpha2(0, 1) = (0, 0)\\)\nsó vale para \\(\\alpha1 = \\alpha2 = 0\\). Assim, os vetores \\((1, 0)\\) e \\((0, 1)\\) são L.I.\nhttps://www.ime.unicamp.br/~marcia/AlgebraLinear/dependencia_linear.html\n\n\n\n\n\n\n\n\nSeja \\(A\\) uma matriz \\(\\text{n x n}\\). O escalar \\(\\lambda\\) é um autovalor de \\(A\\) quando há um vetor \\(x\\) não nulo tal que \\(Ax=\\lambda x\\). O vetor \\(x\\) é um autovetor de \\(A\\) associado a \\(\\lambda\\).\n\n\nPara a matriz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix}\n\\]\nVerifique que \\(x_1=(1, 0)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_1=2\\) e que \\(x_2=(0, 1)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_2= 1\\).\nSolução:\nMultiplicar \\(x_1\\) à esquerda por \\(A\\) produz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix} \\begin{bmatrix}1\\\\0\\end{bmatrix}=\\begin{bmatrix}2\\\\0\\end{bmatrix}=2\\begin{bmatrix}1\\\\0\\end{bmatrix}\n\\]\nEntão, \\(x_1 =  (1, 0)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_1= 2\\). Da mesma forma, multiplicar \\(x_2\\) à esquerda por \\(A\\) produz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix} \\begin{bmatrix}0\\\\1\\end{bmatrix}=\\begin{bmatrix}0\\\\-1\\end{bmatrix}=-1\\begin{bmatrix}0\\\\1\\end{bmatrix}\n\\]\nEntão \\(x_2 = (0,1)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_2 = -1\\)\n\n\n\n\n\n\n\n\n\n\n\n\nPara encontrar os autovalores e os autovetores de uma matriz \\(A\\) de ordem \\(n\\), seja \\(I\\) a matriz identidade \\(\\text{n x n}\\). Reescrever \\(Ax = \\lambda x\\) como \\(\\lambda Ix = Ax\\) e reorganizar fornece \\((\\lambda I-A)x=0\\). Este sistema homogêneo de equações possui soluções não nulas se e somente se a matriz dos coeficientes \\((\\lambda I - A)\\) for não invertível, ou seja, se e somente se seu determinante for zero. O próximo teorema afirma formalmente isso.\nTEOREMA: Autovalores e autovetores de uma matriz Seja A uma matriz \\(\\text{n x n}\\).\n\nUm autovalor de \\(A\\) é um escalar \\(\\lambda\\) tal que \\(det(\\lambda-A)=0\\).\nOs autovetores de \\(A\\) associados a \\(\\lambda\\) são as soluções não nulas de \\((\\lambda I - A)=0\\).\n\nEncontre os autovalores e autovetores associados de \\(A = \\begin{bmatrix} 2 & -12 \\\\ 1 & -5 \\end{bmatrix}\\)\nSolução\nO polinômio característico de \\(A\\) é\n\\[\n|\\lambda I - A| = \\begin{vmatrix} \\lambda - 2 & 12 \\\\ -1 & \\lambda + 5 \\end{vmatrix} = \\lambda^2 + 3\\lambda - 10 + 12 = (\\lambda + 1)(\\lambda + 2).\n\\]\nAssim, a equação característica é \\((\\lambda + 1)(\\lambda + 2) = 0\\), o que dá \\(\\lambda_1 = -1\\) e \\(\\lambda_2 = -2\\) como autovalores de \\(A\\). Para encontrar os autovetores associados, resolva o sistema linear homogêneo representado por \\((\\lambda I - A)x = 0\\) duas vezes: primeiro para \\(\\lambda = \\lambda_1 = -1\\) e, então, para \\(\\lambda = \\lambda_2 = -2\\). Para \\(\\lambda_1 = -1\\), a matriz dos coeficientes é\n\\[\n(-1)I - A = \\begin{bmatrix} -1 - 2 & 12 \\\\ -1 & -1 + 5 \\end{bmatrix} = \\begin{bmatrix} -3 & 12 \\\\ -1 & 4 \\end{bmatrix},\n\\]\nque se reduz por linhas a \\(\\begin{bmatrix} 1 & -4 \\\\ 0 & 0 \\end{bmatrix}\\), mostrando que \\(x_1 - 4x_2 = 0\\). Tomando \\(x_2 = t\\), você pode concluir que todo autovetor associado a \\(\\lambda_1\\) é da forma\n\\(x = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 4t \\\\ t \\end{bmatrix} = t \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix}, \\quad t \\neq 0\\).\nPara \\(\\lambda_2=-2\\), você tem\n\\((-2)I - A = \\begin{bmatrix} -2 - 2 & 12 \\\\ -1 & -2 + 5 \\end{bmatrix} = \\begin{bmatrix} -4 & 12 \\\\ -1 & 3 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 1 & -3 \\\\ 0 & 0 \\end{bmatrix}.\\)\nTomando \\(x_2 = t\\), você pode concluir que todo autovetor associado a \\(\\lambda_2\\) é da forma\n\\(x = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 3t \\\\ t \\end{bmatrix}=t\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}, \\quad t \\neq 0.\\)\n\n\n\n\nA redução de dimensionalidade consiste em reduzir o número de colunas de um dataset\nPreservar o máximo de informação possível\n\n\n\n\nReduzir dimensionalidade\nVisualização de dados mais eficientes\n\n\n\nPCA se baseia em alguns conceitos estatísticos\n\nmédia\n\n\n\nVariância\n\n\n\nCovariância\n\n\n\n\n\n\nRepresentação\n\n\nAplicação:\n\n\n\n\nPCA ⇒ Projeções, Autovalorese matriz de covariância.\nToda matriz de covariância é simétrica.\n\n\n\nImagine que temos \\(5\\) variáveis \\((x_1, x_2, x_3, x_4, x_5)\\) e queremos reduzir a apenas \\(2\\) variáveis.\n\ncriamos uma matriz \\(X\\) com o conjunto de dados.\n\n\\[\n\\begin{equation}\n\\begin{aligned}\n\\\\\n&X=\\left[\\begin{array}{cccc}\nx_{11} & x_{12} & \\ldots & x_{15} \\\\\nx_{21} & x_{22} & \\ldots & x_{25} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nx_{n 1} & x_{n 2} & \\ldots & x_{n 5}\n\\end{array}\\right]\n\\end{aligned}\n\\end{equation}\n\\]\n\ncentralizamos os dados ⇒ \\(X - \\mu\\)\n\n\\[\n\\begin{equation}\\boldsymbol{X}-\\boldsymbol{\\mu}=\\left[\\begin{array}{cccc}x_{11}-\\mu_1 & x_{12}-\\mu_2 & \\ldots & x_{15}-\\mu_5 \\\\x_{21}-\\mu_1 & x_{22}-\\mu_2 & \\ldots & x_{25}-\\mu_5 \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\x_{n 1}-\\mu_1 & x_{n 2}-\\mu_2 & \\ldots & x_{n 5}-\\mu_5\\end{array}\\right]\\end{equation}\n\\]\n\nCalculamos a matriz de covarância\n\n\\[\n\\begin{equation}C=\\frac{1}{n-1}(X-\\mu)^T(X-\\mu)=\\left[\\begin{array}{ccccc}\\operatorname{Var}\\left(X_1\\right) & \\operatorname{Cov}\\left(X_1, X_2\\right) & \\operatorname{Cov}\\left(X_1, X_3\\right) & \\operatorname{Cov}\\left(X_1, X_4\\right) & \\operatorname{Cov}\\left(X_1, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_2\\right) & \\operatorname{Var}\\left(X_2\\right) & \\operatorname{Cov}\\left(X_2, X_3\\right) & \\operatorname{Cov}\\left(X_2, X_4\\right) & \\operatorname{Cov}\\left(X_2, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_3\\right) & \\operatorname{Cov}\\left(X_2, X_3\\right) & \\operatorname{Var}\\left(X_3\\right) & \\operatorname{Cov}\\left(X_3, X_4\\right) & \\operatorname{Cov}\\left(X_3, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_4\\right) & \\operatorname{Cov}\\left(X_2, X_4\\right) & \\operatorname{Cov}\\left(X_3, X_4\\right) & \\operatorname{Var}\\left(X_4\\right) & \\operatorname{Cov}\\left(X_4, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_5\\right) & \\operatorname{Cov}\\left(X_2, X_5\\right) & \\operatorname{Cov}\\left(X_3, X_5\\right) & \\operatorname{Cov}\\left(X_4, X_5\\right) & \\operatorname{Var}\\left(X_5\\right)\\end{array}\\right]\\end{equation}\n\\]\n\nCalculamos os autovalores e autovetores da matriz de covariância e classifique-os do menor pro maior.\n\n\\[\n\\begin{equation}\\left\\lvert\\, \\begin{array}{ll}\\lambda_1 & v_1 \\\\\\lambda_2 & v_2 \\\\\\lambda_3 & v_3 \\\\\\lambda_4 & v_4 \\\\\\lambda_5 & v_5\\end{array}\\right.\\end{equation}\n\\]\n\nCriar uma matriz para projetar os dados\n\n\\[\n\\begin{equation}V = \\begin{bmatrix}\\frac{v_1}{||v_1||_2} & \\frac{v_2} {||v_2||_2}\\end{bmatrix} \\end{equation}\n\\]\n\nProjetar os dados no vetor escolhido\n\n\\[\n\\begin{equation}X_{PCA} = (X-\\mu)V\\end{equation}\n\\]\nMódulo 1: Sistema de equações lineares"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#vetores-e-suas-propriedades",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#vetores-e-suas-propriedades",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Vetores e suas propriedades",
    "text": "Vetores e suas propriedades\n\nNotação\nvetor linha: \\(x = (x_1,x_2~...~x_n)\\)\nvetor coluna: \\(x= \\begin{pmatrix}x_1\\\\x_2\\\\...\\\\x_n\\end{pmatrix}\\)\nOutras notações: \\([x_1,x_2...x_n]\\) e \\(\\begin{bmatrix}x_1\\\\x_2\\\\...\\\\x_n\\end{bmatrix}\\)\nDefinição geral: normas L1 e L2\nDado o vetor: \\(x = (x_1, x_2, ...,x_n)\\)\nL1 ⇒ \\(||x||_1=|x_1|+|x_2|+...+|x_n|\\)\nL2 ⇒ \\(||x||_2=\\sqrt{x^2_1+x^2_2+...+x^2_n}\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#operações-vetoriais",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#operações-vetoriais",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Operações vetoriais",
    "text": "Operações vetoriais\n\nSoma de vetores\nPara obter a soma de dois vetores é bem simples.\nImagine que temos os vetores \\(u=(4,1)\\) e \\(v = (1,3)\\);\nA soma dos vetores \\(u+v = (4+1,1+3)=(5,4)\\)\n\n\nSubtração de vetores\nImagine que temos os mesmos vetores \\(u=(4,1)\\) e \\(v = (1,3)\\);\nA subtração dos vetores \\(u-v = (4-1,1-3)=(3,-2)\\)\n\n\nDefinição geral: soma e subtração de vetores\nImagine que temos os vetores\n\\(x = (x_1, x_2, ...,x_n)\\) e \\(y = (y_1, y_2, ...,y_n)\\)\nA soma será feita de componente por componente \\(x + y = (x_1 + y_1, x_2+y2,...x_n+y_n)\\)\nA subtração também será feita de componente por componente \\(x - y = (x_1 - y_1, x_2-y2,...x_n-y_n)\\)\nA diferença entre dois vetores é muito importante para dizer a que distância dois vetores estão um do outro.\nNo exemplo anterior tínhamos os vetores \\(u=(4,1)\\) e \\(v = (1,3)\\);\nA distância entre eles pode ser definida (Distância L1) como: \\(|u-v|=|5|+|-3| = 8\\). Podemos usar L2 também.\n\n\nMultiplicação de um vetor por um escalar\nImagine que temos o vetor \\(u = (1,2)\\) e o escalar \\(\\lambda = 3\\) a multiplicação será \\(\\lambda u = (3,6)\\)\n\n\nDefinição geral: multiplicação por um escalar\nImagine o escalar a seguir: \\(x = (x_1, x_2, ...,x_n)\\) e o escalar \\(\\lambda\\), a multiplicação será; \\(\\lambda x = ( \\lambda  x_1,\\lambda  x_2, ..., \\lambda  x_n)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#o-produto-escalar",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#o-produto-escalar",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "O produto escalar",
    "text": "O produto escalar\nA norma L2 será sempre a raiz quadrada do produto escalar de um vetor.\nImagine um vetor, \\((4,3)\\). O produto escalar será: \\([4~~3] \\begin{bmatrix}4\\\\3\\end{bmatrix}\\) = 25. Nesse caso, a distância entre os vetores é o mesmo que usar a norma \\(L2\\).\n\\(\\text{Norma L2} =\\sqrt{4^2+3^2} = \\sqrt{25}= 5\\)\nNotação: \\(|u|_2 = \\sqrt{\\langle u,u \\rangle}\\)\nAlém disso, a distância com relação a norma euclidiana, definida por:\n\\(d(u,v) = \\left\\| u-v \\right\\|_2 =\n\\sqrt{(u_1 - v_1)^2 + (u_2 - v_2)^2 + ... + (u_n -\nv_n)^2}\\)\n\nTransposta de um vetor:\n\\[\n\\begin{bmatrix}2\\\\4\\\\1\\end{bmatrix}^T = [2~~4~~1]\n\\]\n\\[\n[2~~4~~1]^T=\\begin{bmatrix}2\\\\4\\\\1\\end{bmatrix}\n\\]\n\n\nTransposta de uma matriz:\n\\[\n\\begin{bmatrix}2&5\\\\4&7\\\\1&3\\end{bmatrix}^T = \\begin{bmatrix}2&4&1\\\\5&7&3\\end{bmatrix}\n\\]\n\n\nProduto escalar: definição geral\nImagine os vetores \\(x = (x_1, x_2, ...,x_n)\\) e \\(y = (y_1, y_2, ...,y_n)\\)\nO produto escalar será:\n\\[\nx\\cdot y = (x_1 \\cdot y_1) + (x_2 \\cdot y_2) + ... + (x_n \\cdot y_n)\n\\]\nOutras definições: \\(\\langle x,y \\rangle\\)\n\\[\nx \\cdot y^T = (x_1~~x_2~~...~~x_n) \\cdot \\begin{pmatrix}y_1\\\\y_2\\\\\\vdots\\\\y_n \\end{pmatrix}\n\\]"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#produto-de-pontos-geométricos",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#produto-de-pontos-geométricos",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Produto de pontos geométricos",
    "text": "Produto de pontos geométricos"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-uma-matriz-por-um-vetor",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-uma-matriz-por-um-vetor",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Multiplicação de uma matriz por um vetor",
    "text": "Multiplicação de uma matriz por um vetor\n\nEquações lineares em forma de produto escalar\nObserve as equações:\n\\(a+b+c=10~~(1)\\); \\(a+2b+c=15~~(2)\\); \\(a+b+2c=12~~(3)\\)\nElas podem ser representadas como\n\\([1~~1~~1]\\cdot \\begin{bmatrix}a\\\\b\\\\c\\end{bmatrix}=10~~(1);\\) \\([1~~2~~1]\\cdot \\begin{bmatrix}a\\\\b\\\\c\\end{bmatrix}=15~~(2);\\) \\([1~~1~~2]\\cdot \\begin{bmatrix}a\\\\b\\\\c\\end{bmatrix}=12~~(3)\\)\nPodemos pegar esses três produtos escalares e transformá-los em uma matriz, pois o vetor coluna é o mesmo nos três produtos escalares, assim, teríamos:\n\\[\n\\begin{bmatrix}1&1&1\\\\1&2&1\\\\1&1&2\\end{bmatrix}\\cdot \\begin{bmatrix} a\\\\b\\\\c\\end{bmatrix}=\\begin{bmatrix} 10\\\\15\\\\12\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#operações-vetoriais-multiplicação-escalar-soma-e-produto-escalar-de-vetores-usando-python",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#operações-vetoriais-multiplicação-escalar-soma-e-produto-escalar-de-vetores-usando-python",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Operações vetoriais: Multiplicação escalar, soma e produto escalar de vetores usando Python",
    "text": "Operações vetoriais: Multiplicação escalar, soma e produto escalar de vetores usando Python\n# vamos carregar o numpy\nimport numpy as np\n\nMultiplicação escalar e soma de vetores\nComo sabemos, podemos representar os vetores em formato de setas\n# Visualizando o vetor em seta\nimport matplotlib.pyplot as plt\n\ndef plot_vectors(list_v, list_label, list_color):\n    _, ax = plt.subplots(figsize=(10, 10))\n    ax.tick_params(axis='x', labelsize=14)\n    ax.tick_params(axis='y', labelsize=14)\n    ax.set_xticks(np.arange(-10, 10))\n    ax.set_yticks(np.arange(-10, 10))\n    \n    \n    plt.axis([-10, 10, -10, 10])\n    for i, v in enumerate(list_v):\n        sgn = 0.4 * np.array([[1] if i==0 else [i] for i in np.sign(v)])\n        plt.quiver(v[0], v[1], color=list_color[i], angles='xy', scale_units='xy', scale=1)\n        ax.text(v[0]-0.2+sgn[0], v[1]-0.2+sgn[1], list_label[i], fontsize=14, color=list_color[i])\n\n    plt.grid()\n    plt.gca().set_aspect(\"equal\")\n    plt.show()\n\nv = np.array([[1],[3]])\n# Arguments: list of vectors as NumPy arrays, labels, colors.\nplot_vectors([v], [f\"$v$\"], [\"black\"])\nO vetor é definido por sua norma (comprimento, magnitude) e direção, e não por sua posição real.\n\n\nMultiplicação por um escalar\nSe o escalar for positivo ao multiplicar pelo vetor ele terá a mesma direção, caso contrário será na posição oposta.\nplot_vectors([v, 2*v, -2*v], [f\"$v$\", f\"$2v$\", f\"$-2v$\"], [\"black\", \"green\", \"blue\"])\n\n\nSoma de vetores\nA soma de dois vetores corresponde a diagonal partindo do mesmo ponto, segundo a chamada lei do paralelogramo.\nv = np.array([[1],[3]])\nw = np.array([[4],[-1]])\n\nplot_vectors([v, w, v + w], [f\"$v$\", f\"$w$\", f\"$v + w$\"], [\"black\", \"black\", \"red\"])\n# plot_vectors([v, w, np.add(v, w)], [f\"$v$\", f\"$w$\", f\"$v + w$\"], [\"black\", \"black\", \"red\"])\n\n\nNormas de um vetor\nA norma de um vetor pode ser definida como um número não negativo que descreve a extensão do vetor no espaço.\nprint(\"Norm of a vector v is\", np.linalg.norm(v))\n\n\nProduto escalar\nO produto escalar é a operação algébrica entre dois vetores \\(\\vec x=[x_1~~x_2~~...~~x_n]^T \\in R^n\\) e \\(\\vec x=[y_1~~y_2~~...~~y_n]^T \\in R^n\\) em que retorna um único valor. O produto escalar pode ser representado por \\(x \\cdot y\\) e é definido como:\n\\[\nx \\cdot y = \\sum^n_{i=1} = x_1y_1+x_2y_2+...+x_ny_n\n\\]\n\n\nProduto escalar usando Python\n# basta definir os vetore\nx = [1, -2, -5]\ny = [4, 3, -1]\n\n# define a função que calcula o produto escalar\ndef dot(x, y):\n        s=0\n        for xi, yi in zip(x, y):\n                s += xi * yi\n        return s\n\nprint(\"O produto escalar entre x e y é\", dot(x, y))\n\nprint(\"np.dot(x,y) pode ser usada para calcular o produto escalar entre x e y:\", np.dot(x, y))"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#definição-de-transformação-linear",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#definição-de-transformação-linear",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Definição de transformação linear",
    "text": "Definição de transformação linear\nSejam \\(V\\) e \\(W\\) **espaços vetoriais. A função \\(T: V \\to W\\)\né a transformação linear de \\(V\\) em \\(W\\) quando as duas propriedades abaixo são verdadeiras para quaisquer u e v em \\(V\\) e para qualquer escalar c.\n\n\\(T(u + v) = T(u) + (v)\\)\n\\(T(cu)=cT(u)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#propriedades-das-transformações-lineares",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#propriedades-das-transformações-lineares",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Propriedades das transformações lineares",
    "text": "Propriedades das transformações lineares\nSeja T uma transformação linear de V em W e sejam u e v em V. Então as propriedades listadas abaixo são verdadeiras.\n\n\\(T(0)=0\\)\n\\(T(-v) = -T(v)\\)\n\\(T(u-v)=T(u)-T(v)\\)\nSe \\(v = c_1v_1+c_2v_2+...+c_nv_n\\) então \\(T(v) = T(c_1v_1+c_2v_2+...+c_nv_n)=c_1T(v_1)+c_2T(v_2)+...+c_nT(v_n)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#matrizes-dada-por-transformações-lineares",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#matrizes-dada-por-transformações-lineares",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Matrizes dada por transformações lineares",
    "text": "Matrizes dada por transformações lineares\nSeja a matriz \\(\\begin{bmatrix}3&1\\\\1&2\\end{bmatrix}\\) a transformação da matriz linear no ponto (0, 0) será definida por \\(\\begin{bmatrix}3*0 + 1*0\\\\1*0+2*0\\end{bmatrix} = \\begin{bmatrix}0\\\\0\\end{bmatrix}\\)\nNo ponto \\((1, 1) = \\begin{bmatrix}3*1 + 1*1\\\\1*1+2*1\\end{bmatrix} = \\begin{bmatrix}4\\\\3\\end{bmatrix}\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformação-linear-dada-por-uma-matriz",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformação-linear-dada-por-uma-matriz",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Transformação linear dada por uma matriz",
    "text": "Transformação linear dada por uma matriz"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-matrizes",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-matrizes",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Multiplicação de matrizes",
    "text": "Multiplicação de matrizes\n\nDefinição\nSe \\(A = [a{ij}]\\) é uma matriz \\(\\text{m x n}\\) e \\(B = [b_{ij}]\\) é uma matriz \\(\\text{ n x p}\\), então o produto \\(AB\\) é uma matriz \\(\\text{m x p}\\)\n\\(AB = [c_{ij}]\\)\nonde\n\\(c_{ij} = \\sum\\limits^n_{k=1} a_{ik}b_{kj} = a_{i1}b_{1j}+a_{i2}b_{2j}+a_{i3}b_{3j}+...+a_{in}b_{nj}\\)\nEsta definição significa que, para encontrar o elemento na \\(i-ésima\\) linha e na \\(j-ésima\\) coluna do produto \\(AB\\), basta multiplicar os elementos na \\(i-ésima\\) linha de \\(A\\) pelos elementos correspondentes na \\(j-ésima\\) coluna de \\(B\\) e em seguida somar os resultados."
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#matriz-identidade",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#matriz-identidade",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Matriz identidade",
    "text": "Matriz identidade\nA matriz identidade é a matriz que, quando multiplicada por qualquer outra matriz, dá a mesma matriz, e sua transformação linear correspondente é muito simples."
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#inversa-de-uma-matriz",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#inversa-de-uma-matriz",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Inversa de uma matriz",
    "text": "Inversa de uma matriz\n\nDefinição da inversa de uma matriz\nUma matriz quadrada \\(A\\) de ordem \\(n\\) é invertível (ou não singular) quando existe uma matriz \\(B\\) de tamanho \\(\\text{n x n}\\) tal que\n\\(AB = BA = I_n\\),\nonde \\(I_n\\) é a matriz identidade de ordem \\(n\\). A matriz \\(B\\) é a inversa multiplicativa) de \\(A\\). Uma matriz que não possui uma inversa é não invertível (ou singular).\nAs matrizes não quadradas não têm inversas.\nExemplo:\nEncontre a inversa da matriz \\(A=\\begin{bmatrix}1&4\\\\-1&-3\\end{bmatrix}\\)\nSOLUÇÃO:\nPara encontrar a inversa de \\(A\\), resolva a equação matricial \\(AX = I\\) para determinar \\(X\\).\n\\(\\begin{bmatrix}1&4\\\\-1&-3\\end{bmatrix} \\begin{bmatrix}x_{11}&x_{12}\\\\x_{21}&x_{22}\\end{bmatrix} =\\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}\\)\n\\(\\begin{bmatrix}x_{11}+4x_{21}&x_{12}+4x_{22}\\\\-x_{11}-3x_{21}&-x_{12}-3x_{22}\\end{bmatrix} = \\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}\\)\nIgualando os elementos correspondentes, você obtém dois sistemas de equações lineares.\n\\(\\begin{cases}x_{11} + 4x_{21} = 1 \\\\ -x_{11}-3x_{21}=0 \\end{cases}\\)\n\\(\\begin{cases}x_{12} + 4x_{22} = 0 \\\\ -x_{12}-3x_{22}=1 \\end{cases}\\)\nResolvendo o primeiro sistema, você encontra que \\(x_{11}=-3\\) e \\(x_{21}  = 1\\). De forma semelhante, resolvendo o segundo sistema, encontra que \\(x_{12} = 4\\) e \\(x_{22}=  1\\). Então, a inversa de \\(A\\) é\n\\(A = A^{-1}=\\begin{bmatrix}-3&-4\\\\1&1\\end{bmatrix}\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#quais-matrizes-têm-uma-inversa",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#quais-matrizes-têm-uma-inversa",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Quais matrizes têm uma inversa?",
    "text": "Quais matrizes têm uma inversa?\n\nPropriedades de matrizes inversas\nSe \\(A\\) é uma matriz invertível, \\(k\\) é um número inteiro positivo e \\(c\\) é um escalar diferente de zero, então \\(A^{-1}\\), \\(A^k\\), \\(cA\\) e \\(AT\\) são invertíveis e as afirmações abaixo são verdadeiras.\n\n\\((A^{-1})^{-1} = A\\)\n\\((A^k)^{-1}=\\underbrace{A^{-1}A^{-1}…A^{-1}}_{\\text{k fatores}}=(A^{-1})^k\\)\n\\((cA)^{-1}=\\frac{1}{c}A^{-1}\\)\n\\((A^T)^{-1}=(A^{-1})^T\\)\n\nMatriz singular não tem inversa. Determinante = 0"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-matrizes-usando-numpy",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#multiplicação-de-matrizes-usando-numpy",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Multiplicação de matrizes usando Numpy",
    "text": "Multiplicação de matrizes usando Numpy\nimport numpy as np\nDefinição:\nSe \\(A\\) é uma matriz \\(\\text{m x n }\\) e \\(B\\) é uma matriz \\(\\text{n x p}\\) a matriz \\(C\\) será o produto \\(C = AB\\). É definida sendo uma matriz \\(\\text{m x p}\\) em que:\n\\(c_{ij} = a_{ij}b_{ij}+a_{i2}b_{2j}+…+a_{in}b_{nj} = \\sum\\limits^n_{k=1}a_{ik}b_{kj}\\)\nOnde \\(a_{ik}\\) são os elemento da matriz \\(A\\), \\(b_{kj}\\) são os elementos da matriz \\(B\\), e \\(i = 1\\), \\(\\ldots, m, k=1, \\ldots, n, j = 1, \\ldots, p\\). Em outras palavras, \\(c_{ij}\\) é o produto escalar \\(i-th\\) linha de A e o \\(j-th\\) é a coluna de \\(B\\).\nA multiplicação de matrizes usando numpy é mais eficiente quando usamos a forma vetorizada.\n\nAgora vamos definir duas mabtrizes\n\nA = np.array([[4, 9, 9], [9, 1, 6], [9, 2, 3]])\nprint(\"Matrix A (3 by 3):\\n\", A)\n\nB = np.array([[2, 2], [5, 7], [4, 4]])\nprint(\"Matrix B (3 by 2):\\n\", B)\n\nPara multiplicar as duas matrizes usamos\n\nnp.matmul(A, B)\n\npodemos obter o mesmo resultado utilizando a seguinte operação no python base.\n\nA @ B\nMatematicamente, a multiplicação de matrizes é possível somente se;\nO número de colunas da matriz A for igual o número de linhas de B.\nPodemos checar essas informações com:\ntry:\n    np.matmul(B, A)\nexcept ValueError as err:\n    print(err)\nTambém usando:\ntry:\n    B @ A\nexcept ValueError as err:\n    print(err)\nPodemos checar as dimensões das matrizes assim, veja o exemplo abaixo:\nx = np.array([1, -2, -5])\ny = np.array([4, 3, -1])\n\nprint(\"Shape of vector x:\", x.shape)\nprint(\"Number of dimensions of vector x:\", x.ndim)\nprint(\"Shape of vector x, reshaped to a matrix:\", x.reshape((3, 1)).shape)\nprint(\"Number of dimensions of vector x, reshaped to a matrix:\", x.reshape((3, 1)).ndim)\n\nnp.matmul(x,y)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformações-lineares-usando-python",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformações-lineares-usando-python",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Transformações lineares usando Python",
    "text": "Transformações lineares usando Python\nVamos precisar dos pacotes\nimport numpy as np\n# OpenCV library for image transformations.\nimport cv2\nUma transformação é uma função que vai de um espaço vetorial a outro, respeitando a estrutura (linear) subjacente de cada espaço vetorial. Ao se referir a uma transformação específica, você pode usar um símbolo, como \\(T\\). Especificando os espaços que contêm os vetores de entrada e saída, por exemplo, \\(\\mathbb{R}^2\\) e \\(\\mathbb{R}^3\\), você pode escrever \\(T: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^3\\). Ao transformar o vetor \\(v \\in \\mathbb{R}^2\\) no vetor \\(w\\in\\mathbb{R}^3\\) pela transformação \\(T\\), você pode usar a notação \\(T(v)=w\\) e lê-la como “T de v é igual a w” ou “o vetor w é uma imagem do vetor v pela transformação T”.\nA seguinte função em Python corresponde à transformação \\(T: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^3\\) com a fórmula simbólica abaixo:\n\\[\nT\\begin{pmatrix}\n\\begin{bmatrix}\nv_1 \\\\v_2\n\\end{bmatrix}\\end{pmatrix}=\n\\begin{bmatrix}\n3v_1 \\\\\n0 \\\\\n-2v_2\n\\end{bmatrix}\n\\tag{1}\n\\]\ndef T(v):\n    w = np.zeros((3,1))\n    w[0,0] = 3*v[0,0]\n    w[2,0] = -2*v[1,0]\n    \n    return w\n\nv = np.array([[3], [5]])\nw = T(v)\n\nprint(\"Original vector:\\n\", v, \"\\n\\n Result of the transformation:\\n\", w)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformações-lineares-1",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#transformações-lineares-1",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Transformações Lineares",
    "text": "Transformações Lineares\nUma transformação \\(T\\) é dita linear se as seguintes duas propriedades forem verdadeiras para qualquer escalar \\(k\\) e quaisquer vetores de entrada \\(u\\) e \\(v\\):\n\n\\(T(kv)=kT(v)\\),\n\\(T(u+v)=T(u)+T(v)\\).\n\nNo exemplo acima, \\(T\\) é uma transformação linear:\n\\[\nT(kv) =\nT \\begin{pmatrix}\\begin{bmatrix}\nkv_1 \\\\\nkv_2\n\\end{bmatrix}\\end{pmatrix} =\n\\begin{bmatrix}\n3kv_1 \\\\\n0 \\\\\n-2kv_2\n\\end{bmatrix} =\nk\\begin{bmatrix}\n3v_1 \\\\\n0 \\\\\n-2v_2\n\\end{bmatrix} =\nkT(v),\\tag{2}\n\\]\n\\[\nT (u+v) =\nT \\begin{pmatrix}\\begin{bmatrix}\nu_1 + v_1 \\\\\nu_2 + v_2\n\\end{bmatrix}\\end{pmatrix} =\n\\begin{bmatrix}\n3(u_1+v_1) \\\\\n0 \\\\\n-2(u_2+v_2)\n\\end{bmatrix} =\n\\begin{bmatrix}\n3u_1 \\\\\n0 \\\\\n-2u_2\n\\end{bmatrix} +\n\\begin{bmatrix}\n3v_1 \\\\\n0 \\\\\n-2v_2\n\\end{bmatrix} =\nT(u)+T(v).\\tag{3}\n\\]\nVocê pode alterar os valores de \\(k\\) ou dos vetores \\(u\\) e \\(v\\) na célula abaixo para verificar que isso é verdadeiro para alguns valores específicos.\nu = np.array([[1], [-2]])\nv = np.array([[2], [4]])\n\nk = 7\n\nprint(\"T(k*v):\\n\", T(k*v), \"\\n k*T(v):\\n\", k*T(v), \"\\n\\n\")\nprint(\"T(u+v):\\n\", T(u+v), \"\\n T(u)+T(v):\\n\", T(u)+T(v))\n\nA multiplicação de matrizes geralmente não é comutativa\nOs exemplos a seguir ilustram que a multiplicação de matrizes geralmente não é comutativa.\nPor exemplo, o produto \\(AB\\) de uma matriz \\(2 \\times 3\\) com uma matriz \\(3 \\times 4\\) resulta em uma matriz \\(2 \\times 4\\), mas o produto \\(BA\\) de uma matriz \\(3 \\times 4\\) com uma matriz \\(2 \\times 3\\) não é definido.\nMesmo para duas matrizes quadradas \\(M\\) e \\(N\\), ambas de tamanho \\(n \\times n\\), a multiplicação de matrizes não é necessariamente comutativa: os produtos \\(MN\\) e \\(NM\\) podem ser diferentes.\nPor exemplo, seja\n\\(M = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}, \\quad\nN = \\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix},\\)\nde modo que\n\\(MN = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix} = \\begin{bmatrix} 1 & 1 \\\\ -1 & 0 \\end{bmatrix},\\)\ne\n\\(NM = \\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix} \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & -1 \\end{bmatrix}.\\)\nAssim, as matrizes quadradas \\(M\\) e \\(N\\) não comutam: \\(MN \\neq NM.\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#redes-neurais",
    "href": "Vida-Academica/Cursera/03-mod-transformacoes-lineares.html#redes-neurais",
    "title": "Módulo 3: Vetores e transformações lineares",
    "section": "Redes Neurais",
    "text": "Redes Neurais\n\nRegressão Linear\nRegressão linear é uma abordagem linear para modelar a relação entre uma resposta escalar (variável dependente) e uma ou mais variáveis explicativas (variáveis independentes).\nO modelo de regressão linear com duas variáveis independentes \\(x_1\\), \\(x_2\\) pode ser escrito como\n\\(\\hat{y} = w_1x_1 + w_2x_2 + b = Wx + b\\)\nonde \\(Wx\\) é o produto escalar do vetor de entrada \\(x = \\begin{bmatrix} x_1 & x_2\\end{bmatrix}\\) e o vetor de parâmetros \\(W = \\begin{bmatrix} w_1 & w_2\\end{bmatrix}\\), e o parâmetro escalar \\(b\\) é o intercepto.\nO objetivo é o mesmo - encontrar os parâmetros “ideais” \\(w_1\\), \\(w_2\\) e \\(b\\) de modo que as diferenças entre os valores originais \\(y_i\\) e os valores previstos \\(\\hat{y}_i\\) sejam mínimas.\nPodemos usar um modelo de rede neural para fazer isso. A multiplicação de matrizes estará no cerne do modelo!\n\n\nModelo de Rede Neural com um Único Perceptron e Dois Nós de Entrada\nNovamente, usaremos apenas um perceptron, mas com dois nós de entrada, conforme mostrado no esquema a seguir:\n\nO cálculo da saída do perceptron para um exemplo de treinamento \\(x = \\begin{bmatrix} x_1 & x_2\\end{bmatrix}\\) pode ser escrito com o produto escalar:\n\\(z = w_1x_1 + w_2x_2 + b = Wx + b\\)\nonde os pesos estão no vetor \\(W = \\begin{bmatrix} w_1 & w_2\\end{bmatrix}\\) e o viés \\(b\\) é um escalar. A camada de saída terá o mesmo único nó \\(\\hat{y} = z\\).\nOrganize todos os exemplos de treinamento em uma matriz \\(X\\) com forma (\\(2 \\times m\\)), colocando \\(x_1\\) e \\(x_2\\) em colunas. Então, a multiplicação de matrizes de \\(W\\) (\\(1 \\times 2\\)) e \\(X\\) (\\(2 \\times m\\)) resultará em um vetor (\\(1 \\times m\\))\n\\[\nWX =\n\\begin{bmatrix} w_1 & w_2\\end{bmatrix}\n\\begin{bmatrix}\nx_1^{(1)} & x_1^{(2)} & \\dots & x_1^{(m)} \\\\\nx_2^{(1)} & x_2^{(2)} & \\dots & x_2^{(m)} \\\\ \\end{bmatrix}\n= \\begin{bmatrix}\nw_1x_1^{(1)} + w_2x_2^{(1)} &\nw_1x_1^{(2)} + w_2x_2^{(2)} & \\dots &\nw_1x_1^{(m)} + w_2x_2^{(m)}\\end{bmatrix}\n\\]\nE o modelo pode ser escrito como\n\\[\n\\begin{align}\nZ &= W X + b,\\\\\n\\hat{Y} &= Z,\n\\tag{8}\\end{align}\n\\]\nonde \\(b\\) é transmitido para o vetor de tamanho (\\(1 \\times m\\)). Esses são os cálculos a serem realizados na etapa de propagação para frente.\nAgora, você pode comparar o vetor resultante das previsões \\(\\hat{Y}\\) (\\(1 \\times m\\)) com o vetor original de dados \\(Y\\). Isso pode ser feito com a chamada função de custo, que mede quão próximo seu vetor de previsões está dos dados de treinamento. Ela avalia o quão bem os parâmetros \\(w\\) e \\(b\\) funcionam para resolver o problema. Existem muitas funções de custo diferentes disponíveis, dependendo da natureza do seu problema. Para sua rede neural simples, você pode calculá-la como:\n\\[\n\\mathcal{L}\\left(w, b\\right)  = \\frac{1}{2m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)^2.\\tag{5}\n\\]\nO objetivo é minimizar a função de custo durante o treinamento, o que minimizará as diferenças entre os valores originais \\(y_i\\) e os valores previstos \\(\\hat{y}_i\\) (a divisão por \\(2m\\) é feita apenas para fins de escala).\nQuando seus pesos foram apenas inicializados com alguns valores aleatórios e nenhum treinamento foi realizado ainda, não se pode esperar bons resultados.\nO próximo passo é ajustar os pesos e o viés para minimizar a função de custo. Este processo é chamado de propagação para trás e é feito de forma iterativa: você atualiza os parâmetros com uma pequena mudança e repete o processo.\nNota: A propagação para trás não é abordada neste curso - ela será discutida no próximo curso desta especialização.\nA metodologia geral para construir uma rede neural é:\n\nDefinir a estrutura da rede neural (número de unidades de entrada, número de unidades ocultas, etc.).\nInicializar os parâmetros do modelo.\nLoop:\n\nImplementar a propagação para frente (calcular a saída do perceptron),\nImplementar a propagação para trás (para obter as correções necessárias nos parâmetros),\nAtualizar os parâmetros.\n\nFazer previsões.\n\nMódulo 4: Determinantes e Autovetores"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#singularidade-e-classificação-de-transformações-lineares",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#singularidade-e-classificação-de-transformações-lineares",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Para uma matriz não singular, a sua transformação linear envia para um paralelogramo que cobre todo o plano.\nPara as singulares, cobre um segmento de reta ou um ponto."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinante-de-uma-matriz-como-área",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinante-de-uma-matriz-como-área",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "O determinante de uma matriz é a área após a transformação linear."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinante-de-um-produto",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinante-de-um-produto",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "\\(det(AB) = det(A)det(B)\\)\n\nO produto de uma matriz singular e uma não singular, independente da ordem, será singular."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinantes-de-inversos",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#determinantes-de-inversos",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "O determinante de uma matriz inversa é o inverso do determinante de uma matriz.\n\n\n\nE matrizes singulares não possui inversa.\nO determinante de uma matriz identidade será sempre 1.\n\n\n\nQ1. Seja T uma transformação linear no plano representada pela seguinte matriz:\n\\(\\begin{bmatrix} 1&0\\\\2&3 \\end{bmatrix}\\)\nA classificação de T é:\nPara classificar uma transformação linear, você geralmente calcula o determinante da matriz associada. O determinante nos ajuda a entender se a transformação é invertível, e a classificação pode ser feita com base no valor do determinante.\n\n\n\nDada a matriz:\n\\(T = \\begin{pmatrix} 1 & 0 \\\\ 2 & 3 \\end{pmatrix}\\)\nO determinante de uma matriz ( 2 ), dada por:\n\\(\\text{det}(T) = ad - bc\\)\nonde a matriz ( T ) tem a forma:\n\\(T = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\)\nPara a matriz \\(T = \\begin{pmatrix} 1 & 0 \\\\ 2 & 3 \\end{pmatrix}\\), temos:\n\n( a = 1 )\n( b = 0)\n( c = 2 )\n( d = 3 )\n\nO determinante é calculado como: \\(\\text{det}(T) = (1 \\times 3) - (0 \\times 2) = 3 - 0 = 3\\)\nComo o determinante é diferente de zero, a transformação \\(( T )\\) é invertível.\n\n\n\n\nInvertível (ou não singular): Se o determinante é diferente de zero.\nNão invertível (ou singular): Se o determinante é zero.\n\nNeste caso, a transformação ( T ) é invertível.\n\n\n\nAqui está como você pode calcular o determinante em Python usando a biblioteca NumPy:\nimport numpy as np\n\n# Definindo a matriz\nT = np.array([[1, 0], [2, 3]])\n\n# Calculando o determinante\ndeterminante = np.linalg.det(T)\n\n# Exibindo o resultado\nprint(determinante)\n\n\n\nAqui está como você pode calcular o determinante em R:\n# Definindo a matriz\nT &lt;- matrix(c(1, 2, 0, 3), nrow=2, byrow=TRUE)\n\n# Calculando o determinante\ndeterminante &lt;- det(T)\n\n# Exibindo o resultado\nprint(determinante)\nEm ambos os casos, o resultado do determinante será 3, indicando que a matriz é invertível.\nQ2. Considere a transformação linear T que mapeia os vetores (1,0) e (0,1) da seguinte maneira:\n\\(T(0,1)=(2,5)\\) \\(T(1,0)=(3,1)\\)\nA área do paralelogramo abrangido pela transformação dos vetores (0,1) e (1,0) é:\nA área do paralelogramo formado pelos vetores transformados por uma transformação linear pode ser encontrada calculando o determinante da matriz que representa essa transformação. A matriz de transformação é construída a partir das imagens dos vetores básicos ( (1,0) ) e ( (0,1) ).\n\n\n\nDada a transformação:\n\\([\nT(1,0) = (3,1)\n]\\) \\([\nT(0,1) = (2,5)\n]\\)\nA matriz que representa essa transformação é:\n\\([\nT = \\begin{pmatrix} 3 & 2 \\\\ 1 & 5 \\end{pmatrix}\n]\\)\nA área do paralelogramo é dada pelo valor absoluto do determinante desta matriz.\nO determinante de uma matriz \\(( 2 \\times 2 )\\) é calculado como:\n\\([\n\\text{det}(T) = ad - bc\n]\\)\nonde:\n\\([\nT = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\n]\\)\nSubstituindo os valores da matriz ( T ):\n\\([\n\\text{det}(T) = (3 \\times 5) - (2 \\times 1) = 15 - 2 = 13\n]\\)\nPortanto, a área do paralelogramo é 13.\n\n\n\nAqui está como você pode calcular o determinante em Python usando a biblioteca NumPy:\nimport numpy as np\n\n# Definindo a matriz\nT = np.array([[3, 2], [1, 5]])\n\n# Calculando o determinante\ndeterminante = np.linalg.det(T)\n\n# Exibindo o valor absoluto do determinante (área do paralelogramo)\narea = abs(determinante)\nprint(area)\n\n\n\nAqui está como você pode calcular o determinante em R:\n# Definindo a matriz\nT &lt;- matrix(c(3, 1, 2, 5), nrow=2, byrow=TRUE)\n\n# Calculando o determinante\ndeterminante &lt;- det(T)\n\n# Exibindo o valor absoluto do determinante (área do paralelogramo)\narea &lt;- abs(determinante)\nprint(area)\nEm ambos os casos, o valor do determinante será 13, que é a área do paralelogramo formado pelos vetores transformados."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#base",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#base",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Base sãos os vetores que formam o ponto num plano. Não é uma base se os vetores seguirem a mesma direção."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#verificando-se-um-conjunto-é-linearmente-independente-ou-não",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#verificando-se-um-conjunto-é-linearmente-independente-ou-não",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Geometricamente, quando dois elementos em \\(R^2~ \\text{ou}~R^3~\\)são Linearmente Dependentes, eles estão na mesma reta, quando colocados na mesma origem.\n\nGeometricamente, quando dois elementos em \\(R^2\\) ou \\(R^3\\) são L.I., eles não estão na mesma reta, quando colocados na mesma origem.\n\nGeometricamente, se três vetores em \\(R^3\\) são linearmente dependentes, ele estão no mesmo plano, quando colocados na mesma origem, caso contrário são linearmente independentes.\n\nExemplo 1: O conjunto \\({(1, 0), (0, 1)}\\) em \\(R^2\\) é Linearmente Independente. De fato, a equação:\n\\(\\alpha1(1, 0) + \\alpha2(0, 1) = (0, 0)\\)\nsó vale para \\(\\alpha1 = \\alpha2 = 0\\). Assim, os vetores \\((1, 0)\\) e \\((0, 1)\\) são L.I.\nhttps://www.ime.unicamp.br/~marcia/AlgebraLinear/dependencia_linear.html"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#autovalores-e-autovetores",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#autovalores-e-autovetores",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Seja \\(A\\) uma matriz \\(\\text{n x n}\\). O escalar \\(\\lambda\\) é um autovalor de \\(A\\) quando há um vetor \\(x\\) não nulo tal que \\(Ax=\\lambda x\\). O vetor \\(x\\) é um autovetor de \\(A\\) associado a \\(\\lambda\\).\n\n\nPara a matriz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix}\n\\]\nVerifique que \\(x_1=(1, 0)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_1=2\\) e que \\(x_2=(0, 1)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_2= 1\\).\nSolução:\nMultiplicar \\(x_1\\) à esquerda por \\(A\\) produz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix} \\begin{bmatrix}1\\\\0\\end{bmatrix}=\\begin{bmatrix}2\\\\0\\end{bmatrix}=2\\begin{bmatrix}1\\\\0\\end{bmatrix}\n\\]\nEntão, \\(x_1 =  (1, 0)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_1= 2\\). Da mesma forma, multiplicar \\(x_2\\) à esquerda por \\(A\\) produz\n\\[\nA = \\begin{bmatrix}2&0\\\\0&-1\\end{bmatrix} \\begin{bmatrix}0\\\\1\\end{bmatrix}=\\begin{bmatrix}0\\\\-1\\end{bmatrix}=-1\\begin{bmatrix}0\\\\1\\end{bmatrix}\n\\]\nEntão \\(x_2 = (0,1)\\) é um autovetor de \\(A\\) associado ao autovalor \\(\\lambda_2 = -1\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#cálculo",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#cálculo",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Para encontrar os autovalores e os autovetores de uma matriz \\(A\\) de ordem \\(n\\), seja \\(I\\) a matriz identidade \\(\\text{n x n}\\). Reescrever \\(Ax = \\lambda x\\) como \\(\\lambda Ix = Ax\\) e reorganizar fornece \\((\\lambda I-A)x=0\\). Este sistema homogêneo de equações possui soluções não nulas se e somente se a matriz dos coeficientes \\((\\lambda I - A)\\) for não invertível, ou seja, se e somente se seu determinante for zero. O próximo teorema afirma formalmente isso.\nTEOREMA: Autovalores e autovetores de uma matriz Seja A uma matriz \\(\\text{n x n}\\).\n\nUm autovalor de \\(A\\) é um escalar \\(\\lambda\\) tal que \\(det(\\lambda-A)=0\\).\nOs autovetores de \\(A\\) associados a \\(\\lambda\\) são as soluções não nulas de \\((\\lambda I - A)=0\\).\n\nEncontre os autovalores e autovetores associados de \\(A = \\begin{bmatrix} 2 & -12 \\\\ 1 & -5 \\end{bmatrix}\\)\nSolução\nO polinômio característico de \\(A\\) é\n\\[\n|\\lambda I - A| = \\begin{vmatrix} \\lambda - 2 & 12 \\\\ -1 & \\lambda + 5 \\end{vmatrix} = \\lambda^2 + 3\\lambda - 10 + 12 = (\\lambda + 1)(\\lambda + 2).\n\\]\nAssim, a equação característica é \\((\\lambda + 1)(\\lambda + 2) = 0\\), o que dá \\(\\lambda_1 = -1\\) e \\(\\lambda_2 = -2\\) como autovalores de \\(A\\). Para encontrar os autovetores associados, resolva o sistema linear homogêneo representado por \\((\\lambda I - A)x = 0\\) duas vezes: primeiro para \\(\\lambda = \\lambda_1 = -1\\) e, então, para \\(\\lambda = \\lambda_2 = -2\\). Para \\(\\lambda_1 = -1\\), a matriz dos coeficientes é\n\\[\n(-1)I - A = \\begin{bmatrix} -1 - 2 & 12 \\\\ -1 & -1 + 5 \\end{bmatrix} = \\begin{bmatrix} -3 & 12 \\\\ -1 & 4 \\end{bmatrix},\n\\]\nque se reduz por linhas a \\(\\begin{bmatrix} 1 & -4 \\\\ 0 & 0 \\end{bmatrix}\\), mostrando que \\(x_1 - 4x_2 = 0\\). Tomando \\(x_2 = t\\), você pode concluir que todo autovetor associado a \\(\\lambda_1\\) é da forma\n\\(x = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 4t \\\\ t \\end{bmatrix} = t \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix}, \\quad t \\neq 0\\).\nPara \\(\\lambda_2=-2\\), você tem\n\\((-2)I - A = \\begin{bmatrix} -2 - 2 & 12 \\\\ -1 & -2 + 5 \\end{bmatrix} = \\begin{bmatrix} -4 & 12 \\\\ -1 & 3 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 1 & -3 \\\\ 0 & 0 \\end{bmatrix}.\\)\nTomando \\(x_2 = t\\), você pode concluir que todo autovetor associado a \\(\\lambda_2\\) é da forma\n\\(x = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 3t \\\\ t \\end{bmatrix}=t\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}, \\quad t \\neq 0.\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#redução-de-dimensionalidade-e-projeção",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#redução-de-dimensionalidade-e-projeção",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "A redução de dimensionalidade consiste em reduzir o número de colunas de um dataset\nPreservar o máximo de informação possível"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#motivação-para-pca",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#motivação-para-pca",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Reduzir dimensionalidade\nVisualização de dados mais eficientes"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#variância-e-covariância",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#variância-e-covariância",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "PCA se baseia em alguns conceitos estatísticos\n\nmédia\n\n\n\nVariância\n\n\n\nCovariância"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#matriz-de-covariância",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#matriz-de-covariância",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Representação\n\n\nAplicação:"
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#pca---visão-geral",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#pca---visão-geral",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "PCA ⇒ Projeções, Autovalorese matriz de covariância.\nToda matriz de covariância é simétrica."
  },
  {
    "objectID": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#pca---formulação-matemática",
    "href": "Vida-Academica/Cursera/04-mod-espacos-vetoriais.html#pca---formulação-matemática",
    "title": "Módulo 4: Determinantes e Autovetores",
    "section": "",
    "text": "Imagine que temos \\(5\\) variáveis \\((x_1, x_2, x_3, x_4, x_5)\\) e queremos reduzir a apenas \\(2\\) variáveis.\n\ncriamos uma matriz \\(X\\) com o conjunto de dados.\n\n\\[\n\\begin{equation}\n\\begin{aligned}\n\\\\\n&X=\\left[\\begin{array}{cccc}\nx_{11} & x_{12} & \\ldots & x_{15} \\\\\nx_{21} & x_{22} & \\ldots & x_{25} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nx_{n 1} & x_{n 2} & \\ldots & x_{n 5}\n\\end{array}\\right]\n\\end{aligned}\n\\end{equation}\n\\]\n\ncentralizamos os dados ⇒ \\(X - \\mu\\)\n\n\\[\n\\begin{equation}\\boldsymbol{X}-\\boldsymbol{\\mu}=\\left[\\begin{array}{cccc}x_{11}-\\mu_1 & x_{12}-\\mu_2 & \\ldots & x_{15}-\\mu_5 \\\\x_{21}-\\mu_1 & x_{22}-\\mu_2 & \\ldots & x_{25}-\\mu_5 \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\x_{n 1}-\\mu_1 & x_{n 2}-\\mu_2 & \\ldots & x_{n 5}-\\mu_5\\end{array}\\right]\\end{equation}\n\\]\n\nCalculamos a matriz de covarância\n\n\\[\n\\begin{equation}C=\\frac{1}{n-1}(X-\\mu)^T(X-\\mu)=\\left[\\begin{array}{ccccc}\\operatorname{Var}\\left(X_1\\right) & \\operatorname{Cov}\\left(X_1, X_2\\right) & \\operatorname{Cov}\\left(X_1, X_3\\right) & \\operatorname{Cov}\\left(X_1, X_4\\right) & \\operatorname{Cov}\\left(X_1, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_2\\right) & \\operatorname{Var}\\left(X_2\\right) & \\operatorname{Cov}\\left(X_2, X_3\\right) & \\operatorname{Cov}\\left(X_2, X_4\\right) & \\operatorname{Cov}\\left(X_2, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_3\\right) & \\operatorname{Cov}\\left(X_2, X_3\\right) & \\operatorname{Var}\\left(X_3\\right) & \\operatorname{Cov}\\left(X_3, X_4\\right) & \\operatorname{Cov}\\left(X_3, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_4\\right) & \\operatorname{Cov}\\left(X_2, X_4\\right) & \\operatorname{Cov}\\left(X_3, X_4\\right) & \\operatorname{Var}\\left(X_4\\right) & \\operatorname{Cov}\\left(X_4, X_5\\right) \\\\\\operatorname{Cov}\\left(X_1, X_5\\right) & \\operatorname{Cov}\\left(X_2, X_5\\right) & \\operatorname{Cov}\\left(X_3, X_5\\right) & \\operatorname{Cov}\\left(X_4, X_5\\right) & \\operatorname{Var}\\left(X_5\\right)\\end{array}\\right]\\end{equation}\n\\]\n\nCalculamos os autovalores e autovetores da matriz de covariância e classifique-os do menor pro maior.\n\n\\[\n\\begin{equation}\\left\\lvert\\, \\begin{array}{ll}\\lambda_1 & v_1 \\\\\\lambda_2 & v_2 \\\\\\lambda_3 & v_3 \\\\\\lambda_4 & v_4 \\\\\\lambda_5 & v_5\\end{array}\\right.\\end{equation}\n\\]\n\nCriar uma matriz para projetar os dados\n\n\\[\n\\begin{equation}V = \\begin{bmatrix}\\frac{v_1}{||v_1||_2} & \\frac{v_2} {||v_2||_2}\\end{bmatrix} \\end{equation}\n\\]\n\nProjetar os dados no vetor escolhido\n\n\\[\n\\begin{equation}X_{PCA} = (X-\\mu)V\\end{equation}\n\\]\nMódulo 1: Sistema de equações lineares"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html",
    "href": "Vida-Academica/Cursera/Calculo.html",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "",
    "text": "Este artigo foi reescrito em Quarta, 21 de agosto de 2024.\nLink do curso: Cálculo para aprendizado de máquina e ciência de dados\nO que Aprendi:\nAcesse as anotações clicando nos links contidos no título de cada módulo abaixo:"
  },
  {
    "objectID": "Vida-Academica/posts/Cursera.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados..curseraalgebra.qmd",
    "href": "Vida-Academica/posts/Cursera.html#álgebra-linear-para-aprendizado-de-máquina-e-ciência-de-dados..curseraalgebra.qmd",
    "title": "Anotações do cursos feitos na plataforma Coursera",
    "section": "[Álgebra linear para aprendizado de máquina e ciência de dados(../Cursera/Algebra.qmd)",
    "text": "[Álgebra linear para aprendizado de máquina e ciência de dados(../Cursera/Algebra.qmd)\nClique aqui para acessar as anotações do curso de Álgebra linear para aprendizado de máquina e ciência de dados."
  },
  {
    "objectID": "Vida-Academica/posts/Cursera.html#aqui",
    "href": "Vida-Academica/posts/Cursera.html#aqui",
    "title": "Anotações do cursos feitos na plataforma Coursera",
    "section": "aqui",
    "text": "aqui"
  },
  {
    "objectID": "Vida-Academica/posts/Cursera.html#cálculo-para-aprendizado-de-máquina-e-ciência-de-dados",
    "href": "Vida-Academica/posts/Cursera.html#cálculo-para-aprendizado-de-máquina-e-ciência-de-dados",
    "title": "Anotações do cursos feitos na plataforma Coursera",
    "section": "Cálculo para aprendizado de máquina e ciência de dados",
    "text": "Cálculo para aprendizado de máquina e ciência de dados"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-1-funções-e-limites",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-1-funções-e-limites",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 1: Funções e limites",
    "text": "Módulo 1: Funções e limites"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-2-derivadas",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-2-derivadas",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 2: Derivadas",
    "text": "Módulo 2: Derivadas"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-3-integrais",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-3-integrais",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 3: Integrais",
    "text": "Módulo 3: Integrais"
  },
  {
    "objectID": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html",
    "href": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html",
    "title": "Módulo 1: Derivadas e otimização",
    "section": "",
    "text": "Otimização de funções ⇒ importante para M.L\nConceitos matemáticos utilizados para treinar um modelo\n\nGradientes\nDerivadas\nOtimização\nFunções de perda e custo\nGradação descendente\n\n\n\n\n\n\nUma derivada é a taxa de variação instantânea de uma função.\n\n\n\n\n\n\n\n\n\nPropriedades\n\nOs pontos máximos e mínimos de uma função são as regiões onde a \\(\\dfrac{dy}{dx} =0\\), isto é, onde a inclinação da reta for igual a 0.\n\n\n\n\n\n\n\nNotação de Leibniz\n\n\\(\\dfrac{dy}{dx} = \\dfrac{d}{dx}f(x)\\)\n\nNotação de Lagrange\n\n\\(f´(x)\\)\n\n\n\n\n\n\nUma linha é uma constante\n\nUma constante tem sempre uma derivada igual a 0.\n\n\n\nUma reta do tipo \\(f(x) = ax+b\\) ⇒ \\(f´(x) = a\\)\n\n\n\n\n\n\n\nPara a função do tipo; \\(f(x) = x^2\\) ⇒ \\(f(x´) = 2x\\)\n\n\n\n\n\n\nPara uma função do tipo; \\(y=f(x) = x^3\\) ⇒ \\(f´(x) =\\) \\(3x^2\\)\n\n\n\n\n\n\nPara a função do tipo \\(y = f(x)=x^{-1}=\\frac{1}{x}\\) ⇒ f´(x) = \\(-x^{-2}\\)\n\n\n\nPara as funções potência derivamos da seguinte forma ⇒ para a \\(f(x)=x^n\\) ⇒ \\(f´(x) = \\frac{d}{dx} f(x)=nx^{(n-1)}\\)\n\n\n\nExemplo\n\n\n\n\n\n\n\\(g(x)\\) e \\(f(x)\\) são inversas\n\n\\(g(x) = f^{-1}(x)\\)\n\\(g(f(x)) = x\\)\n\n\n\n\n\n\n\nFunção seno\n\n\\(f(x) = sin(x) ⇒ f´(x) = cos(x)\\)\n\n\n\n\\(f(x) = cos(x)\\) ⇒ \\(f´(x) = - sin(x)\\)\n\n\n\n\n\n\n\nnúmero de Euler ⇒ \\(e = 2,71828182...\\)\n\npropriedades\n\\(\\begin{bmatrix}n&1&10&100&1000& \\infty \\\\(1+\\frac{1}{n}^n) &2&2,594&2,705&2,717&e \\end{bmatrix}\\)\n\\(f(x) = e^x\\) ⇒ \\(f’(x)=e^x\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDada a função \\(f=4g\\) ⇒ \\(f’=4g’\\)\n\n\n\n\n\n\nDada a função \\(f = g + h\\) ⇒ \\(f’=g’+h’\\)\n\n\n\n\n\n\nDada a função \\(f = gh\\) ⇒ \\(f’ = f’h+gh’\\)\n\n\n\n\n\n\nData a função \\(f(g(h(t)))\\) ⇒ \\(f’(g(h(t)))*g’(h(t))*h’(t)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html#derivada",
    "href": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html#derivada",
    "title": "Módulo 1: Derivadas e otimização",
    "section": "",
    "text": "Otimização de funções ⇒ importante para M.L\nConceitos matemáticos utilizados para treinar um modelo\n\nGradientes\nDerivadas\nOtimização\nFunções de perda e custo\nGradação descendente\n\n\n\n\n\n\nUma derivada é a taxa de variação instantânea de uma função.\n\n\n\n\n\n\n\n\n\nPropriedades\n\nOs pontos máximos e mínimos de uma função são as regiões onde a \\(\\dfrac{dy}{dx} =0\\), isto é, onde a inclinação da reta for igual a 0.\n\n\n\n\n\n\n\nNotação de Leibniz\n\n\\(\\dfrac{dy}{dx} = \\dfrac{d}{dx}f(x)\\)\n\nNotação de Lagrange\n\n\\(f´(x)\\)\n\n\n\n\n\n\nUma linha é uma constante\n\nUma constante tem sempre uma derivada igual a 0.\n\n\n\nUma reta do tipo \\(f(x) = ax+b\\) ⇒ \\(f´(x) = a\\)\n\n\n\n\n\n\n\nPara a função do tipo; \\(f(x) = x^2\\) ⇒ \\(f(x´) = 2x\\)\n\n\n\n\n\n\nPara uma função do tipo; \\(y=f(x) = x^3\\) ⇒ \\(f´(x) =\\) \\(3x^2\\)\n\n\n\n\n\n\nPara a função do tipo \\(y = f(x)=x^{-1}=\\frac{1}{x}\\) ⇒ f´(x) = \\(-x^{-2}\\)\n\n\n\nPara as funções potência derivamos da seguinte forma ⇒ para a \\(f(x)=x^n\\) ⇒ \\(f´(x) = \\frac{d}{dx} f(x)=nx^{(n-1)}\\)\n\n\n\nExemplo\n\n\n\n\n\n\n\\(g(x)\\) e \\(f(x)\\) são inversas\n\n\\(g(x) = f^{-1}(x)\\)\n\\(g(f(x)) = x\\)\n\n\n\n\n\n\n\nFunção seno\n\n\\(f(x) = sin(x) ⇒ f´(x) = cos(x)\\)\n\n\n\n\\(f(x) = cos(x)\\) ⇒ \\(f´(x) = - sin(x)\\)\n\n\n\n\n\n\n\nnúmero de Euler ⇒ \\(e = 2,71828182...\\)\n\npropriedades\n\\(\\begin{bmatrix}n&1&10&100&1000& \\infty \\\\(1+\\frac{1}{n}^n) &2&2,594&2,705&2,717&e \\end{bmatrix}\\)\n\\(f(x) = e^x\\) ⇒ \\(f’(x)=e^x\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDada a função \\(f=4g\\) ⇒ \\(f’=4g’\\)\n\n\n\n\n\n\nDada a função \\(f = g + h\\) ⇒ \\(f’=g’+h’\\)\n\n\n\n\n\n\nDada a função \\(f = gh\\) ⇒ \\(f’ = f’h+gh’\\)\n\n\n\n\n\n\nData a função \\(f(g(h(t)))\\) ⇒ \\(f’(g(h(t)))*g’(h(t))*h’(t)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html",
    "href": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html",
    "title": "Módulo 3: Otimização em redes neurais e método de Newton",
    "section": "",
    "text": "image.png"
  },
  {
    "objectID": "Vida-Academica/Cursera/02-mod-gradientes.html",
    "href": "Vida-Academica/Cursera/02-mod-gradientes.html",
    "title": "Módulo 2: Gradientes e Gradient Descent",
    "section": "",
    "text": "Como podemos calcular uma derivada parcial\n\nImagine a função: \\(f(x,y) = x^2 + y^2\\)\nVamos considerar \\(y^2\\) como uma constante,\n\nentão: \\(\\dfrac{\\partial f}{\\partial x} = 2x + 0\\) ⇒ \\(\\dfrac{\\partial f}{\\partial y} = 2y + 0\\)\n\n\n\nOutro exemplo ⇒ \\(f(x,y) = 3x^2y^3\\)\n\n\\(\\dfrac{\\partial f}{\\partial x} = 3(2x)y^3\\) ⇒ \\(6xy^3\\)\n\n\\(f(x) = 3x^2y^3\\)\n\n\\(\\dfrac{\\partial f}{\\partial y} = 3(x^2)(3y^2)\\) ⇒ \\(9x^2y^2\\)\n\n\n\n\n\n\n\n\ndada a função \\(f(x,y) = x^2 + y^2\\)\no gradiente de f(x, y) é: \\(\\nabla f = \\begin{bmatrix}2x\\\\2y\\end{bmatrix}\\)\nEncontre o gradiente da função \\(f(x,y) = x^2 + y^2\\) no ponto \\((2,3)\\):\n\n\\(\\nabla f = \\begin{bmatrix} 2*2\\\\2*3 \\end{bmatrix} = \\begin{bmatrix} 4\\\\6\\end{bmatrix}\\)\n\nGradiente é importante para minimizarmos funções com duas variáveis:\nPra encontrarmos os pontos mínimos e máximos de uma função com mais de uma variável, basta calcularmos a derivada parcial, igualando as duas funções a 0 e resolvendo o sistema de equações lineares.\n\n\n\n\n03-minimo-maximo-parciais.png\n\n\n\n\n\n\nImagine que você está numa sauna e a temperatura na sala segue essa função \\(T = f(x,y) = 85-\\frac{1}{90}x^2(x-6)y^2(y-6)\\) em relação a área da sauna. Encontre o ponto onde a temperatura é a mínima.\n\nUsando a forma expandida da função ff escrita como: \\(T = f(x,y) = 85-\\frac{1}{90}x^2(x-6)y^2(y-6)\\)\n\\(=85−\\frac{1}{90}x^3y^3+\\frac{1}{15}x^3y^2+\\frac{1}{15}x^2y^3−\\frac{2}{5}x2y2\\)\nEncontre \\(\\dfrac{\\partial f}{\\partial x}\\) e \\(\\dfrac{\\partial f}{\\partial y}\\)\n\\(\\dfrac{\\partial f}{\\partial x} = -\\dfrac{1}{90}x(3x-12)y^2(y-6) =0\\)\n\\(\\dfrac{\\partial f}{\\partial y} = -\\dfrac{1}{90}x^2(x-6)y(3y-12)=0\\)\n\n\n\n04-sauna-minimo.png\n\n\nNum modelo de regressão linear, caso queira encontrar a melhor reta que se ajuste aos dados, o procedimento pode ser feita calculando as derivadas parciais da função que descreve os dados. Veja o exemplo a seguir:\n\n\n\n05-energia-minimo.png\n\n\n\nOs pontos que igualam essa derivada a 0 são dados a seguir:\n\\(m = \\frac{1}{2}\\)\n\\(b = \\frac{7}{3}\\)\nSubstituindo \\(m\\) e \\(b\\) temos que\n\\(E(m=\\frac{1}{2},b= \\frac{7}{3} \\approx 4.167)\\)"
  },
  {
    "objectID": "projetos-Python/posts/Derivadas-Python.html",
    "href": "projetos-Python/posts/Derivadas-Python.html",
    "title": "Derivadas usando Sympy e Numpy",
    "section": "",
    "text": "Este artigo foi reescrito em Sexta, 23 de Agosto de 2024."
  },
  {
    "objectID": "projetos-Python/posts/Derivadas-Python.html#derivadas-simbólicas",
    "href": "projetos-Python/posts/Derivadas-Python.html#derivadas-simbólicas",
    "title": "Derivadas usando Sympy e Numpy",
    "section": "Derivadas simbólicas",
    "text": "Derivadas simbólicas\nComputação simbólica lida com a computação de objetos matemáticos que são representados na forma exata, e não aproximadamente (por exemplo, \\(\\sqrt{2}\\) será escrito exatamente assim, e não como \\(1.41421356237\\). Para a derivada, isso significa que o resultado será de certa forma semelhante ao que seria se você estivesse calculando derivadas manualmente usando regras (analiticamente). Assim, derivadas simbólicas podem produzir resultados exatos.\n\nDerivadas simbólicas em Python usando a biblioteca SymPy.\nPodemos calcular o valor decimal aproximado de \\(\\sqrt{18}\\)\n\n\n\nCode\nimport math\n\nmath.sqrt(18)\n\n\n4.242640687119285\n\n\nIntrodução à Computação Simbólica com SymPy\n\nO valor obtido é: \\(4.242640687119285\\)\n\nAgora se quisermos calcular: \\(\\sqrt{18} = \\sqrt{9 \\cdot 2} = 3\\sqrt{2}\\)\n\n\nCode\n# Esse formato de importação de módulo permite\n# usar as funções sympy sem o prefixo sympy.\nfrom sympy import *\n\n# Na verdade, essa é a função sympy.sqrt,\n# mas o prefixo sympy. foi omitido.\nsqrt(18)\n\n\n\\(\\displaystyle 3 \\sqrt{2}\\)\n\n\nPara obtermos o valor aproximado fazemos\n\n\nCode\nN(sqrt(18))\n\n\n\\(\\displaystyle 4.24264068711928\\)\n\n\nNo SymPy, as variáveis são definidas usando símbolos. Nesta biblioteca específica, elas precisam ser pré-definidas (uma lista delas deve ser fornecida). Veja na célula abaixo como a expressão simbólica, correspondente à expressão matemática \\(2x^2 - xy\\), é definida:\n\n\nCode\n# Lista de símboos\nx, y = symbols('x y')\n# Definição da expressão.\nexpr = 2 * x**2 - x * y\nexpr\n\n\n\\(\\displaystyle 2 x^{2} - x y\\)\n\n\nPode realizar várias manipulações com essa expressão: adicionar ou subtrair alguns termos, multiplicar por outras expressões, etc., assim como se estivesse fazendo isso manualmente:\n\n\nCode\nexpr_manip = x * (expr + x * y + x**3)\nexpr_manip\n\n\n\\(\\displaystyle x \\left(x^{3} + 2 x^{2}\\right)\\)\n\n\nAgora, vamos calcular a derivada da expressão \\(2x^2 - xy\\) em relação a \\(x\\):\n\n\nCode\n# Derivada da expressão em relação a x.\ndiff(expr, x)\n\n\n\\(\\displaystyle 4 x - y\\)\n\n\nPodemos expandir a função expr_manipulada para obter a expressão completa:\n\n\nCode\nexpand(expr_manip)\n\n\n\\(\\displaystyle x^{4} + 2 x^{3}\\)\n\n\nPodemos também simplificar a expressão:\n\n\nCode\nsimplify(expr_manip)\n\n\n\\(\\displaystyle x^{3} \\left(x + 2\\right)\\)\n\n\nTambém podemos fatorear a expressão:\n\n\nCode\nfactor(expr_manip)\n\n\n\\(\\displaystyle x^{3} \\left(x + 2\\right)\\)\n\n\nPodemos também resolver equações simbolicamente:\n\n\nCode\n# Resolvendo a equação x^2 - 1 = 0.\nsolve(x**2 - 1, x)\n\n\n[-1, 1]\n\n\nPodemos substituir valores específicos para as variáveis na expressão\n\n\nCode\nexpr.evalf(subs={x:-1, y:2})\n\n\n\\(\\displaystyle 4.0\\)\n\n\nIsso pode ser usado para avaliar uma função \\(f\\left(x\\right) = x^2\\):\n\n\nCode\nf_symb = x ** 2\nf_symb.evalf(subs={x:3})\n\n\n\\(\\displaystyle 9.0\\)\n\n\nPodemos avaliar uma função simbólica para cada elemento de uma matriz:\n\n\nCode\n# Definindo uma matriz simbólica.\n\nx_array = np.array([1, 2, 3])\n\ntry:\n    f_symb(x_array)\nexcept TypeError as err:\n    print(err)\n# Convertendo a função simbólica em uma função numpy.\nfrom sympy.utilities.lambdify import lambdify\n\nf_symb_numpy = lambdify(x, f_symb, 'numpy')\n\nprint(\"x: \\n\", x_array)\nprint(\"f(x) = x**2: \\n\", f_symb_numpy(x_array))\n\n\n'Pow' object is not callable\nx: \n [1 2 3]\nf(x) = x**2: \n [1 4 9]"
  },
  {
    "objectID": "projetos-Python/posts/Derivadas-Python.html#derivadas-simbólicas-com-sympy",
    "href": "projetos-Python/posts/Derivadas-Python.html#derivadas-simbólicas-com-sympy",
    "title": "Derivadas usando Sympy e Numpy",
    "section": "Derivadas Simbólicas com SymPy",
    "text": "Derivadas Simbólicas com SymPy\nSe quisermos calcular a derivada da função \\(f(x) = x^2\\) simbolicamente, podemos fazer isso com o SymPy:\n\n\nCode\n# Definindo a função simbólica.\nf_symb = x ** 2\n# Calculando a derivada da função simbólica.\ndfdx_symb = diff(f_symb, x)\ndfdx_symb\n\n\n\\(\\displaystyle 2 x\\)\n\n\nO Sympy aplica todas as regras de derivação para obter a derivada da função \\((exp(-2x) + 3sin(3x), x)\\):\n\n\nCode\nf_symb = exp(-2*x) + 3*sin(3*x)\ndfdx_symb = diff(f_symb, x)\nf_symb, dfdx_symb\n\n\n(3*sin(3*x) + exp(-2*x), 9*cos(3*x) - 2*exp(-2*x))\n\n\nAgora vamos plotar a função e sua derivada:\n\n\nCode\nf_symb_numpy = lambdify(x, f_symb, 'numpy')\ndfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n\nplot_f1_and_f2(f_symb_numpy, dfdx_symb_numpy)\n\n\n\n\n\n\n\n\n\nAgora vamos calcular a derivada da função \\(f(x) = 2x\\) simbolicamente:\n\n\nCode\nf_symb_numpy = lambdify(x, f_symb, 'numpy')\n\ndfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n\nprint(\"x: \\n\", x_array)\nprint(\"f'(x) = 2x: \\n\", dfdx_symb_numpy(x_array))\n\n\nx: \n [1 2 3]\nf'(x) = 2x: \n [-9.18060304  8.6049013  -8.20512986]\n\n\nAgora vamos plotar a função e sua derivada:\n\n\nCode\n# plote a função e sua derivada\nplot_f1_and_f2(f_symb_numpy, dfdx_symb_numpy)"
  },
  {
    "objectID": "projetos-Python/posts/Derivadas-Python.html#limitações-da-derivada-simbólica",
    "href": "projetos-Python/posts/Derivadas-Python.html#limitações-da-derivada-simbólica",
    "title": "Derivadas usando Sympy e Numpy",
    "section": "Limitações da derivada simbólica",
    "text": "Limitações da derivada simbólica\n\nÀs vezes, as expressões de saída são muito complicadas e até mesmo impossíveis de serem avaliadas. Por exemplo, encontrar a derivada da função.\n\n\\[\\left|x\\right| = \\begin{cases} x, \\ \\text{if}\\ x &gt; 0\\\\  -x, \\ \\text{if}\\ x &lt; 0 \\\\ 0, \\ \\text{if}\\ x = 0\\end{cases}\\] Analiticamente, anderivada é: \\[\\frac{d}{dx}\\left(\\left|x\\right|\\right) = \\begin{cases} 1, \\ \\text{if}\\ x &gt; 0\\\\  -1, \\ \\text{if}\\ x &lt; 0\\\\\\ \\text{does not exist}, \\ \\text{if}\\ x = 0\\end{cases}\\] Podemos calcular a derivada da função \\(f(x) = \\left|x\\right|\\) simbolicamente:\n\n\nCode\ndfdx_abs = diff(abs(x),x)\ndfdx_abs\n\n\n\\(\\displaystyle \\frac{\\left(\\operatorname{re}{\\left(x\\right)} \\frac{d}{d x} \\operatorname{re}{\\left(x\\right)} + \\operatorname{im}{\\left(x\\right)} \\frac{d}{d x} \\operatorname{im}{\\left(x\\right)}\\right) \\operatorname{sign}{\\left(x \\right)}}{x}\\)\n\n\nOutro exemplo \\(x=-2\\):\n\n\nCode\ndfdx_abs.evalf(subs={x:-2})\n\n\n\\(\\displaystyle - \\left. \\frac{d}{d x} \\operatorname{re}{\\left(x\\right)} \\right|_{\\substack{ x=-2 }}\\)\n\n\nDe fato, há problemas com a avaliação das expressões simbólicas sempre que há um “salto” na derivada (por exemplo, as expressões da função são diferentes para diferentes intervalos de \\(x\\)), como acontece com \\(\\frac{d}{dx}(|x|)\\).\nAlém disso, você pode ver neste exemplo que é possível obter uma função muito complicada como resultado da computação simbólica. Isso é chamado de aumento de expressão, que resulta em cálculos não suficientemente lentos."
  },
  {
    "objectID": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html#derivadas-usando-sympy-numpy-e-jax-python",
    "href": "Vida-Academica/Cursera/01-mod-derivadas-otimização.html#derivadas-usando-sympy-numpy-e-jax-python",
    "title": "Módulo 1: Derivadas e otimização",
    "section": "Derivadas usando Sympy, Numpy e JAX (Python)",
    "text": "Derivadas usando Sympy, Numpy e JAX (Python)"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-1",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-1",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 1:",
    "text": "Módulo 1:"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-2",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-2",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 2:",
    "text": "Módulo 2:"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-3",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-3",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 3:",
    "text": "Módulo 3:"
  },
  {
    "objectID": "projetos-Python/posts/gradiente-descent.html",
    "href": "projetos-Python/posts/gradiente-descent.html",
    "title": "Otimização usando Gradient Descent em uma variável Usando Python",
    "section": "",
    "text": "Para entendermos como otimizar funções usando Gradient Descent, vamos começar com uma exemplo simples: funções de uma única variável.\nPara isso vamos utilizar os pacotes numpy e matplotlib.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom w2_tools import plot_f, gradient_descent_one_variable, f_example_2, dfdx_example_2\n\n\nA função \\(f(x) = e^x - log(x)\\) (definida para \\(x&gt;0\\)) é uma função de uma variável que tem apenas um ponto mínimo (chamado de mínimo global). No entanto, às vezes esse ponto mínimo não pode ser encontrado analiticamente - resolvendo a derivada dessa equação \\(\\dfrac{df}{dx}=0\\). Isso pode ser feito usando um método de Gradient Descent.\nPara implementar a Gradient Descent, você precisa partir de algum ponto inicial \\(x_0\\). Com o objetivo de encontrar um ponto em que a derivada seja igual a zero, você deseja “descer na curva”. Calcule a derivada \\(\\dfrac{df}{dx}(x)\\) (chamado de gradiente) e avance para o próximo ponto usando a expressão:\n\\[\nx_1 = x_0 - \\alpha \\frac{df}{dx}(x_0),\\tag{1}\n\\]\nem que \\(a&gt;0\\) é um parâmetro chamado de taxa de aprendizado. Repita o processo iterativamente. O número de iterações \\(n\\) geralmente também é um parâmetro.\nSubtraindo \\(\\dfrac{df}{dx}(x_0)\\) você desce a na curva contra o aumento da função - em direção ao ponto mínimo. Portanto, \\(\\dfrac{df}{dx}(x_0)\\) geralmente define a direção do movimento. O parâmetro \\(a\\) serve como um fator de escala.\nAgora é hora de implementar o método de Gradient Descent e fazer experimentos com os parâmetros!\nPrimeiro, defina a função \\(f(x)=e^2-log(x)\\) e sua derivada \\(\\dfrac{df}{dx}=e^x-\\dfrac{1}{x}\\):\n\n\nCode\ndef f_example_1(x):\n    return np.exp(x) - np.log(x)\n\ndef dfdx_example_1(x):\n    return np.exp(x) - 1/x\n\n\nA função \\(f(x)\\) tem um mínimo global. Vamos traçar o gráfico da função:\n\n\nCode\nplot_f([0.001, 2.5], [-0.3, 13], f_example_1, 0.0)\n\n\n\n\n\n\n\n\n\nO Gradient Descent pode ser implementado da seguinte forma:\n\n\nCode\ndef gradient_descent(dfdx, x, learning_rate = 0.1, num_iterations = 100):\n    for iteration in range(num_iterations):\n        x = x - learning_rate * dfdx(x)\n    return x\n\n\nObserve que há três parâmetros nessa implementação: num_iterations, learning_rate, ponto inicial x_initial. Para otimizar a função, configure os parâmetros e chame a função definida gradient_descent:\n\n\nCode\nnum_iterations = 25; learning_rate = 0.1; x_initial = 1.6\nprint(\"Gradient descent result: x_min =\", gradient_descent(dfdx_example_1, x_initial, learning_rate, num_iterations)) \n\n\nGradient descent result: x_min = 0.5671434156768685\n\n\nO código na célula a seguir o ajudará a visualizar e entender melhor o método de descida de gradiente.\n\n\nCode\nnum_iterations = 25; learning_rate = 0.1; x_initial = 1.6\nnum_iterations = 25; learning_rate = 0.3; x_initial = 1.6\nnum_iterations = 25; learning_rate = 0.5; x_initial = 1.6\nnum_iterations = 25; learning_rate = 0.04; x_initial = 1.6\nnum_iterations = 75; learning_rate = 0.04; x_initial = 1.6\nnum_iterations = 25; learning_rate = 0.1; x_initial = 0.05\nnum_iterations = 25; learning_rate = 0.1; x_initial = 0.03\nnum_iterations = 25; learning_rate = 0.1; x_initial = 0.02\n\ngd_example_1 = gradient_descent_one_variable([0.001, 2.5], [-0.3, 13], f_example_1, dfdx_example_1, \n                                   gradient_descent, num_iterations, learning_rate, x_initial, 0.0, [0.35, 9.5])\n\n\n\n\n\n\n\n\n\n\nFunção com vários mínimos\nPlotando a função\n\n\nCode\nplot_f([0.001, 2], [-6.3, 5], f_example_2, -6)\n\n\n\n\n\n\n\n\n\nRodando o gradient descent\n\n\nCode\nprint(\"Gradient descent results\")\nprint(\"Global minimum: x_min =\", gradient_descent(dfdx_example_2, x=1.3, learning_rate=0.005, num_iterations=35)) \nprint(\"Local minimum: x_min =\", gradient_descent(dfdx_example_2, x=0.25, learning_rate=0.005, num_iterations=35)) \n\n\nGradient descent results\nGlobal minimum: x_min = 1.7751686214270586\nLocal minimum: x_min = 0.7585728671820583\n\n\nTestando diferentes pontos:\n\n\nCode\nnum_iterations = 35; learning_rate = 0.005; x_initial = 1.3\nnum_iterations = 35; learning_rate = 0.005; x_initial = 0.25\nnum_iterations = 35; learning_rate = 0.01; x_initial = 1.3\n\ngd_example_2 = gradient_descent_one_variable([0.001, 2], [-6.3, 5], f_example_2, dfdx_example_2, \n                                      gradient_descent, num_iterations, learning_rate, x_initial, -6, [0.1, -0.5])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/02-mod-gradientes.html#gradientes",
    "href": "Vida-Academica/Cursera/02-mod-gradientes.html#gradientes",
    "title": "Módulo 2: Gradientes e Gradient Descent",
    "section": "",
    "text": "Como podemos calcular uma derivada parcial\n\nImagine a função: \\(f(x,y) = x^2 + y^2\\)\nVamos considerar \\(y^2\\) como uma constante,\n\nentão: \\(\\dfrac{\\partial f}{\\partial x} = 2x + 0\\) ⇒ \\(\\dfrac{\\partial f}{\\partial y} = 2y + 0\\)\n\n\n\nOutro exemplo ⇒ \\(f(x,y) = 3x^2y^3\\)\n\n\\(\\dfrac{\\partial f}{\\partial x} = 3(2x)y^3\\) ⇒ \\(6xy^3\\)\n\n\\(f(x) = 3x^2y^3\\)\n\n\\(\\dfrac{\\partial f}{\\partial y} = 3(x^2)(3y^2)\\) ⇒ \\(9x^2y^2\\)\n\n\n\n\n\n\n\n\ndada a função \\(f(x,y) = x^2 + y^2\\)\no gradiente de f(x, y) é: \\(\\nabla f = \\begin{bmatrix}2x\\\\2y\\end{bmatrix}\\)\nEncontre o gradiente da função \\(f(x,y) = x^2 + y^2\\) no ponto \\((2,3)\\):\n\n\\(\\nabla f = \\begin{bmatrix} 2*2\\\\2*3 \\end{bmatrix} = \\begin{bmatrix} 4\\\\6\\end{bmatrix}\\)\n\nGradiente é importante para minimizarmos funções com duas variáveis:\nPra encontrarmos os pontos mínimos e máximos de uma função com mais de uma variável, basta calcularmos a derivada parcial, igualando as duas funções a 0 e resolvendo o sistema de equações lineares.\n\n\n\n\n03-minimo-maximo-parciais.png\n\n\n\n\n\n\nImagine que você está numa sauna e a temperatura na sala segue essa função \\(T = f(x,y) = 85-\\frac{1}{90}x^2(x-6)y^2(y-6)\\) em relação a área da sauna. Encontre o ponto onde a temperatura é a mínima.\n\nUsando a forma expandida da função ff escrita como: \\(T = f(x,y) = 85-\\frac{1}{90}x^2(x-6)y^2(y-6)\\)\n\\(=85−\\frac{1}{90}x^3y^3+\\frac{1}{15}x^3y^2+\\frac{1}{15}x^2y^3−\\frac{2}{5}x2y2\\)\nEncontre \\(\\dfrac{\\partial f}{\\partial x}\\) e \\(\\dfrac{\\partial f}{\\partial y}\\)\n\\(\\dfrac{\\partial f}{\\partial x} = -\\dfrac{1}{90}x(3x-12)y^2(y-6) =0\\)\n\\(\\dfrac{\\partial f}{\\partial y} = -\\dfrac{1}{90}x^2(x-6)y(3y-12)=0\\)\n\n\n\n04-sauna-minimo.png\n\n\nNum modelo de regressão linear, caso queira encontrar a melhor reta que se ajuste aos dados, o procedimento pode ser feita calculando as derivadas parciais da função que descreve os dados. Veja o exemplo a seguir:\n\n\n\n05-energia-minimo.png\n\n\n\nOs pontos que igualam essa derivada a 0 são dados a seguir:\n\\(m = \\frac{1}{2}\\)\n\\(b = \\frac{7}{3}\\)\nSubstituindo \\(m\\) e \\(b\\) temos que\n\\(E(m=\\frac{1}{2},b= \\frac{7}{3} \\approx 4.167)\\)"
  },
  {
    "objectID": "Vida-Academica/Cursera/02-mod-gradientes.html#gradiente-descendente",
    "href": "Vida-Academica/Cursera/02-mod-gradientes.html#gradiente-descendente",
    "title": "Módulo 2: Gradientes e Gradient Descent",
    "section": "Gradiente Descendente",
    "text": "Gradiente Descendente\n\nDado que temos a função \\(f(x) = e^x - log(x)\\)\n\n\n\nEscolhemos um valor aleatório e o movemos nas duas direções do eixo \\(x\\) e verificamos a direção até chegarmos no ponto onde a derivada sobe de uma lado e desce do outro, assim, encontramos um ponto que aproximadamente pode ser o mínimo.\nSe você quiser encontrar o ponto mais próximo do mínimo menos a inclinação."
  },
  {
    "objectID": "projetos-Python/posts/gradien-descent-2-variables.html",
    "href": "projetos-Python/posts/gradien-descent-2-variables.html",
    "title": "Otimização usando Gradient Descent em duas variáveis usando Python",
    "section": "",
    "text": "Método de Gradient Descent otimizando algumas funções em duas variáveis.\nVamos carregar os pacotes que utilizaremos aqui:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom w2_tools import (plot_f_cont_and_surf, gradient_descent_two_variables, \n                      f_example_3, dfdx_example_3, dfdy_example_3, \n                      f_example_4, dfdx_example_4, dfdy_example_4)\n\n\nAgora vamos explorar um exemplo simples de uma função em duas variáveis \\(f(x,y)\\) com um mínimo global.\n\n\nCode\nplot_f_cont_and_surf([0, 5], [0, 5], [74, 85], f_example_3, cmap='coolwarm', view={'azim':-60,'elev':28})\n\n\n(&lt;Figure size 960x480 with 2 Axes&gt;,\n &lt;Axes: xlabel='$x$', ylabel='$y$'&gt;,\n &lt;Axes3D: xlabel='$x$', ylabel='$y$', zlabel='$f$'&gt;)\n\n\n\n\n\n\n\n\n\nPara encontrarmos o mínimo, você podemos implementar a gradient descent a partir do ponto inicial \\((x_0,y_0)\\) e realizar etapas iteração por iteração usando as seguintes equações:\n\\[\nx_1 = x_0 - \\alpha \\frac{\\partial f}{\\partial x}(x_0, y_0),\n\\]\n\\[\ny_1 = y_0 - \\alpha \\frac{\\partial f}{\\partial y}(x_0, y_0),\\tag{1}\n\\]\nem que \\(\\alpha&gt;0\\) é uma taxa de aprendizado. O número de iterações também é um parâmetro. O método é implementado com o seguinte código:\n\n\nCode\ndef gradient_descent(dfdx, dfdy, x, y, learning_rate = 0.1, num_iterations = 100):\n    for iteration in range(num_iterations):\n        x, y = x - learning_rate * dfdx(x, y), y - learning_rate * dfdy(x, y)\n    return x, y\n\n\nAgora, para otimizar a função, configuramos os parâmetros num_iterations, learning_rate, x_initial, y_initial e executar o gradient descent:\n\n\nCode\nnum_iterations = 30; learning_rate = 0.25; x_initial = 0.5; y_initial = 0.6\nprint(\"Gradient descent result: x_min, y_min =\", \n      gradient_descent(dfdx_example_3, dfdy_example_3, x_initial, y_initial, learning_rate, num_iterations)) \n\n\nGradient descent result: x_min, y_min = (4.0, 4.0)\n\n\nPode ver a visualização executando o código a seguir. Observe que a descida de gradiente em duas variáveis executa etapas no plano, em uma direção oposta ao vetor de gradiente \\(\\begin{bmatrix}\\frac{\\partial f}{\\partial x}(x_0, y_0) \\\\ \\frac{\\partial f}{\\partial y}(x_0, y_0)\\end{bmatrix}\\) com a taxa de aprendizado \\(\\alpha\\) como um fator de escala.\n\n\nCode\nnum_iterations = 20; learning_rate = 0.25; x_initial = 0.5; y_initial = 0.6\nnum_iterations = 20; learning_rate = 0.5; x_initial = 0.5; y_initial = 0.6\nnum_iterations = 20; learning_rate = 0.15; x_initial = 0.5; y_initial = 0.6\nnum_iterations = 20; learning_rate = 0.15; x_initial = 3.5; y_initial = 3.6\n\ngd_example_3 = gradient_descent_two_variables([0, 5], [0, 5], [74, 85], \n                                              f_example_3, dfdx_example_3, dfdy_example_3, \n                                              gradient_descent, num_iterations, learning_rate, \n                                              x_initial, y_initial, \n                                              [0.1, 0.1, 81.5], 2, [4, 1, 171], \n                                              cmap='coolwarm', view={'azim':-60,'elev':28})\n\n\n\n\n\n\n\n\n\nVamos dar uma olhada nessa outra função\n\n\nCode\nplot_f_cont_and_surf([0, 5], [0, 5], [6, 9.5], f_example_4, cmap='terrain', view={'azim':-63,'elev':21})\n\n\n(&lt;Figure size 960x480 with 2 Axes&gt;,\n &lt;Axes: xlabel='$x$', ylabel='$y$'&gt;,\n &lt;Axes3D: xlabel='$x$', ylabel='$y$', zlabel='$f$'&gt;)\n\n\n\n\n\n\n\n\n\nPodemos encontrar o mínimo global com:\n\n\nCode\nnum_iterations = 100; learning_rate = 0.2; x_initial = 0.5; y_initial = 3\n\nprint(\"Gradient descent result: x_min, y_min =\", \n      gradient_descent(dfdx_example_4, dfdy_example_4, x_initial, y_initial, learning_rate, num_iterations)) \n\n\nGradient descent result: x_min, y_min = (0.5230322579358745, 0.5169891562802605)\n\n\nVisualizando\n\n\nCode\n# Converges to the global minimum point.\nnum_iterations = 30; learning_rate = 0.2; x_initial = 0.5; y_initial = 3\n# Converges to a local minimum point.\n# num_iterations = 20; learning_rate = 0.2; x_initial = 2; y_initial = 3\n# Converges to another local minimum point.\n# num_iterations = 20; learning_rate = 0.2; x_initial = 4; y_initial = 0.5\n\ngd_example_4 = gradient_descent_two_variables([0, 5], [0, 5], [6, 9.5], \n                                              f_example_4, dfdx_example_4, dfdy_example_4, \n                                              gradient_descent, num_iterations, learning_rate, \n                                              x_initial, y_initial, \n                                              [2, 2, 6], 0.5, [2, 1, 63], \n                                              cmap='terrain', view={'azim':-63,'elev':21})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Vida-Academica/Cursera/02-mod-gradientes.html#otimização-usando-gradient-descent-em-uma-variável-usando-python",
    "href": "Vida-Academica/Cursera/02-mod-gradientes.html#otimização-usando-gradient-descent-em-uma-variável-usando-python",
    "title": "Módulo 2: Gradientes e Gradient Descent",
    "section": "Otimização usando Gradient Descent em uma variável Usando Python",
    "text": "Otimização usando Gradient Descent em uma variável Usando Python\nClique aqui para acessar o código"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#otimização-em-redes-neurais",
    "href": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#otimização-em-redes-neurais",
    "title": "Módulo 3: Otimização em redes neurais e método de Newton",
    "section": "",
    "text": "image.png"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#modelo-de-rede-neural-com-um-único-perceptron-e-um-nó-de-entrada",
    "href": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#modelo-de-rede-neural-com-um-único-perceptron-e-um-nó-de-entrada",
    "title": "Módulo 3: Otimização em redes neurais e método de Newton",
    "section": "Modelo de rede neural com um único Perceptron e um nó de entrada",
    "text": "Modelo de rede neural com um único Perceptron e um nó de entrada\nO modelo de rede neural mais simples que descreve o problema acima pode ser realizado com o uso de um perceptron. As camadas de entrada e saída terão um nó cada (\\(x\\) para entrada e \\(\\hat{y} = z\\) para saída):\n\n\n\nimage.png\n\n\nWeight (\\(w\\)) e bias (\\(b\\)) são os parâmetros que serão atualizados quando você treinar o modelo. Eles são inicializados com alguns valores aleatórios ou definidos como 0 e atualizados à medida que o treinamento avança.\nPara cada exemplo de treinamento \\(x^{(i)}\\), a previsão \\(\\hat{y}^{(i)}\\) pode ser calculada como:\n\\[\n\\begin{align} z^{(i)} &= w x^{(i)} + b,\\\\ \\hat{y}^{(i)} &= z^{(i)}, \\tag{2} \\end{align}\n\\]\nonde \\(i = 1, \\dots, m\\).\nVocê pode organizar todos os exemplos de treinamento como um vetor \\(X\\) de tamanho (\\(1 \\times m\\)) e realizar a multiplicação escalar de \\(X\\) (\\(1 \\times m\\)) por um escalar \\(w\\), adicionando \\(b\\), que será transmitido para um vetor de tamanho (\\(1 \\times m\\)):\n\\[\n\\begin{align} Z &= w X + b,\\\\\\ \\hat{Y} &= Z, \\tag{3}\\end{align}\n\\]\nEsse conjunto de cálculos é chamado de propagação direta.\nPara cada exemplo de treinamento, você pode medir a diferença entre os valores originais \\(y^{(i)}\\) e os valores previstos \\(\\hat{y}^{(i)}\\) com a função loss \\(L\\left(w, b\\right) = \\frac{1}{2}\\left(\\hat{y}^{(i)} - y^{(i)}\\right)^2\\). A divisão por \\(2\\) é feita apenas para fins de escala; você verá o motivo abaixo, calculando as derivadas parciais. Para comparar o vetor resultante das previsões \\(\\hat{Y}\\) (\\(1 \\times m\\)) com o vetor \\(Y\\) dos valores originais \\(y^{(i)}\\), você pode obter uma média dos valores da função de perda para cada um dos exemplos de treinamento:\n\\[\n\\mathcal{L}\\left(w, b\\right) = \\frac{1}{2m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)^2.\\tag{4}\n\\]\nEssa função é chamada de soma de quadrados função de custo. O objetivo é otimizar a função de custo durante o treinamento, o que minimizará as diferenças entre os valores originais \\(y^{(i)}\\) e os valores previstos \\(\\hat{y}^{(i)}\\).\nQuando os pesos foram inicializados apenas com alguns valores aleatórios e nenhum treinamento foi feito, não é possível esperar bons resultados. Você precisa calcular os ajustes para o peso e a polarização, minimizando a função de custo. Esse processo é chamado de propagação para trás.\nDe acordo com o algoritmo de descida de gradiente, você pode calcular as derivadas parciais como:\n\\[\n\\begin{align} \\frac{\\partial \\mathcal{L} }{ \\partial w } &= \\frac{1}{m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)x^{(i)},\\\\ \\frac{\\partial \\mathcal{L} }{ \\partial b } &= \\frac{1}{m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right). \\tag{5}\\end{align}\n\\]\nVocê pode ver como a divisão adicional por \\(2\\) na equação \\((4)\\) ajudou a simplificar os resultados das derivadas parciais. Em seguida, atualize os parâmetros iterativamente usando as expressões\n\\[\n\\begin{align} w &= w - \\alpha \\frac{\\partial \\mathcal{L} }{ \\partial w },\\\\ b &= b - \\alpha \\frac{\\partial \\mathcal{L} }{ \\partial b }, \\tag{6}\\end{align}\n\\]\nem que \\(\\alpha\\) é a taxa de aprendizado. Em seguida, repita o processo até que a função de custo pare de diminuir.\nA metodologia geral para construir uma rede neural é:\n\nDefinir a estrutura da rede neural (número de unidades de entrada, número de unidades ocultas, etc.).\nInicializar os parâmetros do modelo\nFazer um loop: - Implementar a propagação para frente (calcular a saída do perceptron), - Implementar a propagação para trás (para obter as correções necessárias para os parâmetros), - Atualizar os parâmetros.\nFazer previsões.\n\nGeralmente, você cria funções auxiliares para calcular as etapas de 1 a 3 e depois as mescla em uma função nn_model(). Depois de criar nn_model() e aprender os parâmetros corretos, você pode fazer previsões com novos dados.\n\n1.3 - Conjunto de dados\nCarregue (Conjunto de dados), salvo em um arquivo data/tvmarketing.csv. Ele tem dois campos: Despesas de marketing de TV (TV) e valor das vendas (Sales).\npath = \"data/tvmarketing.csv\"\n\nadv = pd.read_csv(path)\nCriando gráfico\nadv.plot(x='TV', y='Sales', kind='scatter', c='black')\nOs campos TV e Sales têm unidades diferentes. Para tornar o algoritmo de descida de gradiente eficiente, precisamos normalizar cada um deles: subtrair o valor médio da matriz de cada um dos elementos da matriz e dividi-los pelo desvio padrão.\nA normalização do conjunto de dados por coluna pode ser feita para todos os campos de uma só vez e é implementada no código a seguir:\nadv_norm = (adv - np.mean(adv))/np.std(adv)\n# gráfico\nadv_norm.plot(x='TV', y='Sales', kind='scatter', c='black')\nRenomeando as variáveis\nX_norm = adv_norm['TV']\nY_norm = adv_norm['Sales']\n\nX_norm = np.array(X_norm).reshape((1, len(X_norm)))\nY_norm = np.array(Y_norm).reshape((1, len(Y_norm)))\n\nprint ('The shape of X_norm: ' + str(X_norm.shape))\nprint ('The shape of Y_norm: ' + str(Y_norm.shape))\nprint ('I have m = %d training examples!' % (X_norm.shape[1]))"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#implementação-do-modelo-de-rede-neural-para-regressão-linear",
    "href": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#implementação-do-modelo-de-rede-neural-para-regressão-linear",
    "title": "Módulo 3: Otimização em redes neurais e método de Newton",
    "section": "Implementação do modelo de rede neural para regressão linear",
    "text": "Implementação do modelo de rede neural para regressão linear\nConfigure a rede neural de forma que seja possível estender esse caso simples de um modelo com um único perceptron e um nó de entrada para estruturas mais complicadas posteriormente.\nDefinição da estrutura da rede neural\nDefina duas variáveis:\n\nn_x: o tamanho da camada de entrada\nn_y: o tamanho da camada de saída\n\nusando formas de matrizes X e Y.\ndef layer_sizes(X, Y):\n    \"\"\"\n    Arguments:\n    X -- input dataset of shape (input size, number of examples)\n    Y -- labels of shape (output size, number of examples)\n    \n    Returns:\n    n_x -- the size of the input layer\n    n_y -- the size of the output layer\n    \"\"\"\n    n_x = X.shape[0]\n    n_y = Y.shape[0]\n    \n    return (n_x, n_y)\n\n(n_x, n_y) = layer_sizes(X_norm, Y_norm)\nprint(\"The size of the input layer is: n_x = \" + str(n_x))\nprint(\"The size of the output layer is: n_y = \" + str(n_y))\n\nInicializar os parâmetros do modelo\nImplemente a função initialize_parameters(), inicializando o vetor de pesos de forma \\((n_y \\times n_x) = (1 \\times 1)\\) com valores aleatórios e o vetor de polarização de forma \\((n_y \\times 1) = (1 \\times 1)\\) com zeros\ndef initialize_parameters(n_x, n_y):\n    \"\"\"\n    Returns:\n    params -- python dictionary containing your parameters:\n                    W -- weight matrix of shape (n_y, n_x)\n                    b -- bias value set as a vector of shape (n_y, 1)\n    \"\"\"\n    \n    W = np.random.randn(n_y, n_x) * 0.01\n    b = np.zeros((n_y, 1))\n    \n    parameters = {\"W\": W,\n                  \"b\": b}\n    \n    return parameters\n\nparameters = initialize_parameters(n_x, n_y)\nprint(\"W = \" + str(parameters[\"W\"]))\nprint(\"b = \" + str(parameters[\"b\"]))\nLoop\nImplemente forward_propagation() seguindo a equação \\((3)\\) na seção 1.2:\n\\[\n\\begin{align}\nZ &=  w X + b\\\\\n\\hat{Y} &= Z,\n\\end{align}\n\\]\ndef forward_propagation(X, parameters):\n    \"\"\"\n    Argument:\n    X -- input data of size (n_x, m)\n    parameters -- python dictionary containing your parameters (output of initialization function)\n    \n    Returns:\n    Y_hat -- The output\n    \"\"\"\n    W = parameters[\"W\"]\n    b = parameters[\"b\"]\n    \n    # Forward Propagation to calculate Z.\n    Z = np.matmul(W, X) + b\n    Y_hat = Z\n\n    return Y_hat\n\nY_hat = forward_propagation(X_norm, parameters)\n\nprint(\"Some elements of output vector Y_hat:\", Y_hat[0, 0:5])\nSeus pesos acabaram de ser inicializados com alguns valores aleatórios, portanto, o modelo ainda não foi treinado.\nDefina uma função de custo \\((4)\\) que será usada para treinar o modelo:\n\\[\n\\mathcal{L}\\left(w, b\\right)  = \\frac{1}{2m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)^2\n\\]\ndef compute_cost(Y_hat, Y):\n    \"\"\"\n    Computes the cost function as a sum of squares\n    \n    Arguments:\n    Y_hat -- The output of the neural network of shape (n_y, number of examples)\n    Y -- \"true\" labels vector of shape (n_y, number of examples)\n    \n    Returns:\n    cost -- sum of squares scaled by 1/(2*number of examples)\n    \n    \"\"\"\n    # Number of examples.\n    m = Y_hat.shape[1]\n\n    # Compute the cost function.\n    cost = np.sum((Y_hat - Y)**2)/(2*m)\n    \n    return cost\n\nprint(\"cost = \" + str(compute_cost(Y_hat, Y_norm)))\nCalcule as derivadas parciais conforme mostrado em \\((5)\\):\n\\[\n\\begin{align} \\frac{\\partial \\mathcal{L} }{ \\partial w } &= \\frac{1}{m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)x^{(i)},\\\\ \\frac{\\partial \\mathcal{L} }{ \\partial b } &= \\frac{1}{m}\\sum_{i=1}^{m} \\left(\\hat{y}^{(i)} - y^{(i)}\\right). \\end{align}\n\\]\ndef backward_propagation(Y_hat, X, Y):\n    \"\"\"\n    Implements the backward propagation, calculating gradients\n    \n    Arguments:\n    Y_hat -- the output of the neural network of shape (n_y, number of examples)\n    X -- input data of shape (n_x, number of examples)\n    Y -- \"true\" labels vector of shape (n_y, number of examples)\n    \n    Returns:\n    grads -- python dictionary containing gradients with respect to different parameters\n    \"\"\"\n    m = X.shape[1]\n    \n    # Backward propagation: calculate partial derivatives denoted as dW, db for simplicity. \n    dZ = Y_hat - Y\n    dW = 1/m * np.dot(dZ, X.T)\n    db = 1/m * np.sum(dZ, axis = 1, keepdims = True)\n    \n    grads = {\"dW\": dW,\n             \"db\": db}\n    \n    return grads\n\ngrads = backward_propagation(Y_hat, X_norm, Y_norm)\n\nprint(\"dW = \" + str(grads[\"dW\"]))\nprint(\"db = \" + str(grads[\"db\"]))\nAtualize os parâmetros conforme mostrado em \\((6)\\):\n\\[\n\\begin{align} w &= w - \\alpha \\frac{\\partial \\mathcal{L} }{ \\partial w },\\\\ b &= b - \\alpha \\frac{\\partial \\mathcal{L} }{ \\partial b }. \\end{align}\n\\]\ndef update_parameters(parameters, grads, learning_rate=1.2):\n    \"\"\"\n    Updates parameters using the gradient descent update rule\n    \n    Arguments:\n    parameters -- python dictionary containing parameters \n    grads -- python dictionary containing gradients \n    learning_rate -- learning rate parameter for gradient descent\n    \n    Returns:\n    parameters -- python dictionary containing updated parameters \n    \"\"\"\n    # Retrieve each parameter from the dictionary \"parameters\".\n    W = parameters[\"W\"]\n    b = parameters[\"b\"]\n    \n    # Retrieve each gradient from the dictionary \"grads\".\n    dW = grads[\"dW\"]\n    db = grads[\"db\"]\n    \n    # Update rule for each parameter.\n    W = W - learning_rate * dW\n    b = b - learning_rate * db\n    \n    parameters = {\"W\": W,\n                  \"b\": b}\n    \n    return parameters\n\nparameters_updated = update_parameters(parameters, grads)\n\nprint(\"W updated = \" + str(parameters_updated[\"W\"]))\nprint(\"b updated = \" + str(parameters_updated[\"b\"]))\nModelo de rede neural\ndef nn_model(X, Y, num_iterations=10, learning_rate=1.2, print_cost=False):\n    \"\"\"\n    Arguments:\n    X -- dataset of shape (n_x, number of examples)\n    Y -- labels of shape (n_y, number of examples)\n    num_iterations -- number of iterations in the loop\n    learning_rate -- learning rate parameter for gradient descent\n    print_cost -- if True, print the cost every iteration\n    \n    Returns:\n    parameters -- parameters learnt by the model. They can then be used to make predictions.\n    \"\"\"\n    \n    n_x = layer_sizes(X, Y)[0]\n    n_y = layer_sizes(X, Y)[1]\n    \n    parameters = initialize_parameters(n_x, n_y)\n    \n    # Loop\n    for i in range(0, num_iterations):\n         \n        # Forward propagation. Inputs: \"X, parameters\". Outputs: \"Y_hat\".\n        Y_hat = forward_propagation(X, parameters)\n        \n        # Cost function. Inputs: \"Y_hat, Y\". Outputs: \"cost\".\n        cost = compute_cost(Y_hat, Y)\n        \n        # Backpropagation. Inputs: \"Y_hat, X, Y\". Outputs: \"grads\".\n        grads = backward_propagation(Y_hat, X, Y)\n    \n        # Gradient descent parameter update. Inputs: \"parameters, grads, learning_rate\". Outputs: \"parameters\".\n        parameters = update_parameters(parameters, grads, learning_rate)\n        \n        # Print the cost every iteration.\n        if print_cost:\n            print (\"Cost after iteration %i: %f\" %(i, cost))\n\n    return parameters\n\n###############################################################################\nparameters_simple = nn_model(X_norm, Y_norm, num_iterations=30, learning_rate=1.2, print_cost=True)\nprint(\"W = \" + str(parameters_simple[\"W\"]))\nprint(\"b = \" + str(parameters_simple[\"b\"]))\n\nW_simple = parameters[\"W\"]\nb_simple = parameters[\"b\"]\nVocê pode ver que, após algumas iterações, a função de custo não se altera mais (o modelo converge).\nObservação: Esse é um modelo muito simples. Na realidade, os modelos não convergem tão rapidamente.\nOs parâmetros finais do modelo podem ser usados para fazer previsões, mas não se esqueça da normalização e da desnormalização.\ndef predict(X, Y, parameters, X_pred):\n    \n    # Retrieve each parameter from the dictionary \"parameters\".\n    W = parameters[\"W\"]\n    b = parameters[\"b\"]\n    \n    # Use the same mean and standard deviation of the original training array X.\n    if isinstance(X, pd.Series):\n        X_mean = np.mean(X)\n        X_std = np.std(X)\n        X_pred_norm = ((X_pred - X_mean)/X_std).reshape((1, len(X_pred)))\n    else:\n        X_mean = np.array(np.mean(X)).reshape((len(X.axes[1]),1))\n        X_std = np.array(np.std(X)).reshape((len(X.axes[1]),1))\n        X_pred_norm = ((X_pred - X_mean)/X_std)\n    # Make predictions.\n    Y_pred_norm = np.matmul(W, X_pred_norm) + b\n    # Use the same mean and standard deviation of the original training array Y.\n    Y_pred = Y_pred_norm * np.std(Y) + np.mean(Y)\n    \n    return Y_pred[0]\n\nX_pred = np.array([50, 120, 280])\nY_pred = predict(adv[\"TV\"], adv[\"Sales\"], parameters_simple, X_pred)\nprint(f\"TV marketing expenses:\\n{X_pred}\")\nprint(f\"Predictions of sales:\\n{Y_pred}\")\nPlot\nfig, ax = plt.subplots()\nplt.scatter(adv[\"TV\"], adv[\"Sales\"], color=\"black\")\n\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$y$\")\n    \nX_line = np.arange(np.min(adv[\"TV\"]),np.max(adv[\"TV\"])*1.1, 0.1)\nY_line = predict(adv[\"TV\"], adv[\"Sales\"], parameters_simple, X_line)\nax.plot(X_line, Y_line, \"r\")\nax.plot(X_pred, Y_pred, \"bo\")\nplt.plot()\nplt.show()"
  },
  {
    "objectID": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#método-de-newton",
    "href": "Vida-Academica/Cursera/03-mod-otimizacao-redes-neurais.html#método-de-newton",
    "title": "Módulo 3: Otimização em redes neurais e método de Newton",
    "section": "Método de Newton",
    "text": "Método de Newton"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-1-derivadas-e-otimização",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-1-derivadas-e-otimização",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 1: Derivadas e otimização",
    "text": "Módulo 1: Derivadas e otimização"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-2-gradientes-e-gradient-descent",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-2-gradientes-e-gradient-descent",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 2: Gradientes e Gradient Descent",
    "text": "Módulo 2: Gradientes e Gradient Descent"
  },
  {
    "objectID": "Vida-Academica/Cursera/Calculo.html#módulo-3-otimização-em-redes-neurais-e-método-de-newton",
    "href": "Vida-Academica/Cursera/Calculo.html#módulo-3-otimização-em-redes-neurais-e-método-de-newton",
    "title": "Cálculo para aprendizado de máquina e ciência de dados",
    "section": "Módulo 3: Otimização em redes neurais e método de Newton",
    "text": "Módulo 3: Otimização em redes neurais e método de Newton"
  },
  {
    "objectID": "projetos-Python/posts/introducao-pandas.html",
    "href": "projetos-Python/posts/introducao-pandas.html",
    "title": "Análise exploratória de dados",
    "section": "",
    "text": "Este artigo foi reescrito em Domingo, 08 de Setembro de 2024."
  },
  {
    "objectID": "projetos-Python/posts/introducao-pandas.html#operações-básicas-com-o-pandas",
    "href": "projetos-Python/posts/introducao-pandas.html#operações-básicas-com-o-pandas",
    "title": "Análise exploratória de dados",
    "section": "Operações básicas com o Pandas",
    "text": "Operações básicas com o Pandas\nPodemos visualizar as primeiras linhas do nosso DataFrame com o comando df.head(). Para visualizar as últimas linhas, basta usar o comando df.tail().\n\n# Visualizando as primeiras linhas do DataFrame\ndf.head()\n\n\n\n\n\n\n\n\nCountry name\nyear\nLife Ladder\nLog GDP per capita\nSocial support\nHealthy life expectancy at birth\nFreedom to make life choices\nGenerosity\nPerceptions of corruption\nPositive affect\nNegative affect\n\n\n\n\n0\nAfghanistan\n2008\n3.724\n7.350\n0.451\n50.5\n0.718\n0.168\n0.882\n0.414\n0.258\n\n\n1\nAfghanistan\n2009\n4.402\n7.509\n0.552\n50.8\n0.679\n0.191\n0.850\n0.481\n0.237\n\n\n2\nAfghanistan\n2010\n4.758\n7.614\n0.539\n51.1\n0.600\n0.121\n0.707\n0.517\n0.275\n\n\n3\nAfghanistan\n2011\n3.832\n7.581\n0.521\n51.4\n0.496\n0.164\n0.731\n0.480\n0.267\n\n\n4\nAfghanistan\n2012\n3.783\n7.661\n0.521\n51.7\n0.531\n0.238\n0.776\n0.614\n0.268\n\n\n\n\n\n\n\n\n# Visualizando as últimas linhas do DataFrame\ndf.tail()\n\n\n\n\n\n\n\n\nCountry name\nyear\nLife Ladder\nLog GDP per capita\nSocial support\nHealthy life expectancy at birth\nFreedom to make life choices\nGenerosity\nPerceptions of corruption\nPositive affect\nNegative affect\n\n\n\n\n2194\nZimbabwe\n2018\n3.616\n7.783\n0.775\n52.625\n0.763\n-0.051\n0.844\n0.658\n0.212\n\n\n2195\nZimbabwe\n2019\n2.694\n7.698\n0.759\n53.100\n0.632\n-0.047\n0.831\n0.658\n0.235\n\n\n2196\nZimbabwe\n2020\n3.160\n7.596\n0.717\n53.575\n0.643\n0.006\n0.789\n0.661\n0.346\n\n\n2197\nZimbabwe\n2021\n3.155\n7.657\n0.685\n54.050\n0.668\n-0.076\n0.757\n0.610\n0.242\n\n\n2198\nZimbabwe\n2022\n3.296\n7.670\n0.666\n54.525\n0.652\n-0.070\n0.753\n0.641\n0.191\n\n\n\n\n\n\n\nPodemos visualizar os índices e nome das colunas do DataFrame com os comandos df.index e df.columns, respectivamente.\n\n# Visualizando os índices do DataFrame\ndf.index\n\nRangeIndex(start=0, stop=2199, step=1)\n\n\n\n# Visualizando os nomes das colunas do DataFrame\ndf.columns\n\nIndex(['Country name', 'year', 'Life Ladder', 'Log GDP per capita',\n       'Social support', 'Healthy life expectancy at birth',\n       'Freedom to make life choices', 'Generosity',\n       'Perceptions of corruption', 'Positive affect', 'Negative affect'],\n      dtype='object')\n\n\nComo vimos as colunas possuem espaços em seus nomes, para remover esses espaços podemos usar o comando df.columns = df.columns.str.replace(' ', '_').\n\n# Removendo os espaços dos nomes das colunas\ndf.columns = df.columns.str.replace(' ', '_')\n\nAlém disso, podemos colocar os nomes das colunas em minúsculo.\n\n# Colocando os nomes das colunas em minúsculo\ndf.columns = df.columns.str.lower()\n\n\n# Visualizando os nomes das colunas do DataFrame\ndf.columns\n\nIndex(['country_name', 'year', 'life_ladder', 'log_gdp_per_capita',\n       'social_support', 'healthy_life_expectancy_at_birth',\n       'freedom_to_make_life_choices', 'generosity',\n       'perceptions_of_corruption', 'positive_affect', 'negative_affect'],\n      dtype='object')\n\n\nPodemos visualizar as informações do DataFrame com o comando df.info(). Além disso, podemos visualizar o tipo dos dados de cada coluna com o comando df.dtypes.\n\n# Visualizando as informações do DataFrame\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2199 entries, 0 to 2198\nData columns (total 11 columns):\n #   Column                            Non-Null Count  Dtype  \n---  ------                            --------------  -----  \n 0   country_name                      2199 non-null   object \n 1   year                              2199 non-null   int64  \n 2   life_ladder                       2199 non-null   float64\n 3   log_gdp_per_capita                2179 non-null   float64\n 4   social_support                    2186 non-null   float64\n 5   healthy_life_expectancy_at_birth  2145 non-null   float64\n 6   freedom_to_make_life_choices      2166 non-null   float64\n 7   generosity                        2126 non-null   float64\n 8   perceptions_of_corruption         2083 non-null   float64\n 9   positive_affect                   2175 non-null   float64\n 10  negative_affect                   2183 non-null   float64\ndtypes: float64(9), int64(1), object(1)\nmemory usage: 189.1+ KB\n\n\n\n# Visualizando o tipo dos dados de cada coluna\ndf.dtypes\n\ncountry_name                         object\nyear                                  int64\nlife_ladder                         float64\nlog_gdp_per_capita                  float64\nsocial_support                      float64\nhealthy_life_expectancy_at_birth    float64\nfreedom_to_make_life_choices        float64\ngenerosity                          float64\nperceptions_of_corruption           float64\npositive_affect                     float64\nnegative_affect                     float64\ndtype: object"
  },
  {
    "objectID": "projetos-Python/posts/introducao-pandas.html#selecionando-colunas-do-dataframe",
    "href": "projetos-Python/posts/introducao-pandas.html#selecionando-colunas-do-dataframe",
    "title": "Análise exploratória de dados",
    "section": "Selecionando colunas do DataFrame",
    "text": "Selecionando colunas do DataFrame\nPodemos selecionar a coluna life_ladder do DataFrame com o comando df.life_ladder. Além disso, podemos selecionar mais de uma coluna passando uma lista com os nomes das colunas desejadas.\n\n# Selecionando a coluna life_ladder\nx = df.life_ladder\nprint(x)\n\n0       3.724\n1       4.402\n2       4.758\n3       3.832\n4       3.783\n        ...  \n2194    3.616\n2195    2.694\n2196    3.160\n2197    3.155\n2198    3.296\nName: life_ladder, Length: 2199, dtype: float64\n\n\nUma outra forma é passar o nome da coluna entre colchetes, como no exemplo abaixo.\n\n# Selecionando a coluna life_ladder\nx = df['life_ladder']\nprint(x)\n\n0       3.724\n1       4.402\n2       4.758\n3       3.832\n4       3.783\n        ...  \n2194    3.616\n2195    2.694\n2196    3.160\n2197    3.155\n2198    3.296\nName: life_ladder, Length: 2199, dtype: float64"
  },
  {
    "objectID": "projetos-Python/posts/introducao-pandas.html#selecionando-linhas-do-dataframe",
    "href": "projetos-Python/posts/introducao-pandas.html#selecionando-linhas-do-dataframe",
    "title": "Análise exploratória de dados",
    "section": "Selecionando linhas do DataFrame",
    "text": "Selecionando linhas do DataFrame\nPodemos selecionar as linhas de um DataFrame com o comando df[1:5].\n\n# Selecionando as linhas de 1 a 5\nx = df[1:5]\nprint(x)\n\n  country_name  year  life_ladder  log_gdp_per_capita  social_support  \\\n1  Afghanistan  2009        4.402               7.509           0.552   \n2  Afghanistan  2010        4.758               7.614           0.539   \n3  Afghanistan  2011        3.832               7.581           0.521   \n4  Afghanistan  2012        3.783               7.661           0.521   \n\n   healthy_life_expectancy_at_birth  freedom_to_make_life_choices  generosity  \\\n1                              50.8                         0.679       0.191   \n2                              51.1                         0.600       0.121   \n3                              51.4                         0.496       0.164   \n4                              51.7                         0.531       0.238   \n\n   perceptions_of_corruption  positive_affect  negative_affect  \n1                      0.850            0.481            0.237  \n2                      0.707            0.517            0.275  \n3                      0.731            0.480            0.267  \n4                      0.776            0.614            0.268"
  },
  {
    "objectID": "projetos-excel/index.html",
    "href": "projetos-excel/index.html",
    "title": "Projetos desenvolvidos em Excel",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "peojetos-SQL/index.html",
    "href": "peojetos-SQL/index.html",
    "title": "Projetos desenvolvidos em SQL",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n Back to top"
  }
]