{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Derivadas usando Sympy e Numpy\"\n",
        "subtitle: \"Derivadas com Python\"\n",
        "description: \"\"\n",
        "author: \"Wellington Santos Souza\"\n",
        "date: \"2024-08-23\"\n",
        "format: \n",
        "  html:\n",
        "    code-fold: true\n",
        "    code-copy: true\n",
        "    code-tools: true\n",
        "categories: [Derivadas, Python]\n",
        "open-graph:\n",
        "  description: \"Derivadas\"\n",
        "  image: ../images/02.calculo_python/derivadas.jpeg\n",
        "twitter-card:\n",
        "  description: \"Derivadas\"\n",
        "  image: ../images/02.calculo_python/derivadas.jpeg\n",
        "---\n",
        "\n",
        "\n",
        "*Este artigo foi reescrito em Sexta, 23 de Agosto de 2024.*\n",
        "\n",
        "![](../images/02.calculo_python/derivadas.jpeg){fig-alt=\"Python\" fig-title=\"Derivadas Usando Python\"}\n",
        "\n",
        "### Funções usando `Python`\n",
        "\n",
        "Para instalar as bibliotecas necessárias, use o comando: `!pip install sympy numpy`\n",
        "\n",
        "Usaremos as bibliotecas `Sympy`, `Numpy` e `JAX`\n",
        "\n",
        "**Definição de uma função usando Python**\n",
        "\n",
        "-   Se quisermos definir a função $f(x) = x^2$\n"
      ],
      "id": "3f39c863"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def f(x):\n",
        "    return x**2\n",
        "\n",
        "print(f(3))"
      ],
      "id": "1599d464",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos encontrar a derivada dessa função facilmente usando:\n"
      ],
      "id": "b9d7de03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def dfdx(x):\n",
        "    return 2*x\n",
        "\n",
        "print(dfdx(3))"
      ],
      "id": "c58e7e62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Além disso, podemos aplicar essa função e calcular a derivada para cada elemento de uma array criada com Numpy:\n"
      ],
      "id": "66a5795e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# primeiro importamos a biblioteca\n",
        "import numpy as np\n",
        "# criamos o array\n",
        "x_array = np.array([1, 2, 3])\n",
        "# calculamos x^2 para cada elemento do array \n",
        "#e depois calculamos a derivada para cada elemento\n",
        "print(\"x: \\n\", x_array)\n",
        "print(\"f(x) = x**2: \\n\", f(x_array))\n",
        "print(\"f'(x) = 2x: \\n\", dfdx(x_array))"
      ],
      "id": "341011c8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos também aplicar as funções f e dfdx para arrays maiores, além disso podemos plotar os gráficos de f e dfdx\n"
      ],
      "id": "59d58680"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def plot_f1_and_f2(f1, f2=None, x_min=-5, x_max=5, label1=\"f(x)\", label2=\"f'(x)\"):\n",
        "    x = np.linspace(x_min, x_max,100)\n",
        "\n",
        " \n",
        "    fig = plt.figure()\n",
        "    ax = fig.add_subplot(1, 1, 1)\n",
        "    ax.spines['left'].set_position('center')\n",
        "    ax.spines['bottom'].set_position('zero')\n",
        "    ax.spines['right'].set_color('none')\n",
        "    ax.spines['top'].set_color('none')\n",
        "    ax.xaxis.set_ticks_position('bottom')\n",
        "    ax.yaxis.set_ticks_position('left')\n",
        "\n",
        "    plt.plot(x, f1(x), 'r', label=label1)\n",
        "    if not f2 is None:\n",
        "             \n",
        "        if isinstance(f2, np.ndarray):\n",
        "            plt.plot(x, f2, 'bo', markersize=3, label=label2,)\n",
        "        else:\n",
        "            plt.plot(x, f2(x), 'b', label=label2)\n",
        "    plt.legend()\n",
        "\n",
        "    plt.show()\n",
        "    \n",
        "plot_f1_and_f2(f, dfdx)"
      ],
      "id": "507d3c08",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Derivadas simbólicas\n",
        "\n",
        "**Computação simbólica** lida com a computação de objetos matemáticos que são representados na forma exata, e não aproximadamente (por exemplo, $\\sqrt{2}$ será escrito exatamente assim, e não como $1.41421356237$. Para a derivada, isso significa que o resultado será de certa forma semelhante ao que seria se você estivesse calculando derivadas manualmente usando regras (analiticamente). Assim, derivadas simbólicas podem produzir resultados exatos.\n",
        "\n",
        "-   Derivadas simbólicas em `Python` usando a biblioteca `SymPy`.\n",
        "\n",
        "-   Podemos calcular o valor decimal aproximado de $\\sqrt{18}$\n"
      ],
      "id": "bb596eba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import math\n",
        "\n",
        "math.sqrt(18)"
      ],
      "id": "cbf9f68a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Introdução à Computação Simbólica com `SymPy`**\n",
        "\n",
        "-   O valor obtido é: $4.242640687119285$\n",
        "\n",
        "Agora se quisermos calcular: $\\sqrt{18} = \\sqrt{9 \\cdot 2} = 3\\sqrt{2}$\n"
      ],
      "id": "0386f8e0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Esse formato de importação de módulo permite\n",
        "# usar as funções sympy sem o prefixo sympy.\n",
        "from sympy import *\n",
        "\n",
        "# Na verdade, essa é a função sympy.sqrt,\n",
        "# mas o prefixo sympy. foi omitido.\n",
        "sqrt(18)"
      ],
      "id": "3c3030b6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Para obtermos o valor aproximado fazemos\n"
      ],
      "id": "851967cf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "N(sqrt(18))"
      ],
      "id": "d2a6908f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "No SymPy, as variáveis são definidas usando símbolos. Nesta biblioteca específica, elas precisam ser pré-definidas (uma lista delas deve ser fornecida). Veja na célula abaixo como a expressão simbólica, correspondente à expressão matemática $2x^2 - xy$, é definida:\n"
      ],
      "id": "78f01b7d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Lista de símboos\n",
        "x, y = symbols('x y')\n",
        "# Definição da expressão.\n",
        "expr = 2 * x**2 - x * y\n",
        "expr"
      ],
      "id": "80ddf772",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Pode realizar várias manipulações com essa expressão: adicionar ou subtrair alguns termos, multiplicar por outras expressões, etc., assim como se estivesse fazendo isso manualmente:\n"
      ],
      "id": "922d3a1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "expr_manip = x * (expr + x * y + x**3)\n",
        "expr_manip"
      ],
      "id": "d79f9708",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Agora, vamos calcular a derivada da expressão $2x^2 - xy$ em relação a $x$:\n"
      ],
      "id": "b6449ea3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Derivada da expressão em relação a x.\n",
        "diff(expr, x)"
      ],
      "id": "16c284ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos expandir a função expr_manipulada para obter a expressão completa:\n"
      ],
      "id": "b520c577"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "expand(expr_manip)"
      ],
      "id": "a40836c8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos também simplificar a expressão:\n"
      ],
      "id": "19c7032c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "simplify(expr_manip)"
      ],
      "id": "3de0fb70",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Também podemos fatorear a expressão:\n"
      ],
      "id": "a746ec9a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "factor(expr_manip)"
      ],
      "id": "dbb1f170",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos também resolver equações simbolicamente:\n"
      ],
      "id": "8ca521c0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Resolvendo a equação x^2 - 1 = 0.\n",
        "solve(x**2 - 1, x)"
      ],
      "id": "676d3e33",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos substituir valores específicos para as variáveis na expressão\n"
      ],
      "id": "613a7f73"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "expr.evalf(subs={x:-1, y:2})"
      ],
      "id": "30977231",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Isso pode ser usado para avaliar uma função $f\\left(x\\right) = x^2$:\n"
      ],
      "id": "5aa2da55"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f_symb = x ** 2\n",
        "f_symb.evalf(subs={x:3})"
      ],
      "id": "6c69ad00",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Podemos avaliar uma função simbólica para cada elemento de uma matriz:\n"
      ],
      "id": "c816688c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Definindo uma matriz simbólica.\n",
        "\n",
        "x_array = np.array([1, 2, 3])\n",
        "\n",
        "try:\n",
        "    f_symb(x_array)\n",
        "except TypeError as err:\n",
        "    print(err)\n",
        "# Convertendo a função simbólica em uma função numpy.\n",
        "from sympy.utilities.lambdify import lambdify\n",
        "\n",
        "f_symb_numpy = lambdify(x, f_symb, 'numpy')\n",
        "\n",
        "print(\"x: \\n\", x_array)\n",
        "print(\"f(x) = x**2: \\n\", f_symb_numpy(x_array))"
      ],
      "id": "079a75b3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Derivadas Simbólicas com `SymPy`\n",
        "\n",
        "Se quisermos calcular a derivada da função $f(x) = x^2$ simbolicamente, podemos fazer isso com o `SymPy`:\n"
      ],
      "id": "689db056"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Definindo a função simbólica.\n",
        "f_symb = x ** 2\n",
        "# Calculando a derivada da função simbólica.\n",
        "dfdx_symb = diff(f_symb, x)\n",
        "dfdx_symb"
      ],
      "id": "7c51eea1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "O Sympy aplica todas as regras de derivação para obter a derivada da função $(exp(-2x) + 3sin(3x), x)$:\n"
      ],
      "id": "567c34bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f_symb = exp(-2*x) + 3*sin(3*x)\n",
        "dfdx_symb = diff(f_symb, x)\n",
        "f_symb, dfdx_symb"
      ],
      "id": "85fed8e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Agora vamos plotar a função e sua derivada:\n"
      ],
      "id": "9ff913c2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f_symb_numpy = lambdify(x, f_symb, 'numpy')\n",
        "dfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n",
        "\n",
        "plot_f1_and_f2(f_symb_numpy, dfdx_symb_numpy)"
      ],
      "id": "1b191988",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Agora vamos calcular a derivada da função $f(x) = 2x$ simbolicamente:\n"
      ],
      "id": "7043b059"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f_symb_numpy = lambdify(x, f_symb, 'numpy')\n",
        "\n",
        "dfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n",
        "\n",
        "print(\"x: \\n\", x_array)\n",
        "print(\"f'(x) = 2x: \\n\", dfdx_symb_numpy(x_array))"
      ],
      "id": "68594526",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Agora vamos plotar a função e sua derivada:\n"
      ],
      "id": "fed7b315"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# plote a função e sua derivada\n",
        "plot_f1_and_f2(f_symb_numpy, dfdx_symb_numpy)"
      ],
      "id": "3beb987d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Limitações da derivada simbólica\n",
        "\n",
        "-   Às vezes, as expressões de saída são muito complicadas e até mesmo impossíveis de serem avaliadas. Por exemplo, encontrar a derivada da função.\n",
        "\n",
        "$$\\left|x\\right| = \\begin{cases} x, \\ \\text{if}\\ x > 0\\\\  -x, \\ \\text{if}\\ x < 0 \\\\ 0, \\ \\text{if}\\ x = 0\\end{cases}$$ Analiticamente, anderivada é: $$\\frac{d}{dx}\\left(\\left|x\\right|\\right) = \\begin{cases} 1, \\ \\text{if}\\ x > 0\\\\  -1, \\ \\text{if}\\ x < 0\\\\\\ \\text{does not exist}, \\ \\text{if}\\ x = 0\\end{cases}$$\n",
        "Podemos calcular a derivada da função $f(x) = \\left|x\\right|$ simbolicamente:"
      ],
      "id": "470fb0e7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dfdx_abs = diff(abs(x),x)\n",
        "dfdx_abs"
      ],
      "id": "87c5c334",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Outro exemplo $x=-2$:"
      ],
      "id": "efb9a816"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dfdx_abs.evalf(subs={x:-2})"
      ],
      "id": "0bde3bc5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "De fato, há problemas com a avaliação das expressões simbólicas sempre que há um \"salto\" na derivada (por exemplo, as expressões da função são diferentes para diferentes intervalos de $x$), como acontece com $\\frac{d}{dx}(|x|)$.\n",
        "\n",
        "Além disso, você pode ver neste exemplo que é possível obter uma função muito complicada como resultado da computação simbólica. Isso é chamado de aumento de expressão, que resulta em cálculos não suficientemente lentos. \n",
        "\n",
        "# Derivadas Numéricas\n",
        "\n",
        "**Derivadas Numéricas** são calculadas numericamente, ou seja, aproximadamente. Isso significa que a derivada é calculada para um valor específico de $x$ e é uma aproximação do valor real da derivada. A precisão da derivada numérica depende do valor de $h$ (o passo de Derivada). Quanto menor o valor de $h$, mais precisa será a derivada, mas também mais lenta será a computação.\n",
        "\n",
        "#### Derivadas numéricas em `Python` usando a biblioteca `NumPy`."
      ],
      "id": "54ab7bfb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x_array_2 = np.linspace(-5, 5, 100)\n",
        "dfdx_numerical = np.gradient(f(x_array_2), x_array_2)\n",
        "\n",
        "plot_f1_and_f2(dfdx_symb_numpy, dfdx_numerical, label1=\"f'(x) exact\", label2=\"f'(x) approximate\")"
      ],
      "id": "1074ec49",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dfdx_composed = diff(exp(-2*x) + 3*sin(3*x), x)\n",
        "dfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n",
        "# plote a função e sua derivada\n",
        "def f_composed(x):\n",
        "    return np.exp(-2*x) + 3*np.sin(3*x)\n",
        "\n",
        "plot_f1_and_f2(lambdify(x, dfdx_composed, 'numpy'), np.gradient(f_composed(x_array_2), x_array_2),\n",
        "              label1=\"f'(x) exact\", label2=\"f'(x) approximate\")"
      ],
      "id": "1232c074",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Obviamente, a primeira desvantagem da Derivada numérica é que ela não é exata. No entanto, sua precisão normalmente é suficiente para aplicativos de aprendizado de máquina. Nesse estágio, não há necessidade de avaliar os erros da Derivada numérica.\n",
        "\n",
        "Outro problema é semelhante ao que apareceu na Derivada simbólica: ela é imprecisa nos pontos em que há \"saltos\" da derivada. Vamos comparar a derivada exata da função de valor absoluto e a aproximação numérica:\n"
      ],
      "id": "830ed19c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def dfdx_abs(x):\n",
        "    if x > 0:\n",
        "        return 1\n",
        "    else:\n",
        "        if x < 0:\n",
        "            return -1\n",
        "        else:\n",
        "            return None\n",
        "\n",
        "plot_f1_and_f2(np.vectorize(dfdx_abs), np.gradient(abs(x_array_2), x_array_2))"
      ],
      "id": "4fa15d4e",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}